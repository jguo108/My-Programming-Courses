# 5 Dodge the Ball

### Objectives

### Background

### Project

### What to learn

### Lesson Plan

| Step | Details |
| --- | --- |
| Introduction | * In lesson “[Turtle Crossing](turtle cross)”, our little turtle has to face its worst nightmare: the crabs. But you know what is the worst nightmare of the crabs? Yes, it’s the octopus! The octopus will happily take the crabs for a nice meal! 
* In today’s lesson, we are going to create a doge game where you, the crab, is going to try your best to avoid the water cannonballs fired from a gang of evil octopus! Each time you are hit, your health level drops, and as soon as it drops to 0, the game ends. So try to stay alive for as long as you can!
* We are going to learn … |
| Backdrop | * Ok, so because the battle is going to happen deep in the ocean, let’s change the backdrop first. Go the stage and click the “backdrop” tab. Select the “backdrop” image from the resources folder. Voila, we are in the ocean now. Nice! |
| Crab (add to project) | * Next, let’s add a Crab sprite by choosing the “crab” image from the Resources folder. Adjust its size accordingly.
* OK, in lesson “[Race to the Island](../Level2%20f841ea788a6f412db7884de2c891457c/10%20Race%20to%20the%20Island%208d244dc379844c1e85601f7a2302e706.md)”, we have learnt a common code pattern for games: you have two phases, in the first “Setup” phase, well, we set everything up, for example, moving each sprite to their initial position, switching to the right costume, etc. Just anything that needs to be done once before the game starts. In the second “Run”, basically you just tell every sprite “off you go and do whatever you were told to do”. So this is when you control the movement of your character, get the enemies to move and attack etc. So in this project, we are going to follow this same pattern again.
* Now, to code this two-phase pattern, if you can still recall from lesson “[Race to the Island](../Level2%20f841ea788a6f412db7884de2c891457c/10%20Race%20to%20the%20Island%208d244dc379844c1e85601f7a2302e706.md)”, we need to broadcast two messages to everybody in the game, this first one is “Setup” and the other one is “Run”. Now, who is going to broadcast these two messages when the game starts is totally up to you. In theory, you can let any sprite to broadcast them. But it is exactly because you can make any sprite to broadcast them, to make things fair among all sprite, I always choose to let the Stage to do the broadcast. |
| Stage broadcast two-phase messages | * So, go to the Stage, when green flag is clicked, we first broadcast the “Setup” message. Now, a question for you: should we use “broadcast” or “broadcast and wait”? Remember in lesson “[Race to the Island](../Level2%20f841ea788a6f412db7884de2c891457c/10%20Race%20to%20the%20Island%208d244dc379844c1e85601f7a2302e706.md)”, we need to wait for the 3, 2, 1 countdown to complete when setting up? In general, we want to wait for everybody to finish setting up before we can start to run the game. So we need to broadcast a “Setup” message and wait. Then, when everybody is ready, we can then broadcast a “Run” message. |
| Crab (movement) | * OK, back to the Crab sprite. Now let’s think about what it needs to do when receiving the “Setup” message. For the Crab, there is nothing too much to do here. Probably we can just make it start from the center of the stage by moving to x 0 and y 0. That’s it.
* Next, things should really start get going when it receives the “Run” message. More specifically, we want to able to control the crab’s movement by using the four arrow keys on the keyboard. Now we have done exactly the same thing in lesson “[Escape Room](../Level2%20f841ea788a6f412db7884de2c891457c/13%20Escape%20Room%20343925c206954817b27e356e7d66d8fe.md)”. There, we also control the player using the arrow keys. Since there is nothing new here, I will just quickly finish the code.
* First, when the crab receives the “Run” message, add a “forever” loop. Inside the loop, we check if each arrow key is pressed, and if so, we change either the x or the y position by a small number. In this, I choose 3 or -3. You can experiment with different number if you want to crab to move faster or slower. 
* Test. OK, we can now press the arrow keys to move the crab around in the ocean. Cool! |
| Octopus | * Ok, a crab moving aimlessly in ocean is not that much of a game, right? We need some enemies! As I said in the beginning, octopus loves crabs! Let’s add one! Add the Octopus sprite by choosing the “octopus” image from the Resources folder. 
* Similar to the Crab sprite, let’s also think about what the octopus needs to do when it receives the “Setup” message. Again, nothing too much, probably still just going to some initial position. Since the Crab already starts at the center of the stage, we do not want the Octopus to also start from there. So let’s just make it go to some random position. 
* Next, let’s think about how the octopus should move when the game starts to run. The Octopus is going to wander freely in the ocean non-stop. When it receives the “Run” message, it forever moves one step and then checks if it is touching the edge, and if so, bounce back.  
* Test. Now we have a hungry and deadly octopus floating around in the ocean, ready to attack! |
| Cannonball (Movement) | * But the octopus is too slow to catch our crab directly. So it needs to be smarter and use some secret weapon. And that secret weapon is water cannonballs! If our crab gets hit by such cannonball, damage will be caused. The crab can only take so many hits before it gets killed and become the octopus’s dinner.
* So we need a cannonball for the Octopus to fire. Add this sprite by going the Resources folder and select the “cannonball” image. This is too big, let’s adjust its size accordingly. When the game is setting up, we don’t want to see the cannonball, so let’s hide it first.
* Now, after the game starts to run, we want the Cannonball to be fired from the where the Octopus is and aim towards the crab. For this, we first move it to the Octopus using the “go to Octopus” block, then point it to the crab using the “point towards Octopus” block. After running these two blocks, the cannonball is now at the right start position, aiming at the crab, ready to be fired. Of course, before that, we need to show it because it was hidden initially. Finally, all the blocks here need to be put inside a forever loop to keep the cannonball following the Octopus.
* Test. Ok, nothing seems to be different from before. Even though the cannonball is now following the Octopus, but because it is behind the Octopus, it is completely hidden from us. Just to make it more obvious, we can temporarily change the size of the cannonball to 500. Now, run the program again, you can clearly see that it is behind the Octopus and following it all the time. You can also take a look at the x position and y position of the Cannonball. They change as the Octopus’s position changes. Also, its direction changes as we move the Crab because it needs to face towards the crab at all times. Ok, change the size back to 100.
* Now the cannonball is at position and aiming at the target. Next, how do we make it fired? Easy! just move it in the direction of the crab! How many steps to move? I’m don’t know, let’s just use a forever loop and move, say 5 steps, at a time. 
* Test. Ok, the cannonball fires from the Octopus straight at the crab! Cool!
* Problem: But there are two problems: first, when the cannonball reaches the edge, it gets stuck and stays there forever; second, our octopus can only fire one cannonball at the crab and if it misses the target, that’s it, no more cannonballs! 
* Solution: The first problem occurs because we move the cannonball 5 steps at a time FOREVER! So even after it reaches the edge, it still tries to move 5 steps forwards again and again, this clearly leads to nowhere and it gets stuck. So instead of forever moving forward, it should only move until it touches the edge. We can replace this forever loop with a “repeat until” loop and use “touching edge” as the condition.
* Test. Now watch what happened, when the cannonball reaches the edge, it disappears and the Octopus fires another one right away. But you might be thinking: we did not hide the cannonball, so why has it gone? And also where is this new cannonball coming from?It seems that just by using the “repeat until” loop, we have magically solved both problems! Well, the answer is that the new cannonball did not disappear, it simply goes back to the Octopus and gets fired again after touching the edge! Take a look back at the code, when it reaches the edge, the “repeat until” loop finishes, and this forever loop starts a new iteration, so the cannonball goes to the Octopus again, aims at the crab and moves forward one more time. The reason this did not happen when we use a forever loop to move the cannonball is because the inner forever loop never finishes, and therefore the outer forever loop never gets a chance to run another iteration. Cool, we killed two birds with one stone! |
| Health (Reduce health) | * Now, when the cannonball hits the crab, nothing happens, it just passes through and moves on. This means our Crab is invincible! Well, being invincible in real life is pretty damn awesome, and we all want that. But for character to be invincible in a game is not so much fun! Let’s cause some damage to our Crab!
* It’s very common in games to have some kind of “Health” level for a player. Whenever it gets hit by enemies, the level drops and the player becomes less “healthy”. If somehow the health level drops to 0, the player is considered dead and the game ends. Following this idea, let’s go to the Crab sprite and create a “health” variable to store its health level. Now, we are faced with the same question again, should this variable be local or global. Ok, I have to admit that sometimes it is not clear which one is appropriate when you are creating the variable. That’s totally fine. If this is the case, I would suggest to always make it local by choosing “For this sprite only”. If later you find out that this variable is actually going to be used by many different sprites, you can always come back and change it to global if needed, no big deal. So let’s set it to local for the time being. Ok, when the Crab is setting up, we want to set “health” to, say 10.
* Now, with the Crab having a health level now, we can finally cause some damage: simply reduce the “health” variable by one for example whenever it is hit by a cannonball. The next question then becomes: where do we do this? Well, because the health is going to be reduced when the crab and the cannonball touches each other, so it must be either in the Crab sprite or the Cannonball sprite. Let’s first see what is going to be like if we do it in the Crab sprite. We can add another “When I received Run” hat block, use a forever loop to check if it is touching the Cannonball, and if so, reduces the health by 1.
* Test. Now, whenever the crab is hit by the cannon ball, its health drops. 
* Problem: But here is a problem: when the crab is hit by the cannonball, its health drops a lot more than just one. See, it goes from 10 to 3 after the hit! What is happening here? Well, well, well, there is nothing mysterious here and we have come across the exact problem before! Can you recall which lesson is that? Yes, it is the lesson “[Keep it alive](../Level2%20f841ea788a6f412db7884de2c891457c/9%20Keep%20it%20Alive%20254a7d3e5a3341baaeaf5ac7bbec6f41.md)”, there, the dragonfly bumps up its energy by eating insects. But when it does that initially, it’s energy increases quite a bit every time it touches an insect. And the reason is that, when the two start to touch each other, since the insect is not hidden, as they continue to move, they are touching each other again and again until they are finally not overlapping anymore. In this process, each time they touch, the energy level increases by one. And the solution there was pretty simple, we just hide the insect as soon as they touch, and because a hidden sprite cannot collide with any other sprite, the energy level will only increase once. Simple! Now, back to our problem here, do you it is any different from that one? No, they are exactly the same problem. And the reason why “Health” drop so much is exactly because when the two hit each other, since the cannonball is not hidden, they will just continue to touch each other again and again. As the result, health is dropped again and again! 
* Solution: Well, since the problem is exactly the same, the solution will be exactly the same too! All we need to do is just to hide the cannonball once it touches the crab. So in the “repeat until” loop before the move (Something weird is going on there, if I put the check after the move block, health did not drop when it hits the crab. Need to figure out why is this), we also check if it is touching the crab, and if so, we hide it.
* Test. Now, as soon as the cannonball hits the crab, it disappears and the health is only reduced by one this time. Nice.
* Problem: Now, previously, when considered whether we should check the collision in the Crab sprite or in the Cannonball sprite, we decided to put it in the Crab sprite. But because of the collision problem we had, we have to check the collision also in the Cannonball sprite. Ok, that seems to be a bit redundant: we are essentially checking the collision twice: once in the Crab and once in the Cannonball. Now, redundancy is always considered evil in coding. 
* Solution: So let’s see if we can remove one of these two checks. Do you think we can remove the collision check from the Cannonball sprite? I don’t think so. If we remove it, how can we otherwise hide it? Ok, fair enough. Then can we remove the check from the Crab sprite? What does it do when it touches the cannonball, it just reduces “health” by one. Can we do that in the Cannonball sprite? Yes, there is nothing preventing it from reducing “health” by one! All we need to do is change the “health” variable by -1 when it touches the Crab.
* Problem: Hmmm….but it seems that we cannot find the “health” variable from the dropdown of the “change variable” block? Actually, if you go to the Variable category, you don’t see the “health” variable there! Why is that? 
* Solution: Well, if you don’t see a variable in a sprite, it means that this variable is not global and is only   local to another sprite? Which sprite? The Crab sprite. Remember, when we create the “health” variable in the Crab sprite, I set it to local by choosing “For this sprite” only, and I said it’s always a good idea to set a variable local if you do not know which one to choose. If it turns out that the variable should be global, you can always go back and change it, no big ideal! So here is the time when we need to go back to the “health” variable and make it global again. Go to the Crab sprite, right click the “health” variable, choose “rename or edit variable” and set it to “For all sprites”. Now, go back to the Cannonball sprite, this time, if we click the dropdown, we can see and select the “Health” variable. Cool! Since we are reducing “health” here, we can now delete this script from the Crab sprite. 
* Test. Let’s test this again. Same as before, as soon as the cannonball hits the crab, it disappears and the health is only reduced by one this time. Cool!
* Problem: If we play the game for bit longer, when “health” drops to zero, we can continue to play. And if the crab gets more hits, “health” keeps dropping to become negative numbers. This is not what we expect! Instead, the game should end as soon as “health” reaches 0. 
* Solution: OK, this is not hard: after reducing “health” by one, we check if it is zero now, if so, we stop everything.
* Test. Now, when “health” reaches zero, everything stops and the game ends. Ok, in lesson “[Robot’s Breakfast](2%20Robot%E2%80%99s%20Breakfast%202d02d8e040124d88b8d1ad1664f3820d.md)”, I said that “stop all” stops everything thing right away, so no sprite can and a chance to do anything else, for example, reporting how well the player has done. This is true and as a game designer, you should always think about how the game should end, this is also part of the game. And we have seen some less brutal way of ending a game in that lesson. Here, we might do something similar or maybe just leave that as an exercise for you. For the time being, I will just keep it simple and stop everything once health becomes zero. |
| Cannonball (Hit crab but still moves forward. Failed attempts to solve this problem) | * Problem: For those of you who pay attention to every tiny detail, you might have noticed a slightly odd behavior: when a cannonball hits the crab, the Octopus did not fire the next one right away. Instead, there is always a small delay before the next one is fired. OK, I know this is not an huge issue and in fact, if I haven’t told you, you might not ever notice this at all! But what I really want is for the Octopus to fire the next cannonball as soon as the previous one hits the crab. Ok, let’s first figure out why it is not doing this now. Take a look at this repeat until loop again. If the cannonball touches the crab, it hides, decreases the “health” variable, and if health becomes zero, stops everything. Now, this outer “if then” block complete, and the script carries on with this move block. Essentially, after the collision, the cannonball keeps moving forward for 5 steps. Because it is now hidden, and as we know, a hidden sprite does not collide with anyone, the cannonball just runs this repeat until loop again and again, each time moving 5 steps forward until it finally reaches the edge. In other words, after the initial collision, the cannonball hides itself but keeps moving forwards. This continues until it reaches the edge, at which point it goes back to the Octopus and fires from there again. And this is where the small delay comes from.
* Solution: So to avoid having this delay and make the cannonball fire from the Octopus as soon as it hits the crab, what we really want is to stop moving it as soon as the two touch each other. Now, what code is responsible for moving the cannonball? Yes, it is this “repeat until” loop, so we want to stop this loop when the collision happens. Where do we check if the collision happens? Yes, inside this “if then” block. So we need some magic inside this “if then” block to stop the whole “repeat until” loop here. Ok, what is that magic? Well, because we are stopping something, so sounds we need the “stop” block. Let’s add one inside the “if then” block at the very end. Do you think that would solve our problem? Let’s find out!
* Test. Ouch! As soon as the cannonball hits the crab, it’s health drops by one, but then everyone stops, and the game ends! Why it that? Well, because you tell it to stop all when it touches the crab! Right? So clearly, stopping all is not going to work here. 
* Solution: You might say “Ok, that’s fine. But what about the other options of the stop block. How about stopping this script instead?” Let’s give that a try!
* Test. Ok, it hits the crab, and this time it seems better, at least the game has not ended: we can still move the crab and the octopus is still chasing us. But there is a big problem, can you spot it? Yes, after the first cannonball, the Octopus is not firing any more! Why is that?
* Solution: Well, let ask you a question, which script is responsible for firing the cannonball again and again from the Octopus? Yes, it is this “Run” script here. But do you still remember what we have done to this script when the cannonball hits the crab? Yes! We stop this script! What is “this script”? It is whichever script that contains the “stop” block, so it is the “Run” script here, it has been stopped! If it has been stopped, then how can you still expect the cannonball to be fired from the Octopus again and again? Ok, that leaves us with the final option: stop other scripts in sprite. But I’m not even bother to try it, because, well are there any other scripts in this sprite? Well, yes there is a “Setup” script here, but by the time we are at the “Run” script, it has already completed. If you stop other scripts of this script, what are you stopping? Nothing! There are no other scripts for you to stop! So clearly this wouldn’t solve our problem either! Hmmm….looks like we are stuck! What can we do? |
| Cannonball (Hit crab but still moves forward. Use custom block to solve this problem) | * Ok, I think it should be clear by now that neither “stop all” nor “stop other scripts in sprite” would work in a million years! “Stop this script” looks like to be the only one that might work if we can play some magic. 
* Right now, “stop this script” does not work because it not only stops this “repeat until” loop but also stops the entire “Run” script. Right? Because “stop this script” block stops whichever script it belongs to. So to just stop the “repeat until” loop using “stop this script”, we need to separate it from the “Run” script to become a script of its own, like this. But as it stands now, this repeat loop will not run at all. Because you can only run a script that starts with a hat block and clearly this is not the case here. But after last lesson “[Be a Block Builder](4%20Be%20a%20Block%20Builder%203702a91016794eb48dfb80662b1e7069.md)”, we have learnt another way to run a separate script: turn that script into a custom block and then call this custom block from somewhere else! Let’s see if that helps here.
* What we have right now is a separate script consisting of a “repeat until” loop and we want to run it from the forever loop in the Run script. Seems like a perfect case for a custom block. What the repeat loop doing is firing the cannonball, so let’s create a custom block and name it “Fire”. Now, let’s move the this script under the “Fire” definition block. Then all we need to do to run it is to add the “Fire” custom block inside the forever loop, just after the “show” block.
* Ok, you might be wondering, how is this going to help with solving our initial problem? How can that make the the cannonball fires again immediately after it hits the crab? Well, 
remember, the “stop this script” blocks stops which ever script that it belongs to, right? Now, which script does it belong to now? Yes, it belongs to the repeat until loop now. So which script do you think it is going to stop when the cannonball touches the crab? Yes, it only stops this “Fire” custom block and not the entire “Run” script as before. Now as soon as the “Fire” custom block is stopped, the forever loop in the “Run” script iterates again, and moves the cannonball back the to Octopus and fires from there again.
* Test. So let’s prove that! Run the program. Now, see? As soon as the cannonball hits the crab, the Octopus immediately fires the next one. There is no waiting for the cannonball to reach the edge anymore. Perfect!
* Since we are starting to use custom blocks to organize our code here, let’s take one step further. Take a look at the first three blocks in the forever loop: go to, point towards, and show, what do you thinks these three blocks together are doing? I think they are here to get the cannonball ready right? Go to the start position, aim at the right target and then show up. So why not put they into a custom block too? Let’s create another custom block named “Ready”, move these three under “Ready” definition block and place the “Ready” custom block before “Fire”. Ok, after this, take a look at the forever loop again, isn’t that super clean and clear now? We can immediately tell that, when the program starts to run, all the cannonball sprite does is getting ready and firing at the Crab again and again. So easy to understand!
* Test. Now let’s test the program again just to check that we have not broken anything. No, it works as before, perfect!  |
| Use Cannonball clones to fire more often | * Ok, so far so good. But there is a severe limitation regarding the Octopus firing capability. Currently, it can only fire one cannonball at a time. This is because we only have one cannonball sprite, and it can only go back to the octopus to fire again when it either hits the crab or reaches the edge. Ok, some people might be ok with this design. But I really want the Octopus to be able to fire more than one cannonballs at a time. For example, there might be two, three or even more cannonballs flying towards the Crab at the same time, and this is definitely going to make the game more challenging. So let’s see how this can be done!
* Now, because we want more than one cannonball sprite to be fired from the Octopus, and whenever you want more of a sprite, you should think about using Clones. The idea is that after the program starts, we should create cannonball clones one after the other non-stop, and for each newly created clone, it gets ready and fires from the Octopus. So, let’s see how to change the code to match this idea.
* In the Run script, instead of getting ready and fire again and again for the parent cannonball sprite, we instead create clones of it again and again. Now when a clone is created what should it do? Simple, just get ready and fire!
* Test. Let’s test this out! 
* Problem: Wowowowo, there are a ton of cannonballs firing from the Octopus and hitting the crab. We don’t even have a chance to move the crab before the game is over! So clearly, we go from firing only one cannonball at a time to firing too many and too frequently. 
* Solution: So slow down the firing, we can wait for one second after creating each cannonball clone. So the Octopus is going to fire cannonballs at one second interval.
* Test. Now, this is much better, we are having more cannonballs fired at the same time, but not too many. Cool.
* Problem: But clearly there is a problem here, all the cannonballs that are fired exist for forever: the ones that reaches the edge just stay there. The ones that hits the crab might look like they are gone, but it is just because they are hidden. Why do I know that? Take a look at the clone counter when a cannonball clone hits the crab, did it decrease? No, meaning the clone still exists. 
* Solution: From lesson “[Robot’s Breakfast](2%20Robot%E2%80%99s%20Breakfast%202d02d8e040124d88b8d1ad1664f3820d.md)”, we have learnt that when a clone is not needed anymore, it should be deleted with the “delete this clone” block. Here, when is a clone no longer needed? Two cases: when it reaches the edge or when it hits the crab. So let’s delete this clone after the repeat until loop, this is when it reaches the edge. When it hits the crab, we can replace the “stop this script” block by the “delete this clone” block. This is because whenever you delete a clone, this also stops this script because, well, if the clone is gone, who is going the run this script? 
* Test. Now, when the cannonball clones reach the edge or hit the crab, they are actually deleted, gone forever. This is clear from the clone counter, which stays at around 3 or 4 and never goes beyond. Nice! |
| More Octopus | * As it stands right now, the game is not very challenging, our crab can easily avoid all cannonballs fired from the single Octopus. We can make it more fun by adding more Octopus, each of them is going to fire cannonballs at our crab and the more Octopus we have, the more difficult the game becomes. 
* Ok, by now, whenever you hear something like “we need more of this sprite”, it should come immediately to your mind that we need to use clones. And yes, we are going to add more Octopus using clones too! Let’s see what changes are needed for the code.
* Ok, our goal is to have three Octopus, so we need to create three clones. Also, because we don’t want the parent sprite to show up, let’s hide it when receiving the setup message. Now when the program starts to run, we want to create those three clones. So repeat three times and each time create a clone of myself. What is the Octopus clone going to do once it is created? Well, it is going to float around in the ocean. So let’s move this forever loop under the “When I start as a clone” hat block. Also, the parent sprite does not need to move to a random position, since it is hidden anyway. Instead, each clone needs to move to random position when it starts. So let’s move the “go to random position” block to the clone.
* Test. 
* Problem: Ha, this is strange, we only see the cannonballs firing at our crab, but not a single Octopus can be seen. What is going on here? Well, remember, the parent sprite is hidden during setup. So later when we create clones from it, those clones will also be hidden. 
* Solution: The solution is simple, all we need to do is just add a “show” block tp the clone code.
* Test. Ok, we have three Octopus floating in the ocean now.  |
| Cannonballs fired from Octopus clones | * Problem: But there is something weird going on, it seems that all the cannonballs are now firing without an Octopus! What is going on here? Any idea? The truth is that, it is fired from a hidden Octopus! A hidden Octopus? Which one? Remember we hide the parent Octopus, right? So all the cannonballs are now firing from the hidden parent Octopus. This tells us something: take a look at the “Fire” custom block, when we move the cannonball clone to the Octopus using the “go to Octopus” block, it always goes to the parent sprite and never to any of its clones. However, what we really want is for the cannonballs to fire from those three clones rather than the parent sprite. Unfortunately, what we are seeing here is the exact opposite: the cannonball is fired from the hidden parent sprite and not the other three clones. 
I have to say, this is going to be a fairly difficult problem to solve. But as always, when you are faced with such situation, break it down into smaller sub-problems and solve them one at a time. There is nothing to worry about and let’s take on the challenge together!
* Solution: Take a look at the “Run” script of the Cannonball sprite. The forever loop is creating a single cannonball clone for a single Octopus each time it iterates. Which Octopus? Well, as we have already seen before, all cannonballs are for the hidden parent sprite as they are all fired from there. But since we have three Octopus now, we need to create three cannonball clones for each iteration of the loop, one for each Octopus. So instead of just creating a single clone, we use a repeat loop to create three.
* Test. Let’s run this. Now, the cannonballs are fired in a group of three each time. This makes sense, because for each iteration of the forever loop, we create three clones instead of one.
* Problem: But we still have the same problem, each time, all three cannonballs are fired from the same hidden parent Octopus sprite. What we really want is to have each Octopus clone fire each one of those three cannonball clones. If we number the Octopus clones Octopus1, Octopus2 and Octopus3, and the Cannonball clones Cannonball1, Cannonball2 and Cannonball3, then we want to match them up so that Octopus1 fires Cannonball1, Octopus2 fires Cannonball2 and Octopus3 fires Cannonball3. But to do that, each cannonball clone needs to know the position of its matching Octopus clone, so that it can go and fire from there. As we have already explained, this “go to Octopus” block does not work because it always moves the clone to the parent Octopus sprite. So the question now becomes how do we know the x position and y position of each Octopus clone on the stage at any time. If we know that, then each cannonball can just use the “go to x y” block to go to its matching Octopus clone. 
* Solution: First, it is not difficult to find out the x position and y position of each Octopus clone, we can simply use the “x position” and “y position” blocks in the clone code. To show that, let’s detach the forever loop temporarily so that the Octopus clone does not move. Then, add a “say” block to reports its x and y positions. 
* Test. Let’s run it. See? Each clone now reports what its current x and y positions are. Cool!
* Let’s remove the “say” block and add the forever loop back. Ok, we can now get the position of each Octopus clone. The idea is that if we can store the position of each Octopus clone somewhere, such as Position1, Position2 and Position3, then Cannonball1 can get Postion1 and go there, Cannonball2 can get Position2 and go there, and Cannonball3 can get Position3 and go there. All cannonballs will be going to the right Octopus clone. Sounds good?  Cool, the next problem is that where do we store these three positions. So far, we have seen two ways to store things in Scratch: variables and lists. Now variable is good for storing a single thing and list is good for storing a number of things. So how many positions do we have here? Three. Do you think we should use variable or list to store them? List! Of course! Maybe we can create a position list? But wait, before that, we need think about what a position really consists of. A position actually has two components: the x position and y position, they together determine where is a sprite is on the stage. So what we really need to store are three x positions and three y positions, right? Sounds like we need two lists instead: one for the x positions and one for the y positions. Let’s create both! Both lists need to be global because all Octopus clones need to use them. Once we have both lists, we can add each clone’s x position and y positions to them after the clone has moved to the random position. Still remember how to add things to a list? Yes we use the “add thing to list” block. For the first one, we add the value in “x position” block to list “x positions”, for the second one, we add the value in “y position” block to list “y positions”. Also, as a good practice, always clear any list when the program starts. So let’s delete all of x positions and all of y positions during setup.
* Test. Let’s make both lists visible and test the program. Now, as we can see, the “x positions” list contains the three x positions of the Octopus clones and the “y positions” list contains the three y positions of the Octopus clone. If we take the first item of the “x positions” list and the first item of the “y positions” list, they together give you the start position of the first Octopus clone. And similarly for the other two Octopus. Cool!
* Ok, now we have the position of each Octopus clone, each Cannonball clone can then go to its Octopus. Instead of “go to Octopus”, we can use the “go to x y” block.
* Problem: But here is the problem: where can we get the x position and y position this Cannonball should go to? We know that those positions are in the “x positions” and “y positions” lists. But we cannot just simply put the lists in this “go to block” because this block is only expecting a single number for its x and y, not a list of numbers. 
* Solution: Simple, we just need to select the correct x position and y position from the two lists. How do we select a single value from a list? Yes, use the “item of list” block! So we use one such block for x, select the “x positions” list, and one for y, select the “y positions” list. The final piece of the puzzle is what index should we use here? Just to recap, all items in a list are ordered from 1 to how ever long the list is. This number is called the “index” and we can use the index to quickly find an item in the list. For example, if we pass number 3 as the index to the block, then it is means “get the third item of the list”. If we just use 1 as index here, then all clones are gong select the first x position and first y position from the list. And these x and y together give us the position of the first Octopus clone. And if every cannonball clone goes to the first Octopus, then they will now all be fired from there. This clearly does not solve our problem. How about changing both indices to 2? Do you think that would work? No, that will just make all cannonball clones go and fire from the second Octopus! No good either! Since, what we want is for each cannonball clone to go to its matching Octopus clone, the first cannonball clone should use index “1”  to get the first items from “x positions” and “y positions” lists, the second cannonball clone should use index “2” to get the second items from both lists and the third cannonball clone should use index “3” to get the third items from both lists. So the question then becomes how do we give each cannonball clone a different index to the lists? Well, just like in lesson “[Synchronized Swim](1%20Synchronized%20Swimming%20bba3283731a548a78fa203c1fe036229.md)” where we give each cat a different direction using variable, we can also use variable to each each cannonball clone a different index right? So let’s first create a variable named “index”, this needs to be local because it is going to store different values for different clones. For the three cannonball clone created in each iteration of the forever loop, we want this “index” to start with 1 for the first cannonball clone, and then increases to 2 for the second clone and finally increases to 3 for the third clone. So at the beginning of the forever loop, we first set ”index” to 1. Then we enter the repeat loop, before creating the first cannonball clone, the parent sprite is going to create a copy of the “index” variable, which also contains number 1. This is then passed to the clone. Inside the clone, if we now use variable “index” in the “item of x positions” and “item of y positions” blocks, they will both select the first items from the lists which is the position of the first Octopus. As a result, this “go to” block moves the first cannonball clone to the first Octopus, ready to be fired. Now, after creating the first clone and before the repeat loop starts its second iteration, we need to increase “index” by one using the “change variable by” block. When the repeat loop goes round again and creating the second Cannonball clone, “index” variable contains value two. So when the parent sprite makes a copy of the variable and pass it the second clone, its “index” variable has a value of two and these two blocks are selecting the second items from lists “x positions” and “y positions”. As a result, the second cannonball clone goes the second Octopus clone and fires from there. The third cannonball clone works similarly and I’m not gonna repeat it again.
* Test. OK…now, it is better, we can see that all the cannonballs are clearly firing from different positions. That’s one step forward.
* Problem: However, it seems that all three cannonballs are only fired from the three Octopus the first time round. After that, the Octopus change their locations but the cannonballs no longer follow them around. Does anyone know why this happened? Well, let’s go back to the Octopus sprite. Take a look at the clone script: currently, when an Octopus moves to its random start location, we add its x position and y position to the two lists, right? Let’s make the two lists visible again and run the program. Now, as we can see clearly, the two lists contain the x positions and y positions of the three Octopus clones. Ok, now watch these two lists as the Octopus move around, do you notice something? When the Octopus move, the numbers in both lists stay the same, they remain to be the starts positions of the three Octopus. Think about it, if these positions never change, then the cannonball clone will always go to the same x and y positions of its matching Octopus, which is just the start position, and fire from there. Make sense? 
* Solution: Ok, so the real problem is that the positions in both list are not tracking where each Octopus is at all times, they simple just store the initial positions and be done with it! What we actually want to do is for each Octopus to update both lists with its latest position as it moves around in the Ocean. For example, if the first octopus starts at x -63 and y 110 but later moves to x -50 and y 120, then the first item of the x positions list should replace with -50 and the first item of the y positions list should be replace with 120. That way, we make sure that the positions in the lists are always up to date with where the Octopus are. Ok, now it seems that we need to replace an existing item in a list with something else? How can we do that? Well, because it’s about changing a list, so let’s take a look at all the list blocks and see if someone might do the job. Can you find any one? Yes, we have a block “replace item 1 of x positions with thing”. Ok, do not let the long name scares you, it’s actually pretty easy to understand. The first bubble is where you put in a index, this is telling the block which item you want to replace. The default number is 1, which is the first item. Of course, you can use any number from 1 to the length of the list. For example, we have three positions in each list, so we use number 1, 2  or 3 to replace the first, second or third position. Then there is this dropdown where you can choose the list whose item is going to be replaced. And finally, this old item is replaced with whatever new item you put into the second bubble. In our case, this new item is going to be the new position of the Octopus. Right, let’s add another one of this block for the y positions list. Ok, so we have the blocks to update both lists, where do you think we should add them in the code? Well, we want to run these two blocks when the position of an Octopus changes, right? So when does the position change? Yes, the position changes after the Octopus moves, and where does it move? Yes, it moves after this block. So we need to update the Octopus x and y positions right after this block. Cool. But we are not done yet. First, what is the new x and y positions? Well, this is simple, the latest positions are always stored in the “x position” and “y position” blocks. So, let’s add them to the second bubble of the two replace blocks. The second problem is that, the index of both blocks are still the default number one. This means all clones are going to update the first item of the both lists, which is clearly wrong. We want the first Octopus clone to update the first item, the second Octopus clone to update the second item and the third Octopus clone to update the third item. This means, inside the clone script, the first Octopus should use index one, the second Octopus should use index two and third Octopus should use index three. Well, well, well, this sounds familiar! I think we have seen something pretty similar not long ago! Can you recall? Yes, when we tried to determine which x position and y position a cannonball clone should get from the two lists so that it can go to the matching Octopus, we gave each cannonball clone a different “index”: the first cannonball has index one, the second cannonball has index two and the third cannonball has index three. They can then get the positions of their matching Octopus from the lists. Same idea here, each Octopus needs to be given a different index so that each one knows where its own x and y positions are in the lists and update them accordingly. Similar to what we have done to the Cannonball clones, let’s create an “index” variable, make sure it’s “For this sprite only” because each Octopus needs to have its own index. Set “index” to 1 before creating the three Octopus clones and increase it by one after creating each clone. Ok, now each Octopus clone is going to have a copy of the “index” variable and the value is one for the first Octopus, two for the second Octopus and three for the third Octopus. All we need to do to finish this all up is to use variable “index” in the two replace block. 
* Test. Now let’s give it a final run. Woohoo, now all the cannonballs are firing from the three Octopus all the time. And all you need to do it to keep your crab alive for as long as possible! Of course, we have not added the timer yet. But we have done this a couple of times in previous projects so you should be able to do that on your own. So I will leave that as an exercise for you. |

### Further Exploration

### Exercise