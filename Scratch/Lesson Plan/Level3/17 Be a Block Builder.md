# 4 Be a Block Builder

### References

### What to Learn

- how to identify scripts that should be converted into custom blocks
- how to create and use custom blocks
- how to add input to custom blocks
- how to use custom blocks to make code easier to understand and change, and reduce code duplication

### Blocks

- custom blocks

| Step | Details |
| --- | --- |
| Introduction | * Ok, so far in the course, we have finished quite a lot of projects together. I think you should be very proud of yourself for getting this far. Well done! 
* Now when looking back at the code you have written previously, does it happen to you that sometimes you don’t even know what that some of the code is doing. Ok, maybe I’m bring a little bit too harsh here, maybe you do know what the code is doing, but very often, it we need to spend some time, going through all the code block by block and then slowly recall what we were trying to do. It’s not just you, I also find it difficult to understand my own code after a few weeks or months, especially for those more complex projects.
* Because of this, it is very important for us to organize our code nicely and to make what it does clear, so that we won’t be having such a difficult time when looking back at them. 
* In today’s lesson, we are not going to create any new project. Instead, we are going to revisit two of our previous projects: [Race to the Island](../Level2%20f841ea788a6f412db7884de2c891457c/10%20Race%20to%20the%20Island%208d244dc379844c1e85601f7a2302e706.md) and [Ghost Buster.](../Level1%2051869bb3a8274fd0910ceb115e2e8daf/4%20Ghost%20Buster%2031810f72b21c4323bd4fe2bb5d980a58.md) and see how to make things more organized. The powerful tool that we will be learning to use is “Custom Blocks”. This is a very important tool, especially for complex projects. 
* So without further ado, let’s get started. |
| Race to the Island (Motivation for using custom blocks) | * Ok, the first project we are going to revisit is “[Race to the Island](../Level2%20f841ea788a6f412db7884de2c891457c/10%20Race%20to%20the%20Island%208d244dc379844c1e85601f7a2302e706.md)”. Let’s open that first. Go to the boat sprite. Now, very quickly, take a look at its “Run” script, can you tell me what each of these “if then” block is checking for? Three two one. Time’s up! Ok, I can see that all of you are scratching your head and thinking “Did I write this code?” Right? So, this is exactly what I was saying, very often, it is difficult to figure what your own code is doing!
* OK, if we do slow down and look at code for a bit longer, we can finally recall that, right, the first one is checking if the boat has won by reaching the island, the second one is checking if the boat has lost by colliding with the wall, and the last one is checking if the boat has been sped up by stepping on the booster. 
* But would it be nice if we can just look at the code, and instantly know what it is doing? For example, I can just look at this “Run” script, and immediately say, ”Ok, this is moving the boat one step forward, then one by one, it checks if the boat wins, if the boat loses, and if the boat gets a speed boost” Note that we only care about what it does, and not how it does it. For example, we are only interested in whether the boat wins or not, but not how it wins. Whether it’s touching the yellow color or something else, we don’t care. Ok, I know all of these might sound a bit confusing now, so let’s look at what all these means for our code here. |
| Custom Block (Dance Demo) | * Before making any changes, let’s first learn a very important tool in Scratch, called “Custom Blocks”. So far in all of our projects, we have been using a range of blocks that come with Scratch to do different things, for example, to move a sprite, to say something or to make decisions. You can use these blocks straight out of the box and I often call them “Basic Blocks”. Think about buying a computer, some people would go for the easy route to pick a branded one, such as Dell or HP. The computer comes as a whole and you can start using it right away. This is similar to the case of using Scratch blocks directly. However, there’s a second group of people would like to do it themselves, they would buy the casing, the CPU, the GPU, the memory separately, and then assemble them into a final computer. This is similar to creating your own blocks using the Scratch “Custom Blocks” tool. You might be wondering, why would people want to assemble computers on their own, because obviously it takes more time and is more difficult. Well, the reason people do that is because this gives them a lot more freedom, they can choose the individual components as they see fit, and they can assemble a computer that cannot be found in the market and suit their special needs. Same with custom blocks, it allows you to create blocks that cannot be found in Scratch and do something that is very specific to your project. Let’s take look at more details next.
*  Let’s open a new project and add a Scratch cat sprite. We want it to perform a series of dance moves. When green flag clicked, go to the center of the stage. The first move is to make a full turn. We can use the “turn right” block for this, we turn 15 degrees at a time, and because a full turn is 360 degrees, so we need to turn 360/15 = 24 times. So let’s add a repeat loop and type in 24 times, then put the right turn block inside. 
* Test. Ok, the cat makes a full turn. Cool!
* In the next move, we want the cat to jump up and then fall back down. To jump up, we can change its y position by a small number of steps each time, such as 4 and do it repeatedly for 25 times. 
* Test. Ok, the cat jumps up.
* Then it needs to fall back down, this is simple, we just repeat 25 times again and change y by -4 this time.
* Test. Ok, once the cat jumps to the highest points, it falls back down to where it was before. Cool.
* For the final move, we want the cat to swing to the right end, and then to the left end and finally back to the center. To move horizontally, we use the “change x by” block. Again, we move 4 steps at a time for 25 times.
* Test. OK, turn, jump and swing to the right.
* Now to swing from this current position to the left end, we need to double the distance moved, so repeat 50 times, and each time change x by -4.
* Test. Ok, turn, jump, swing to the right end and swing to the left end.
* OK, so the final thing is just to swing the cat back to the center. So repeat 25 times and each time change x by 4.
* Test. Cool, so we all three moves in place. Nice and simple!
* Ok, now let’s think about it, we assemble different basic blocks, such as turn right, change x, change y and repeat, into more complex moves, such as full turn, jump and swing. This is because Scratch does not come with a full turn, a jump or a swing as one of its basic blocks. So we have to do it ourselves. Just like we assemble CPU, GPU and memory into something called “computer”, we can also assemble basic blocks into something called “Custom Block”. 
* A custom block is just a way of giving some script a name so that you can use that name to refer to the same script later on. Think of it as a variable for a script. For a normal variable, we are essentially giving some value, such as a number or some text a name, right? For example, in lesson “[Keep it alive](../Level2%20f841ea788a6f412db7884de2c891457c/9%20Keep%20it%20Alive%20254a7d3e5a3341baaeaf5ac7bbec6f41.md)”, we give the number that represents the dragonfly’s energy a name “energy level” and turn it into a variable. So later on, when we need to use that number, for example, to check if it has reached zero, we can just refer to the variable “energy level”. 
* Same with custom blocks. Let’s first duplicate the whole script so that we can compare against it later. The first repeat loop is essentially a full turn. So separate that out and let’s give it a name. But how?  Well, if you look at the block palette, there is a category towards the end called “My Blocks”. Click that, and you will see nothing except a “Make a Block” button. Now just like you can create a new variable by clicking the “Make a Variable” button, you can create your own block by clicking this “Make a Block” button. Now, a window pops up. There are a bunch of things here, let’s not worry too much about them for the time being. What I want you to focus on is this “block name” in the center. This is where you give a name to your block. Because we want to create a costume block for a full turn move, let’s just type in “Full Turn”, and that’s it, click Ok and the window closes. Now take a look at the “My Blocks” category again, what do you see? Yes, we have a new block named “Full Turn”. It looks just like a basic block in Scratch, it has den at the top and a bump at the button, this suggests that you can add code blocks above and below it. Another thing that we notice is, there is now another new block in the code area, it has the same color and the same name as the “Full Turn” block, which kind of hinds that they are related. But there is word “define” in front. So what is this block for? First, this block’s top is totally flat, so just like a hat block, this means we cannot add other blocks above it. But at the bottom, it has a small bump, this means we can attach blocks or a script below it. And what blocks or script should we attach to it? Well, remember, we started all these because we want to give this script for the full turn a name, right? And here is how you do it: you simply attach this script to the “define Full Turn” block. And now you have given this script a name “Full Turn”. This is a bit like setting a variable some value, in this case, the variable is the “Full Turn” custom block and the value is this repeat loop script. Ok, now the custom block is all set and ready to be used. How do we use it? Well, remember we have this new “Full Turn” block in the “My Blocks” category? You can just drag it out and place it wherever you want. So let’s add it after the go to block. When you run the program now, what is going to happen now is that after moving the cat to the center, Scratch runs the “Full Turn” custom block, and because this is not Scratch’s own basic blocks, it has no idea what this block does. To figure it out, it looks for a “define Full Turn” block to understand what needs to be done. In this case, there is one, it then runs this repeat loop, turning the cat 15 degrees to the right for 24 times. So let me point that out again: a custom block is just a way of give a script some name so that you can run that script by referring to this name later on. More formally, we call this block a “definition block” of the “Full Turn” custom block because it “defines” what this custom block should to do. And whenever we use a custom block in our code, we often say it is “calling” the custom block. So here, I would say something like “after moving the cat to the center of the stage, we call the custom block ‘Full Turn’”. 
* Test. All right, after all these changes, let’s run the program again. So the cat makes a full turn, exactly as before. Nothing is broken! Nice!
* OK, so after the full turn, the next move is a jump. So how about having another custom block for that? Sure, let’s do it together. First, we separate the next two repeat loops out because they together completes the jump. Then, go to the “My Blocks” category, and click “Make a Block” again. This time, let’s name this custom block “Jump” and click OK. See, we have another new custom block in the list here and also a “define Jump” definition block in the code [area.](http://area.So) Next is simple, we just attach these script with two repeat loops to the definition block, and after the calling the Full Turn custom block, we call the Jump custom block.
* Test. Now, the cat turns and then jumps. Perfect!
* Finally, the last move is swing. So you know what to do right? Let’s have a 5 min break and see if you can get this right! OK, times up! I’m just going to do it quickly here. Create another custom block named “Swing”. Attach the remaining three repeat loops to its definition, and then call “Swing” after calling “Jump”. 
* Test. ok, turn, jump and swing. No problem!
* OK, you might now be thinking, “right we made all these changes just to have the cat behave exactly the same as before. So why bother?” Well, I would love to hear your opinion, if I now put both versions side by side, can you tell me which one you think is better and why?
* Yes, these are all very good answers. So here is what I think. Let’s say we come back to the project 3 months later, if you look version one of the code, can you immediately tell what this script is doing? I would bet probably not! They just look like a bunch repeat loops to you with no real meaning! You can’t even separate the loops into different moves because you don’t even know what they actually represent! Ok, if you spend 15mins or more, looking through the code and probably running it, you will eventually figure what it is doing. But this is painful, and it’s already painful enough for such a tiny little toy program, imagine trying to figure things out in a complex project with hundreds or even thousands of blocks! Now what about version two where we turned each move into its own custom block? Well, I immediately tell what the cat is going to do when the program starts: it first goes to the center of the stage, then makes a full turn, then jumps and finally swings. I don’t need to know exactly how it does it, whether it’s using a repeat loop or moves 4 steps each time, I just don’t care. All I know is that it makes a full turn, jumps and swings, that’s it! That’s what the whole dance is about. It’s about three different moves, and not 6 repeat loops. If you do want to know how it jumps or maybe even change the way it jumps, you can now go straight to the Jump definition block and figure this out yourself without worrying about the rest. Also, if you want to change the order of the moves, say you want to Swing first, then Jump and finally make a full turn, it is as simple as shuffling the three custom blocks to the order you want. So Cool!
* So it should be clear to you by now that, one of the biggest advantages of using custom blocks is that it structures you code in a way to make it easier to understand and change. This might not seem to be very important when your program is small, but it is absolutely crucial when the project become more complex with hundreds or even thousands of blocks.
* Ok, just to complete the story, custom blocks can be placed inside other custom blocks too. For example, the three moves together make up a dance. So we can create a new custom block named “Dance”. Then move these three custom blocks to the “Dance” definition block. Now, after moving the cat to the center of the stage, we just the “Dance” custom block. Now, if you look at the code, you can immediately tell that the cat dances. Well, if you want to know more details about what moves made up the dance, you can always go to the Dance definition block and figure that out. 
* Test. Now, let’s run this, and it behaves as before. Nice! |
| Race to the Island (Improve using Custom Blocks) | * OK, now we have a fairly good understanding of what custom block is, how to use it and why to use it, let’s know turn our attention back to the “Race to the Island” project. 
* Previously, we were saying the all these “if then” blocks in the Run script does not immediately tell us what they are doing unless we spend time to figure it out. Now, with the new shiny tool of Custom Blocks, do you think we can make it better? Let’s give it a try!
* OK, let’s remind ourselves what each “if then” block is doing. The first one checks if we reach the island and win; the second one checks if we hit the wall and lose; the last one checks if we hit the booster and speed up. So clearly, we are doing three things here. So let’s create a custom block for the first “if then” block, name it “Win”, move the first if block to the “Win” definition block, and put this “Win” custom block after the move block. Then let’s create a second custom block named “Lose”, move the second if block to this “Lose” definition block, and put the “Lose” custom block after the “Win” custom block. Finally, let’s create a custom block for the third “if then” block, name it “Speed up”, move the third if block to the “Speedup” definition block and put the “Speed up” custom block after the “Lose” custom block. 
* OK, now if we look at the “Run” script, it becomes super clear to us what it is doing in each loop iteration: it first checks “Am I wining?”, then checks “Am I losing?” and finally checks “Am I speeding up?” If you really want to know want counts as a win or a lose, you can always go into the “Win” and “Lose” custom blocks to figure this out. But if you are not interested in the details, you can stop here and still understand what the code is doing. This is the magical power of Custom Blocks.  |
| Ghost Buster (Improve using Custom Blocks) |  * Ok, let’s revisit another one of our previous projects to further appreciate why custom blocks are so useful and important. Let’s open the “Ghostbuster” project. 
* Go to the Ghost sprite. Now listen to my question: can you quickly tell me what the code in the forever loop is doing? Three, two, one! Times up. Ok, let’s do this slowly: in the forever loop, the first repeat loop fades the ghost away, then the ghost moves to a random position, and the second repeat loop makes the ghost appears again, and finally it waits for two seconds to start all over again.
* Right, do you think we can use custom blocks here to make the code easier to understand? Sure! The first repeat loop makes the ghost disappear, so why not turn that into a custom block? Let’s create a new one named “Disappear”, move the loop to the “Disappear” definition block, and put the “Disappear” custom block in the forever loop instead.
* Test. Ok, the ghost disappears and appears, everything still works fine! Cool.
* Now, the second loop makes the ghost appear again. So let’s create another custom block named “Appear”, move the repeat loop to the “Appear” definition block, and put the “Appear” custom block in the forever loop instead.
* Test. Ok, still looks good, we have not broken anything!
* Now, take a look at the forever loop. Do you think it becomes much clearer what it is going on? I think so, I can now look at it and immediately see that it’s making the ghost disappear, go to a random position and appear again. So much easier! Can you see why we would want to use custom blocks now? I hope so.
* Ok, we all know that when using some of the Scratch’s basic blocks, we can give them numbers or text to make them behave differently. For example, the “move” block, you can give it different number of steps to make it move the sprite faster or slower. You do this by typing in a number in the block’s bubble here. Another example is the “say” block, you type in a word or a sentence and the sprite says whatever you give it. There is nothing new here, we have been doing this all the time. Now, take a look at the script in the “Disappear” custom block, it repeats 10 times, and each time increases the ghost effect by 10. Ok? Now, what if we want the ghost to disappear faster, so it increases the effect by 20 each time and doing that for 5 times. Well you might say, “That’s easy, I can just change the ghost effect increment to 20”. Sure, that would work. Let’s do it. 
* Test. Ok, now the ghost disappears much quicker. 
* Problem: But there is a problem with this approach. Suppose we have two ghosts instead of one, maybe they are two ghost clones, and I want one of them to disappear at the original speed and the other one to disappear at the current faster speed. But the problem is, when both clones are calling the “Disappear” custom block, they will all disappear at the current faster speed, right? Because they all run the same “Disappear” [script.](http://script.SO) So this approach clearly won’t work. What else can we do?
* Solution: What if, just like the “move” and “say” basic blocks, we provide the increment to the “Disappear” custom block when it is called? Then inside the “Disappear” definition, we can use whatever increment that was given to us in the “change ghost effect by” block. In this case, different clones can then pass different increments when calling “Disappear” and this would solve our problem. The next question then becomes: how do we pass the increment to the “Disappear” custom block? Well, remember the pop up window when creating a custom block? Let’s look at it again. Because we are not going to create a new custom block, we can change the “Disappear” block by right clicking it  and choosing “Edit”. Now the pop up window shows up. Here you can change the name of the custom block. But we are not going to do that here. Instead, let’s take a look at the first “Add an input” option here. It says “number or text”. Let’s click that. Now, see what happen? A new bubble appears after the name of the block. This is what we call an “input”. It is the same as the bubble in the “move” and “say” block. This specific one is for number or text. We need to give this input a name as well. Otherwise, how can you refer to it in the definition of the custom block? The default name is this highlighted text here, which says “number or text”. This clearly does not make any sense. Because we are passing in an increment, let’s rename it to “increment”. Cool. Now there are two more options down below, one says “Add an input boolean” and the other one says “Add a label”, since we are not going to use them here, I will not explain them further. Then click OK. Now, take a look at what has been changed: first of all, the “Disappear” custom block now has a bubble, and just like those basic blocks, this is telling us “hey, you can now pass me a number or text”. Next, at the place where Disappear is called, there is also a new bubble. Because we are not passing anything yet, it’s empty for now. Finally, the definition of Disappear has a new input that matches up with the bubble of the block. So whatever value you type into the bubble of Disappear when calling it, is going to be used to set this “increment” input there. Think of as setting the value of a variable, in this case, the variable is this “increment” input. Now, inside the definition of Disappear, we can use this “increment” input as a variable. All you need to do is just move your mouse over it, click and drag it out, then you can place it anywhere you want. Here, let’s put it in the “change ghost effect by” block. Ok, exactly how much do we change the ghost effect? Well, it depends on the value of the “increment” input. How do we set its value? Yes, we set it by typing in a number in the empty bubble when we call “Disappear”. Let’s type in 10. So the “increment” input will become 10 and we are increasing the ghost effect by 10 each time. 
* Test. Ok, everything works as before, cool.
* Now, we can do the same for the Appear custom block as well. Let’s quick do it together. Go to the Appear block, right click and choose Edit. Click “Add an input number of text”, and change this input’s name to “increment” also. Click OK. Now, the “Appear” custom block also has an input. To give the input a value, we pass in -10 when calling it. Finally, inside the script of the Appear block, let’s use the input “increment” in the “change ghost effect by” block. Because we are passing in -10, this decreases the ghost effect by 10 each time.
* Test. Still works as before, nothing is changed, nice! Now, if I want to make the ghost disappear and appear faster, all I need to do is just change the numbers passed to both blocks when they are called, to for example, 20 and -20. If you run the program again, the ghost appears and disappears much faster. Nice. 
* Ok. After all the changes, have you noticed something interesting about the Disappear and Appear custom blocks? Yes, if you look at their scripts, they are exactly the same? So if they are the same, then why do we need two of them? No right? So we can just remove one of them because increasing or decreasing the ghost effect can now by done by one common custom block. Let’s delete the Appear custom block, drag it out. But now, you are getting a warning message, which says “To delete a block definition, first remove all uses of the block”. Let’s click OK and as you can see, the definition block has not been remove. So what does this message mean? What is a use of the block? Well, where do we use this Appear custom block? Yes, we use it when calling it here in the forever loop. Now the reason Scratch prevents you from deleting this definition block is because, if you do that, then there is no Appear block any more, so when you call it, what are you really calling? Nothing right? So this does not make sense any more. That’s why it’s giving you this message. Now to be able to delete Appear, we need to delete the code that calls Appear first, which is this block here. So let’s delete that first. Now, we are having no trouble deleting the Appear definition block. But after this, something is missing, we are not making the ghost appear again. Well, this easy to fix, all we need to do is just call the Disappear custom block again after the “go to random position” block, only this time we need to pass -10, because it needs to decreases the ghost effect to make it show up. But I have to say, give this custom block the name “Disappear” and calling it twice is a little bit confusing. So we probably need a better name for it. Now, looking at the script of the Disappear block, all it does is just enable or disable the ghost effect slowly. I want to create a word for it: Ghostify. But depending on the increment you pass to it, if it is a positive number, then it becomes more and more ghost like, on the other hand, if it is a negative number, then it becomes less and less ghost like. So let’s change the name of this Custom block from Disappear to Ghostify. Now, I think this name works much better than Disappear!
* OK, so we are done with this example. Previously we said that one of the biggest advantages of using custom block is that is helps to better structure your code so that it is easier to understand and change. Now, we have actually seen the second important benefit of using custom block: before the change, we use two repeat loop and almost identical code to increase and decrease the ghost effect. However, after using custom block, we finally manage to merge this two repeat loops inside one custom block, and increasing or decreasing the ghost effect is simply a matter of calling this custom block and passing different input values. As I always tell you, less code is better code. Since custom block helps us to write less code, it helps us to write better code too! |

### Exercise

- Can you add another input to Ghostify to control the wait time?
- In the little demo projects, can you add inputs for the Full Turn custom block to control how fast the cat turns. And similarly add inputs to control how high it jumps and how far it swings.
- Can you check other projects that we have worked on to see if they can benefit from using custom blocks?