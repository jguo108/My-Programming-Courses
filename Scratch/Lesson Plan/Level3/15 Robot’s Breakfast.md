# 2 Robot’s Breakfast

### Reference

Robot Power Up from book<25 Scatch3 Games for Kids>

### What to learn

- Clone should be deleted when they are no longer needed
- Stop sprite individually so each one has the chance to carry out finishing work
- We can use blocks that are rectangles with rounded corners in places of dropdown list of blocks that have rounded corners

### Blocks

- delete this clone

### Lesson Plan

| Step | Details |
| --- | --- |
| Introduction | * In this lesson, we are going to create another very fun game “Robot’s breakfast”. Food, such as eggs, milk and muffins, will appear on the right and flying towards left. You will be controlling a robot to eat as much food as you can. It only flies up and down by pressing the space key on the keyboard. Play with your friends to see who eats the most before time runs out!
* In the last lesson, we have learnt how to use clones in Scratch and we used that to easily create 6 cats without needing to add 6 sprites. When created, all clones are identical to their parent sprite, but this does not mean they cannot be different. In fact, we have seen that using variables can make clones behave differently. But in that lesson, all the cats still look the same, they all have the same costume.
* In today’s lesson, we are going to continue our journey with clones, and show how clones can each have its own costume and looks completely different to each other. More over, we will show how clones can be deleted and removed from the stage too. This is important, because creating without deleting is going to fill the stage up with clones!
* So without further ado, let’s get started! |
| Backdrop | * First, let’s set the scene up. Our robot works in a factory and wants to have a nice breakfast before getting to work. So for the backdrop, select the “factory floor” image from the Resources folder.  |
| Robot | * Next let’s add a robot. Go to the sprite library and search for “robot” and select this sprite. It has three costumes, a, b and c, we will be using all three of them. More specifically, costume b is used when the robot flies up, costume c is used when it falls down, and costume a is used when the game starts or ends. Because each costume has a very specific purpose, it’s best if we can name them properly instead of just the meaningless a, b and c. So we name the first costume “Start/End”, the second one “Fly Up” and the third one “Fall Down”. This makes it super clear when to use which costume. Giving everything a good name is very important when you write code. 
* OK, the robot is too big for the stage now, so let’s first change its size to 50%. In this game, we limit the robot’s movement to the left end of the stage, so it can only moves up and down there but not forward or backward. When green flag clicked, make it go to x -200 and y 0. Also switch its costume to “Start/End”
* Test. Ok, looks good. The robot shows up at the right place and has the right costume. Cool!
* Now, let’s add some code to control the robot. The idea is that if some key on the keyboard is pressed, it flies up, else it falls down. You can choose any key you want, but one that people often choose in such case is the space key, because it’s big and right in the middle of the keyboard, so hard to miss! We will follow this tradition here too!  
* Ok, after learning how to move a character using keyboard keys in the last few lessons, it should now become fairly easy and intuitive to you: first add a forever loop, in the loop, we are going to repeatedly check if the space key is pressed, so add an “if then” block, and use the “key space pressed” diamond block as condition. If this condition is true, the robot flies up, meaning its y position is going to increase. How do you increase a sprite’s y position? Yes, we use the “change y” block with a positive number in the bubble! Exactly how much to increase is total up to you, the bigger the number here, the faster it flies. I’m just gona change it by 4 here. Also, we have a costume named “Fly up” right? So let’s switch to that costume when the robot is flying up.
* Test. Ok, as we press the space key, the robot flies higher and higher. Nice!
* But as people always say “What goes up must come down”, when we are not pressing the space key, the robot needs to fall back down, because, well, you know, it’s gravity! So what we need here is actually an “if then else” block instead, because there is an else case to handle too when the space key is not pressed. To make the robot fall down, we just need to decrease its y position, and this is as simple as changing y by a negative number, let’s try -4 here. Also, let’s switch to the “Fall down” costume.
* Test. Ok, so when we pressed the space key, the robot flies up and when we are not pressing, it falls backdown. 
* But I feel like it is falling a little bit too fast. So let’s slow down the fall by replacing -4 by -2 here.
* Test. Ok, this feels a lot better, we can now decide how high we want the robot to fly by either pressing or releasing the space key. Try to keep the robot in the air for yourself! Nice isn’t it? |
| Egg (move and reach left edge) | * Ok, our robot can now fly up and down and stay in the air. So it’s breakfast time now!
* You can add any food you like, or maybe something that is not even food, as long as the robot loves to chew on it. But here, I’m going to be less bold and choose an egg first. In the sprite library, search for “egg” and add that to our game. It has a total of 6 costumes, but we only need the second one, so let’s delete all the rest. It’s a little bit too big for our robot now, let’s reduce its size to 50%. 
* Ok, what we want the egg to do is to start somewhere from the right and fly towards left. So when green flag clicked, add a “go to” block first. For its initial position, the x is going to be 240 because we want the egg to start as far right as possible. For the y, we could just pick any number between -180 and 180. But which ever y value you choose, the problem is that the egg will always start at the same position each time you start game. That’s just too predictable and to be honest, boring. We already knew that a game can be made more fun when things are a bit more random, right? So here, instead of choosing a fixed y value, we are going to pick a random number from -180 to 180. Still remember how to pick a random number in Scratch? Yes, we use the “pick random number” block, and set the range from -180 to 180.
* Test. Now each time we click the green flag, we can see the egg showing up at different positions on the right edge of the stage. 
* But sometimes it’s too high or too low, touching the ceiling or the bottom of the stage, so let’s just shrink the range a little bit from -160 to -160.
* Test. Now it never touches the ceiling or the bottom. Cool.
* Ok, it’s time to make the egg move! First, we want to make it move to the left a small number of steps each time until it touches the left edge of the stage. How do we make it move a small number of steps to the left? Yes, we use the “change x by” block and -4 in the bubble for four steps to the left. Right, then how do we move four steps again and again until the egg reaches the edge? Well, simple, we have a “repeat until” loop, and let’s move the “change x by” block inside this repeat loop. Finally, how can we check if the egg has reached the left edge or not? 
* In general, there are two common ways to check if a sprite reaches the any edge of the stage. The first one is to use the “touching” block in the Sensing category. We have seen and used this block many times before for checking if the sprite is touching the mouse-pointer or another sprite. But if you take a look at its dropdown list again, you will see that there is another option called “edge”. If you choose, it checks if the sprite is touching any edge of the stage: up, down, left or right. So do you think it would work if we use this as the condition for the repeat loop? Not sure? Well, just try!
* Test. Ah, the egg is not moving at all! Not even a single step! Why is that? Can anyone have a guess? Well, let’s me ask you a question first: where is the egg’s initial position? Yes, it’s on the right edge of the stage! So do you think it is touching the edge now? Of course, it is right on the edge, so surly it is touching the edge. Now, take a look back at the repeat loop, when the program starts, after the egg moves to its initial position, its repeat until loop checks “am I touching the edge”, well, yes you are Sir, so the loop finishes right away, not even running the “change x by” block once! No wonder why the egg has not moved at all! So clearly, this “touching edge” block cannot be used for the condition here.
* OK, as I said there are two common ways to check if a sprite reaches the edge. The first one fails and let’s now try the second one. This one basically checks for the sprite’s x position. What is the x position of the left edge? Yes, its -240, so what if the sprite’s x position is also less than -240, or in other words, to the left of the left edge? Then it must have reached the left edge right? Ok, so all we need to do is to check if the egg’s x position is less than -240. For this, we use the “less than” block in the Operators category, and how do we find out its x position? Yes, it’s stored in the “x position” block in the Motion category, and we check if it is less than -240. We use this as the repeat loop’s condition. 
* Test. Now the egg moves towards left and stops as soon as it reaches the left edge. Cool!
* Right now, when the egg reaches the left edge, it just stays there. What we want to do is to hide it so that it looks as if it is gone forever. This is simple, just add a “hide” block after the repeat loop and always remember to show the sprite if you ever hide it.
* Test. Now when it reaches the left edge, poooof, it disappears, gone! Ok, to be honest, it is not really gone, the egg still stays at the left edge, it just becomes invisible to us this time.  |
| Egg (eaten by robot) | * Problem: Ok, the egg moves fine, but the problem is that our robot can not catch and eat it! See, when they touch each other, nothing happens and the egg just keeps moving on. 
* Solution: To catch the egg, we just need to check if it is touching the robot each time after moving 4 steps. So let’s add a “if then” block after the “change x by -4” block, how do we check if it is touching the robot? Yes, this time we use the “touching” block and select Robot from the dropdown list. Ok, what should we do if this happens? Well, it can just be the same as when the egg reaches the left edge, that is we can just hide it. And it will be even better if we can add some sound effect. The egg sprite already has a pop sound and I think this is ok. So let’s start the sound pop after hiding the sprite.
* Test. Ok, now when the robot eats the egg, we hear a pop sound and the egg is gone, probably into the stomach of the Robot. |
| Egg (clones) | * Problem: Ok, that’s good for one egg. But what next? Is that it? Just one egg? I think the hungry robot is certainly expecting more than one egg! “That’s easy!” I can here you saying “let’s just duplicate the egg sprite and we have a second egg! Still enough? No problem, duplicate it one more time and you have a third egg!” 
* Test. Ok, we do have three eggs now. 
* Problem: But once they reach the left edge or being eaten by the robot, we are left with no eggs again! Well, you could keep duplicating the egg sprite, to have four eggs, five eggs, or even 100 eggs if you have the time. But the problem is that, it doesn’t matter how many eggs sprites you have, it will eventually run out, it’s just a matter of time.
* Solution: So clearly manually duplicating the egg sprite is not going to work, so let’s delete egg2 and egg3. Fortunately, we have just learnt a very powerful tool that can help us to create as many eggs as we want automatically! Right? And the tool is… Yes! Clones! The idea is simple, we just keep creating egg clones, for each clone, we do what this script does here: show up on the right side, move towards left, and hide if reaching the left edge or getting eaten by the robot. So it seems that now each clone needs to run this script. And if you can recall from last lesson, how do you tell a clone to start running some code? Yes, we use the “When I start as a clone” hat block. Let’s detach this from the “when green flag clicked” and move it under the “When I start as a clone” block. Ok, so what is left is just to actually create the clones, and this will be done when the green flag is clicked. So how many clones do we want to create? Well, I don’t know, I truly don’t know. Because we will need eggs as long as the game is still running, so the answer is just keep creating until the game ends! So let’s creating clones forever! How do we create a clone? Yes, we use the “create a clone of myself” block. Let’s add that inside the forever loop.
* Test. Ok, time for the test! 
* Problem: Wow! What is happening here? It’s showering with eggs! Our robot is going to buried in eggs. Clearly, we are creating way too many egg clones! And if you wait for 10 seconds or so and keep an eye on the clone counter, after a few seconds, that number reaches 300, meaning we have 300 clones now. Then it stops increasing because Scratch puts a cap on the maximum number of clones we can create, and that limit is 300. Once it is reached, no more clones can be created and that’s why after 10 seconds or so, we have no new eggs anymore. Ok, let’s first check why it is creating so many clones. Well, to find out the reason, we have to look at the forever loop again. This loop does nothing apart from creating clones, right? But we know that computer can run code very very fast. For example, this loop can iterate 30 times each second. Yes, you hear me right, it iterates 30 times in one second. And what does it do each time? Yes, it creates a clone. So how many clones does it create in one second? Yes, 30 clones. So it takes about 10 seconds to reach the 300 clone limit.
* Solution: Let’s first slow down the rate at which egg clones are created. This is simple enough, we just need to put a wait block before creating each clone. You can wait for 1 second, or 2 seconds or any number of seconds you want. I will just leave it at 1 second for now.
* Test. Now, for each second, we are seeing a new egg coming towards the robot. Cool.
* Problem: But now I’m seeing two new problems, the first one is that there is an egg on the stage that is not moving at all. What is that and where does it come from? Can anybody have a guess? Yes, remember, all egg clones are created from the parent sprite, but the parent sprite itself is not going to run this “When I start as a clone” script here. So it just sits there, not moving at all. 
* Solution: Because we don’t need this parent sprite showing on the stage, we can just hide it when the program starts.
* Test. Now the parent sprite is gone. Cool!
* Problem: The second problem is that when an egg clone reaches the left edge, it is not hidden, we can still see it on the stage. So as more and more egg clones are created, those that are not eaten by the robot get piled up on the left. That’s not good. But why does that happen? We clearly checked its x position here and hide it as soon as it reaches the edge. So what is going on here? 
* Solution: We know that the “x position” block contains the x position of a sprite, right? Now let me ask you a question first, given that we have a parent sprite and all these clones here, whose x position do you think this block contains? Is it the x position of the first clone, the second clone, the third clone? Or maybe the parent sprite? To answer this question, let’s make this block visible on the stage first by checking this box. Ok the value is 88 now. Now let’s start the program. Egg clones are kept being created and moving to the left. But take a look at the value of “x position”, it is not changing at all and stays at 88, right? But all the clones are clearly moving, so their x positions must be changing. So it seems that this x position does not belong to any of the clones. So whose x position is this then? Well, which sprite is not moving at all? Yes, the parent sprite, the one we just hide. So this x position must be the parent sprite’s x position and it does not belong to any one of the clones. Ok, now we can explain why all clones are not hidden after they reach the left edge: this is because “x position” block is the parent sprite’s x position and it never changes, so the condition, “x position” less than -240 is never true. So this loop is just going to repeat again and again, never completes. Because it never completes, this hide block after the loop is never run. So no clone will be hidden. So to solve this problem, we need to give each clone its own “x position”, and as the clone moves, we update this “x position” and check whether this “x position” is less than -240. Ok, so how do you give each clone something that only belongs to it? Yes, we use variables, and more importantly, local variables. So let first add a local variable named “x position”, make sure you choose “For this sprite only”. Ok, for the parent sprite, we set its local “x position” to the value of the x position block, which is 88 as you can see from the stage. Now remember, when we create a clone, the parent sprite is going to make a new copy of the local “x position” variable and pass it down to the new clone. So what value does this copy of “x position” variable has? Yes, it’s also 88 because it is copied from the parent sprite’s “x position” variable. Ok, in the clone, we want it to start from the right edge, right? So but the current value of its x position is 88 instead. So we first need to set it to 240.  Then in the “go to” block we can use the “x position” variable for the x value. Most importantly, we can now use this “x position” variable instead of the parent sprite’s “x position” block when checking if the clone has reached the left edge. But right now, “x position” stays at 240 and never changes as the clone moves across the stage. That’s simple, we just need to change it by -4 after the clone moves 4 steps to the left.
* Test. Hooray! Now as an egg clone reaches the left edge, our repeat loop check this clone’s x position and finds out that it is less than -240, so the loop completes and we hide the clone. Perfect!  |
| Egg (random generation wait) | * Ok, before we move on, I want to address a small issue. I think waiting for one second before creating each clone is too predictable. And what can you do to make thing less predictable? Yes, we use randomness. So instead of always waiting for one second, I will wait between 1 and 3 seconds. So let’s use a “pick random” block and set the range from 1 to 3.
* Test. Now, when the next egg shows up is less predictable and more random. Very nice! |
| Egg (deleting clones) | * Now, if you pay attention to the clone counter, you will see that the number is always increasing. This makes sense, because we are creating a clone every few seconds and when these clones get eaten by the robot or reach the left edge, they are still there, remember? The reason they seem to disappear is simply because we hide them. But they still exist on the stage. This will be very clear if we just remove these two “hide” blocks temporarily.
* Test. Now, see? It doesn’t matter if an egg clone gets eaten by the robot or reaches the left edge, they eventually all get piled up on the left side of the stage. Let’s put these two “hide” blocks back.
* Problem: Ok, so we just keep creating more and more clones, and they never go away. So what’s the problem. Well, if you still remember earlier, when we are creating tons of clones very fast, the clone counter just shoots up and quickly reaches its 300 upper limit. Once that happens, we can no longer create any more clones. Well, this problem is less obvious here because we are creating clones at a much lower rate. But, still, if you run the game for long enough, you will eventually reach the limit, it’s just a matter of time. So, let’s think about it. For each clone, whether it’s been eaten by the robot or reaches the left edge, do we still need it anymore? Clearly No! And that’s why we hide it in the first place. If we do not need it anymore, then why still keep it on the stage? We should just throw it away and be done with it. It’s a bit like any creature in the world, it’s born, it grows and eventually it dies. Same with clone, we create one, it does its things, then it leaves the stage and die. It’s sad, but this is how things work in nature.
* Solution: Fortunately, Scratch also follows the laws of nature, it gives us a way to create a clone, and at the same time, it also allows us to delete it if it is no longer needed. Can you guess what that block is? Yes, it’s the “delete this clone” block. Well, its name says it all, it delete this clone. So coming back to our clone script, when do you think this clone is no longer needed? Yes, we do not need it anymore if it is eaten by the robot or reaches the left edge. And as we have seen before, we are hiding the clone for the time being, but that still leaves the clone on the stage. Now we know that a clone can be deleted, so instead of simply hiding it, we delete it, removing it from the stage forever!
* Test. Now, watch the clone counter very carefully. Whenever a clone is eaten by the robot or reaches the left edge, the counter actually reduces. Why? Well because that clone is deleted, gone forever. If you run the game for a while, you can see that the counter never becomes too big, actually, it’s just around 3 or 4 at maximum, and this the number of clones that are actually on the stage at that moment.  |
| Score | * Right, that was quite a ride! We have gone through the most difficult part of this lesson! The rest is just adding scores, timer out and maybe have more variety of food for our Robot! Let’s look each one by one.
* First, scores! The purpose of the game is to eat as much food as we can before time runs out. But how do we know how much food our Robot has eaten? How can we compete with friends and families to see who eats the most? We need a score to keep track of how well our robot has done. The idea is pretty simple, every time, the robot eats an egg, its score is increased by one.
* Where do we store the score? Yes, variable. So let’s create a new variable and name it “Score”. Now I’m going to ask you again: should this variable be global or local? We are creating this variable in the Robot sprite, so clearly the robot needs it right? If this the only one that uses this variable, a local one should be fine. So let’s choose “For this sprite only” for the time being. But is it true? Is this the only sprite that needs the score? Are there any other sprites that might need to access it?
* Before answering that question, let’s first think about when and where the score needs to be increased. It’s when the robot touches the egg, right? Where do we check if the two are touching each other? Yes, we do it in the script of the egg’s clone, right here! So ideally, we would use the “change variable” block and select our “Score” variable. But here it the problem, we cannot see the “score” variable from the dropdown list? Why? Well, because we made score local to the Robot sprite, right? So that means only robot can see and use that variable. It should now be clear that “score” needs to be global instead of local because the egg sprite and its clones need to see and use it. So to change it to global, you just need to right click the variable, select “rename or edit variable”, then in the window that pops up, choose “For all sprites instead”.
* Now back to the egg sprite, this time we can see “score” in the dropdown list of the “change variable” block. Let’s then move this to when the two are touching each other, which is inside this “if then” block.
* Test. Now every time the robot eats an egg, the score is increase by one. Perfect! |
| Timer | * Ok, let’s remind ourselves what the goal of the game is: it is to eat as much food as it can before time runs out. We already have a score to keep track of how much food the robot has eaten. So next we need to put a time limit!
* In lesson “[Race to the Island](../Level2%20f841ea788a6f412db7884de2c891457c/10%20Race%20to%20the%20Island%208d244dc379844c1e85601f7a2302e706.md)”, we created a timer that counts down, and this one will be exactly the same as that. You can copy the code straight away from that lesson. But here as an exercise on how to create a timer, let’s code that again together.
* So we will add the timer in the stage. Now, we need something to keep track of how many seconds are left. So let’s create a new variable and name it “time left”. Notice that, when you create a variable in the stage, you do not have the option to make it global or local. Instead, what you see is this line “This variable will be available to all sprites” meaning its always global. So all variables that you create for the stage will be global.
* Ok, once it is created, let’s set it to 60 when the green flag is clicked. Then we repeat until “time left” is equal to 0, meaning no time left. If not, in the loop, we wait for one second, and then decrease “time left” by one. After the loop completes and the time is up, we just stop all.
* Test. Now, after 60 seconds, the game ends and we have our score. Cool! |
| Reporting score | * Now, when the game stops, we can know our score by looking at the variable on the stage. That’s ok. But it will be even better if the robot can turn to use and say something like “Time’s up! You final score is xyz”.  But given the fact that the stage just stops everything immediately when time is up, the robot has no chance to report the score because it is stopped too!
* So it is very often that when a game ends, you don’t want to just stop everything right away. Instead, you might want some sprites to do something before it can stop. For example, to report the player’s score. We have seen an example in lesson “Escape Room”. 
When the player bumps into any obstacles or enemies, we do not stop everybody immediately by using the “stop all” block, because the player still needs to play a losing sound and switch to a different costume before it is stopped completely. And the solution we had was to broadcast a lose message, and each sprite receiving that message can decide what to do: it can either stop right away, or, as what the player does, do some finishing work before stopping completely. 
* So, let’s borrow the same solution from that lesson. Instead of “stop all” to nuke everything, we broadcast a “time’s up” message. 
* Test. Ok, when the time is up, nothing gets stopped, we can still fly the robot and egg clones are still getting created.
* Well, that makes sense because no one is responding to that message yet. Now, let’s see who is going to receive that message. First of all, the egg. But this time it is not just the parent egg sprite, but also all of its clones. The parent sprite is running the forever loop to keep creating clones and each clone is moving towards left. So when they receive “time’s up”, they should stop whatever they are doing in these two scripts. And in lesson “[Escape Room](../Level2%20f841ea788a6f412db7884de2c891457c/13%20Escape%20Room%20343925c206954817b27e356e7d66d8fe.md)” we have seen how to stop other scripts in a sprite by using the “stop other scripts in sprite” block.
* Test. Now when time is up, all the eggs stop moving. Cool. But we can still fly the robot so let’s fix that next.
* The idea is the same, when the robot receives “time’s up”, it also stops other scripts in this sprite, which is this forever loop that allows us to control it.
* Test. When time is up, all the eggs stop moving and we cannot fly the robot anymore.
* But what’s good with this solution is that the robot has not been stopped completely, we can still run blocks in the “time’s up” script after the “stop other scripts in sprite” block.
So here we just want it to switch to the “Start/End” costume and then report the score. For the sentence to say, we are going to use the “join” block to join “Time’s up! You final score is: ” with the variable “Score”.
* Test. Now, when the game ends, everything else stop, but robot can still turn to us and say “Time’s up! Your final score is: 2”. Perfect! |
| More food types | * Ok, the game is almost complete and it’s totally fine if you want to stop right here. But I want to make it even better! Currently, our Robot’s breakfast is a little bit too plain, there is just one type of food, the egg. Now think about what you have for breakfast, you might have egg, bread, milk, fruit etc to have a balanced diet. We would like to give our Robot a better breakfast too by adding more types of food!
* First, let’s go to the egg’s costumes, right now, it has just one costume. Let’s add more. In the Scratch costume library, search for milk and add it. Then search for muffin and add it as well. Now we have three types of food that I think the robot is going to enjoy. Of course, you can always add more. We also change the name of the egg sprite to “Food” because it is not just egg now.
* Next, back to the code. Ok, basically, what we want is that for each new clone of the “Food” sprite, we want to give it a random costume chosen from those three. Now, how do set the costume for a sprite? Yes, we use the “switch costume to” block and let’s add that to the beginning of the “When I start as a clone” script. So the first thing when a clone starts is to choose a costume for itself. 
* Problem: But here, we have a problem: if you click open the dropdown list, it gives the names of those three costumes, egg, mill and muffin. Whichever we choose, all clones are going to have that costume. For example, if I choose muffin…
* Test. Now, see? All we have are muffins!
* But this is now what we want, we want the clones to be a mix of egg, milk and muffin. But clearly we can do it by just selecting one in the dropdown here. What can we do?
* Solution: Let’s take a look at the “Food” sprite’s costumes again. It has three costumes, each one has its own name. But if you look more carefully, there is also a number for each costume. For example, the egg costume has number 1, the milk costume has number 2 and the muffin costume has number 3. As it turns out, you can not only use the costume’s name when switching costume, but also use these numbers too! For example, if you want to switch to the muffin costume, you can choose “muffin” from the dropdown, but you can also give it number 3. But might ask, how? Unlike some blocks that have a bubble where you can just type in the number, it just has this dropdown and how can you give it a number. Ok, there is something that I have not mentioned before, and I would like to let you know here: yes, when you see a white bubble in a block, you can type in anything you like, text, numbers. Fine. But when you see a dropdown but has a bubble shape, meaning it’s a rectangle with rounded corner, you can put other blocks that are rectangles with rounded corner into it too! What are these rectangle blocks with rounded corners? Well, there are plenty of them! In the motion category, you have the “x position” and “y position”, in the Sensing category, you have the “answer” and “timer”, in the Operators category, you have all the arithmetic blocks, just to name a few. So technically, these blocks can all be put in here, whether what makes sense or not is a different story. So let’s come back to switching costume here. What we want to give it is number that is either 1, 2 or 3, at random, right? By now, you have no problem getting such a random number, right? Yes, we use the “pick random” and set the range between 1 and 3. What’s more important is that, this block is also one of those rectangles with rounded corners, so it should fit into our “switch to costume to” block, right? Let’s find out, move it over and there you go, it snaps right in! So what is this block doing now? It switch to costume 1, 2 or 3 at random. And what are costumes 1, 2 and 3? Yes, they are the egg, milk and muffin! Perfect!
* Test. Let’s test this out! Start and yes, we have eggs, milk and muffins. This is what I call a proper breakfast. Perfect!  |

### Further Exploration

- Make the food rotate as they move
- Score different points with different food, for example, egg is 1 point, milk is 2 points and muffin is 3 points

### Exercise