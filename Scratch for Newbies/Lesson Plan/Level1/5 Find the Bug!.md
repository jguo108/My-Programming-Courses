# 5. Find the Bug!

[Projects | Computer coding for kids and teens | Raspberry Pi](https://projects.raspberrypi.org/en/projects/find-the-bug)

### Project

Create a game in which you have to find a hidden bug üêû on each level. The game will have ‚Äòstart‚Äô and ‚Äòend‚Äô screen backdrops, and a timer ‚åö to show the player how quickly they found the bugs.

### What to learn

- Make the connection between stage and sprite, backdrops and costumes
- Switching backdrop for stage is like switch costume for sprite
- Creating levels for your game
- Use timer to make the game more interesting

### Blocks

- switch backdrop to/next backdrop
- when backdrop switches to
- timer
- reset timer
- if on edge bounce

### Lesson Plan

| Step | Details |
| --- | --- |
| Introduction | * Ok, welcome back everyone! Good to see you all again! Ready for a new lesson and a new challenge? Yeah? Good! That‚Äôs the attitude I want to see! 

* Ok, let‚Äôs talk about mistakes first. We are all humans, so we all made mistakes, right? That‚Äôs just human natural. Imagine you're building a tower with blocks, and you accidentally put a block in the wrong place. The tower might wobble or fall over. That‚Äôs bad. But mistakes are what help us to learn and more forward. The most important thing is to be able to identify what went wrong and try not to fall at the same place again. 

* Just like we would make mistakes when build block tower, we would also make mistakes when coding. You guys have seen me make mistakes before, right? And in coding, we often call such mistakes ‚ÄúBugs‚Äù, likes bugs bugs. Those are the wrong blocks in the our programs that make them do something unexpected. Ok, you might be wondering, why it is called a bug? Right, a bit of history. Bad in the old days, computers were so big that they can fill an entire room! On of these giant computers was called the ‚ÄúHarvard Mark II‚Äù, and a brilliant lady named Grace Hopper was working on. Now, one day, for some reason, the computer suddenly stopped working and no one has any idea why. Grace and her team have to finally open the computer up and look for potential clues. And guess what they found? A real, actual moth had flown into the computer messed up the wires inside! What a surprise! So Grace and team carefully took the moth out and the first case of bug was found! And from that day on, people started calling problems or mistakes in computer programs ‚Äúbugs‚Äù, just like that little moth that caused big trouble for Grace. And when programmers try to fix those problems, they call it ‚Äúdebugging‚Äù, like getting rig of the bugs! Through out the history of computer programming, programmers have made all sorts of bugs, some of them are not very harmful and even pretty interesting, but some are pretty serious and caused lost of lives. As coders, we need to always keep two things in mind: first, you will create bugs in your programs, that‚Äôs just life, and second, find and fix your bugs as early as possible before they get out of control!  

* Right, enough of history and let‚Äôs see what we are going to build today! Guess what, we are going to find bugs. But not a bug in a program, an actual bug! Here is what the game looks like: it has different levels and your task at each level is to find a hidden bug as soon as you can. Once you find and click it, you are through to the next level. Now the levels are getting more and more difficult, because the bug will become smaller and smaller. So it‚Äôs harder and harder to find! On top of that, there will also be some annoying bat or dragonfly that keeps moving to make you distracted. If you are good enough to get to the end of the game, the bug will report how long it took you to finish. Of course, the faster, the better. And you can play this with your families or friends too see who is the quickest bug finder! 

* Sounds fun? I can‚Äôt wait, let‚Äôs get started!   |
| Create levels | * Ok, like every other projects, after opening a new one, we need to do a couple of things: first, change the project name to ‚ÄúLesson 5 - Find the Bug‚Äù. Next, set the stage size to 4x3 and finally delete the default sprite. We don‚Äôt need it. Ok, we have a blank slate now.

* Previously, the first thing we do is to select an appropriate backdrop for the project. And this one is no different. We also need to find the right image for the stage first. But we need to do a little bit more work here. If you still remember the demo at the beginning, you would recall that we have three different levels for the game, right? Each time we find the bug in the current level, we go through to the next one. How do we know it is the next level? Yes, the backdrop changes! And we are seeing a total of 4 different backdrops, the first three for the three levels and a final at the end of the game. So, what does that tell you? Yes, instead of having just one backdrop like all the previous projects, we probably going to need four for this game! Let‚Äôs see how to add multiple backdrops for the stage!

* Now, we have the stage selected and let‚Äôs click the ‚ÄúBackdrops‚Äù tab. Right, this brings us to the Backdrop editor. Well, nothing should be new to you here. We have the default blank backdrop in the backdrop list. Since we don‚Äôt need this one, we can delete it. But the thing is, when you only have one backdrop for the stage, Scratch won‚Äôt allow you to delete it, because well, the stage needs at least one backdrop after all. No problem, let‚Äôs just add a new backdrop. 

* So, select ‚ÄúChoose a Backdrop‚Äù and we are in the Backdrop library. Now, for the game, you can choose any image you prefer for each level, totally up to you. For me, I would search for ‚ÄúWoods‚Äù and add this one to our project. This is the same backdrop we used in the last Ghostbuster lesson. Ok, once you‚Äôve done that, the backdrop Woods is added to our list. Now, we can select and delete the default blank backdrop. Ok, so we have a backdrop for the first level of the game. How about the other two levels? Easy, just add two more images! So go to the Backdrop library again, I‚Äôm going to search for ‚ÄúFarm‚Äù and add this one. Woohoo, we have two backdrops now. For the third one, just do it again and search for ‚ÄúJungle‚Äù. Click and add this one too. Now, we have a total of three backdrops in the list! We are going to use each one for each level. Of course, you don‚Äôt have to use these three backdrops, free feel to pick any ones you like. There is just one thing you should keep in mind: the backdrop you pick should be as busy as possible so that it won‚Äôt be too easy to spot where the bug is. I think the three we have here are pretty good choices. Yes, there should be a fourth one for the end of the game. We will not worry about it for now and I will return to this later on. 

* Ok, since we want our game to start from level1, let‚Äôs click and select backdrop ‚ÄúWoods‚Äù before going back to the main editor. Ok, now you can see that the stage becomes a night forest. Ok, before we move on, there is something I want you to think about: we have been playing with sprites a lot, right? And one interesting thing about sprites is that you can change its costumes to make it look different from time to time, right? There is the ‚ÄúCostumes‚Äù tab that brings us to the Costume Editor, where we can add different costumes to the costume list for each sprite. Now, does that look and feel similar to what we have here for the stage and stage backdrops? Yes, as we have just seen, the ‚ÄúBackdrops‚Äù tab brings us to the Backdrop editor where we can add different backdrops to the backdrop list for the stage! So you can think of the stage as another special ‚ÄúSprite‚Äù, and its backdrops as the costumes for this special sprite. If you can make that connection, things will become more familiar and easier to understand. And in fact, this is one of the most effective way to learn: always try to find out if any new knowledge is similar or related to what you‚Äôve already known and make a connection between them. If you get into the habit of doing this all the time, you will become a very smart guy! Ok, anyway, that‚Äôs just a side note, let‚Äôs get back to the project! |
| Switch backdrop to Level1 | * OK, in the main editor, we have no sprites yet, just the backdrop. Now, I want you to pay attention to the code palette. At a first glance, it doesn‚Äôt look to be any different: you still have all those colorful code blocks. But if you take a closer look, something seems odd. In the Motion category, there isn‚Äôt a single block! Instead, it says ‚ÄúStage selected: no motion blocks‚Äù. Ok, let‚Äôs see what this means. First, it says ‚ÄúStage selected‚Äù. Well, this is obvious, we have no sprites now, and the stage is selected, as you can see here. So this whole sentence is saying ‚Äúbecause you have the stage selected, there will be no motion blocks to use‚Äù. Aha, ok..so we already know that all the code blocks are for us to write scripts for sprites. Now, it turns out that those code blocks can be used to write scripts for the stage too! Remember, a stage can be seen as a special sprite. If you can write scripts for sprites, there is no reason why you can‚Äôt do that for the stage too! Ok, but the stage is a SPECIAL sprite after all, so there must be some difference, right? Otherwise, where does that special bit comes from? And there is one of those differences. Let‚Äôs first remind ourselves what the Motions blocks are for? Yes, they are mostly used for moving sprites around on the stage. Ok, now, for the stage, do you think we would ever need to move the stage around? Of course not, right! You go the theatre, the performers sing and dance on the stage, but does the stage ever move? No! Right? So since it does not make any sense for the stage to move, there is certainly no need to have any ‚ÄúMotion‚Äù blocks for it! And that‚Äôs exactly what we are seeing here! Scratch makes your life easier by simply not giving you any Motion blocks for the stage at all! But as we can see, there are still many other blocks that you can used for the stage, such as the Looks blocks, the Sound blocks, the Events blocks, etc etc. There will be some differences there, but overall, they look pretty similar to those for sprites.

* Ok, now, since we know you can write scripts for the stage as well, let‚Äôs think about what we want the stage to do once the game starts. Like a sprite, you use the ‚Äúwhen flag clicked‚Äù hat block to kick things off. Ok, what do you think the very first thing the stage should do once the game starts? Ok, let me give a hint: we have three backdrops for the stage, right? Now, when the game starts, which backdrop do we want the stage to start with? Yes, the Woods backdrop! So the first thing we want the stage to do is to make sure it always start with the Woods backdrop, right? Make sense? Ok, as I said before, you can think of the stage as a special sprite and its backdrops as the sprite costumes, remember? How do we change the costumes of a sprite? Yes, there are some blocks in the Looks category that would allow you to change a sprite‚Äôs costumes, such as ‚Äúswitch costume to‚Äù or ‚Äúnext costume‚Äù. Now, since the backdrops are just the stage‚Äôs costume, can we use those same blocks? Let‚Äôs see. First, go to the Looks block category. Oh, no, there is no ‚Äúswitch costume to‚Äù or ‚Äúnext costume‚Äù blocks! What can we do? But wait! I can see a block called ‚Äúswitch backdrop to‚Äù and a block called ‚Äúnext backdrop‚Äù! Aha, what do you think about these two blocks? Yes! Because backdrops are just the stage‚Äôs costumes, so it makes sense to change the blocks names and replace the word ‚Äúcostume‚Äù with the word ‚Äúbackdrop‚Äù. 

* Ok, let‚Äôs drag out the ‚Äúswitch backdrop to‚Äù block and take a look at it. Just like the ‚Äúswitch costume to‚Äù block, this one also has a dropdown menu. If you click and open it, you can see a bunch of options. Starting from the bottom, there is a ‚Äúrandom backdrop‚Äù, ‚Äúprevious backdrop‚Äù and ‚Äúnext backdrop‚Äù. Well, I think those names clearly tell you which backdrops it is going to switch to. Let‚Äôs focus on the first three backdrops, ‚ÄúWoods‚Äù, ‚ÄúFarm‚Äù and ‚ÄúJungle‚Äù. Recognize those names? Yes, they are the backdrops we added to the stage‚Äôs backdrop list earlier. Since ‚ÄúWoods‚Äù is the backdrop we want to use for the first level, let‚Äôs select that. Ok, next we just need to connect this block to the ‚Äúwhen flag clicked‚Äù hat block. Now, every time the game starts, the stage is always going to start with the ‚ÄúWoods‚Äù backdrop. Pretty cool. 

* Test. Let‚Äôs test this. Now if we click the Go button, it might seem that nothing has happened, this is only because the stage already has the ‚ÄúWoods‚Äù backdrop. To see the code working more clearly, we can go into the Backdrop editor, select the second ‚ÄúFarm‚Äù backdrop, then go back to the main editor. Now, the stage has the ‚ÄúFarm‚Äù backdrop. If we click the Go button again, there you go, the stage switches back to the ‚ÄúWoods‚Äù backdrop. Nice!

* Ok, before we move on, I want to make some small changes to our backdrop names. Let‚Äôs go to the Backdrop editor again. Currently, the three backdrops are named ‚ÄúWoods‚Äù, ‚ÄúFarm‚Äù and ‚ÄúJungle‚Äù. We know that they are for Level1, Level2 and Level3. This is ok for a small game with only three levels. But if you‚Äôve ever played any real games, you know that a game can 10, 20 or even more levels. When this happens, names like these do not help you to keep track of which backdrop is for which level. And things can get messed up pretty quickly. So I think we need better names! What kind of names do you think can help here? Yes, very good. We can simply called ‚ÄúWoods‚Äù ‚ÄúLevel1‚Äù, ‚ÄúFarm‚Äù ‚ÄúLevel2‚Äù and ‚ÄúJungle‚Äù ‚ÄúLevel3‚Äù. Because we only which level a backdrop is for, and not what it is, whether it‚Äôs woods or farm, doesn‚Äôt really matter. And in fact, we might even change those backdrops later on. What does matter is the order in which they should appear. So to change the name of a backdrop, just select it, then in this box here, type in ‚ÄúLevel1‚Äù for ‚ÄúWoods‚Äù. And similarly for the other two. Let‚Äôs rename them to ‚ÄúLevel2‚Äù and ‚ÄúLevel3‚Äù. Right, now if we go back to the main editor, take a look at the ‚Äúswitch backdrop to‚Äù block, the ‚ÄúWoods‚Äù backdrop has been changed to ‚ÄúLevel1‚Äù automatically. If you click and open the dropdown menu, you can see ‚ÄúLevel1‚Äù, ‚ÄúLevel2‚Äù and ‚ÄúLevel3‚Äù instead. This makes it much clearer that we are now selecting the backdrop for level1, and not level2 or level3.   |
| Click bug to switch levels (backdrops) | * OK, the backdrops are all set. It‚Äôs time to add the bug! For the bug sprite, we are going to use the one in the Scratch library. Select choose a sprite to go to the sprite library. Search for ‚ÄúBug‚Äù and we can see quite a lot of bugs or insects showing up. The one I want to use is this one called ‚ÄúLadybug2‚Äù. Click it to add to our project. The bug is pretty big now and it is not difficult to find it at all. But not worry about that for the time being. We will come back to that later on. By the way, the ladybug sprite is currently being selected. So our code area is empty again and all the Motion blocks are back! To check the script for the Stage, just click and select it. Now, you see the script we created earlier and all the Motion blocks are gone again. As you can see, the Scratch editor can change what code blocks are available to you depending on what is currently selected. Now, let‚Äôs select the ladybug sprite again.

* Ok, with the bug on the stage, here is how the game should be played: whenever the player spots the bug, he/she uses the mouse pointer to click it. Once the bug is found and clicked, we are through to the next level. And this just repeats in the next level until we get through all levels to reach the end and Hooray! Ok, we can get some useful information from this. The first one is, when the bug sprite is clicked, something should happen, right? Ok, how do we kick start a script when a sprite is clicked? Yes, the ‚Äúwhen this sprite clicked‚Äù hat block in the Events category! We have been using this many times now! Cool, let‚Äôs drag that into our code area.

* Ok, what next? What should happen when the bug is clicked? Yes, we should move the player to the next level! What is the next level? Yes, it‚Äôs the Farm backdrop, right? In other words, when the bug is clicked, we want the stage to switch to the Farm backdrop. Aha, we have seen and used the ‚Äúswitch backdrop to‚Äù block for the stage script. Here, for the ladybug‚Äôs script, it seems that we need the ‚Äúswitch backdrop to‚Äù block again! But is this block available for a sprite? Let‚Äôs find out! Go to the Looks category, and can you find that block? Yes, it‚Äôs right after the ‚Äúnext costume‚Äù block! As it turns out, not the stage can change its backdrop, any sprite can change the stage‚Äôs backdrop too! That‚Äôs pretty handy! So let‚Äôs drag this block out and connect it to the ‚Äúwhen this sprite clicked‚Äù block. Cool. So what backdrop do we want to switch to? Aha, yes, the second Farm backdrop which is now called ‚ÄúLevel2‚Äù. Let‚Äôs pick that from the dropdown menu. OK, let‚Äôs test this!

* Test. Start the game. Click the bug and yes, we are through to the next level. Nice! OK, what should happen now if I click the bug again? Yes, we should be through to the next level, the Jungle, right? Let‚Äôs try! Click, click, click‚Ä¶hmmm‚Ä¶the backdrop didn‚Äôt change at all and we are stuck at level2! What is going on here? Anyone has any idea? Yes, take a look at the ladybug‚Äôs script. It always switch to the ‚ÄúFarm‚Äù backdrop when clicked. This is what we want when we are still at level1. But once we are at level2, we do not want to switch to the second backdrop again and again. Instead, we want to switch the next, the third backdrop Level3. That‚Äôs how the code should work! So can we select the Level3 backdrop from the dropdown menu like this? What do you think? Let‚Äôs try! Click the bug now and yes, we are through to level3! Hooray! How about let‚Äôs start the game all over again? Ok, we are back at level1 now. Click the bug, and‚Ä¶.hmmm, we go straight to the Jungle, the last level! Well, this is not too hard to explain, because we always switch to Level3 in the script. Ok, looks like we are stuck!

* Let‚Äôs think about it, whenever the bug is clicked, what we really want is to go to the next level, or in other words, we want to switch to the next backdrop. We don‚Äôt really care or even need to know what the next backdrop is. All we want is the NEXT backdrop. If you can understand this, then the ‚Äúswitch backdrop to‚Äù block is clearly not the best choice here because you always need to tell it what the next backdrop should be. And as we have seen, this does not work. Right, remember there is another block that we can use to switch backdrops? Yes, the ‚Äúnext backdrop‚Äù block! Aha, this sounds more like it! This block just switch to the next backdrop for the stage. It doesn‚Äôt care what the current backdrop is or what the next backdrop is. All it does is just switch to the next backdrop! Exactly what we need here. So let‚Äôs use this one instead.

* Test. Ok, let‚Äôs give this a test! Aha, yes, we can now go from level1 to level2 and to level3! Nice! Once we are at level3, clicking the bug brings us back to level1, so the ‚Äúnext backdrop‚Äù block always cycles through all the backdrops. This is just like the ‚Äúnext costume‚Äù block which cycles through all the costumes of a spite. In the final game, we would have an end of game backdrop but let‚Äôs deal with that later. For now, our problem is solved and we can move on! |
| Play sound when bug is clicked | * OK, in the last lesson, we have learnt that sounds play a very important role in any games. It can make the game either more exciting or engaging. In the Ghostbuster game, we played a popping to give  the player some feedback when the ghost is caught. Similarly, we can also play some sound when the bug is found and clicked. 

* Let‚Äôs first go to the Sounds tab of the ladybug sprite. Like all sprites, there is a already default popping sound. This is the sound we used in the last lesson. So let‚Äôs use a different sound here. First, select ‚ÄúChoose a Sound‚Äù to go to the Sounds library. Here, you can find all kinds of sounds. Like the backdrops, you are free to choose any sound that you find interesting. For me, I find the boing sound pretty quirky. So search for ‚Äúboing‚Äù and click this one named ‚ÄúBoing‚Äù. Now, it‚Äôs added to the sound list of our sprite. We no longer need the popping sound, so delete it.

* Now let‚Äôs get back to the main editor. When do you think we should play the sound? Yes, the bug is clicked! And how do we play a sound? Yes, we can use the ‚Äústart sound‚Äù block in the Sound category. Of course, there is another block that can play a sound too, the ‚Äúplay sound until done‚Äù block. Does anyone still remember the differences between these two? Yes, very good. So here, I don‚Äôt think it really matters which one you use, so I would just use the ‚ÄúStart sound‚Äù block. It already has the ‚ÄúBoing‚Äù sound selected. Let‚Äôs just add it before the ‚Äúnext backdrop‚Äù block. So when the bug is clicked, we first play a sound and then switch to the next backdrop.

* Test. Ok, let‚Äôs test this out! Start the game, click, Boing, click Boing, click Boing, hahah, this adds so much more fun to the game. Nice! |
| Bug shows at random position at each level | * Ok, we can now move from level to level by clicking the ladybug. But as it stands right now, the game is a little bit too easy for two reasons: firstly, the bug is too big to miss! Just look at its size! Secondly, the bug is always at the same position at each level. This is too predictable! If we want to make the game fun to play, we need to step things up a bit!

* Let‚Äôs first take a look at the second problem. Ideally, whenever we start a new level, we want the bug to be at a random position. Now, placing a sprite randomly on the stage is easy, we have learnt that in the previous lesson. Can anyone remind us all? Yes, the ‚Äúgo to random position‚Äù block in the Motion category. When we click it, we can see that the bug jumps around on the stage randomly. Cool. But again, once the game starts, we cannot click this block to move the bug. The code needs to run it. But when should it be run? Yes, whenever we go into a new level! In other words, whenever a new level starts, the bug should be at some random location ready for us to find! Right, the question now becomes, how do we know a new level has started? Well, first, let me ask you this: what changes when a new level starts? Yes, the backdrop, we switch a new backdrop for each new level, right? Ok, so what if we can say when the backdrop is switched to a new one, we place the bug at a random position? Sounds reasonable? Aha, when something happens, we do something‚Ä¶hmmm‚Ä¶does that sound familiar? When the Go button is click, we start the game, when the a sprite is clicked, we hide it. How did we do both? Yes, we use the ‚Äúwhen flag clicked‚Äù and ‚Äúwhen this sprite clicked‚Äù hat blocks. Remember? Hat blocks always kick start a script and they always start with the word ‚Äúwhen‚Äù. So what do we need now? Aha, yes, when the backdrop is switched to a new one, we wan to move the bug to a random position. So where do you think we should take a look at to maybe find a solution for this? Yes, the Events block category where all the hat blocks are. Let‚Äôs see. Anything useful here? Yes, there is a one called ‚Äúwhen backdrop switches to‚Äù, this looks very promising. Let‚Äôs drag it out! 

* This block as a dropdown menu. Let‚Äôs click and open that. As you can see, there are three options: Level1, Level2, and Level3. What do you think these are? Yes, they are the three different backdrops for our stage! The default is the first backdrop or first level ‚ÄúLevel1‚Äù. It now reads, ‚Äúwhen backdrop switches to Level1‚Äù, in that case, what do we need do? Yes, move the bug to a random position. So let‚Äôs connect the ‚Äúgo to random position‚Äù block to this hat block. Let‚Äôs test this out!

* Test. See? Every time we click the Go button to start the game, the bug appears at a totally different random position! Let‚Äôs see what would happen if we now click the bug. Ok, we are through to level2, but this time, the bug just stays at the same position as that of the previous level. If we click it again, we are now in Level3, but the bug‚Äôs position did not change either. If we click it one more time, we are back to Level1, and see, the bug is now at a different position. Why? Because of this script we have just written: everytime we go into Level1, the bug is going to a random position. Then why is this not happening for the other two levels? Yes, because we never tell the bug to go to a random position when the backdrop switches to either Level2 or Level3. Aha, do you know what to do next? Yes, we just add two more ‚Äúwhen backdrop switches to‚Äù blocks and select for Level2 and Level3. Finally, for each one, let‚Äôs add a ‚Äúgo to random position‚Äù block. Let‚Äôs test this again. OK, first level, click the bug, aha, see, in the second level, the bug is now at a completely different location! If we click it again, we are in level3 and the bug is at yet another a different position! Perfect! |
| Bug becomes smaller and smaller at each level | * Right, so we have made our game more challenging by having the bug showing at random location at each level. Still remember the other problem which makes our game too easy? Yes, the size of the bug. Currently, it‚Äôs just too big. I don‚Äôt think anyone with proper eyesight would miss it! Let‚Äôs make this a bit more difficult for our players! One thing about having multiple levels in a game is that you can make the progressively harder. So the next level is always a bit more challenging than the previous one. This not only keeps the players interested but also gives them a sense of accomplishment. So, when it comes to the bug size, how do you think we can make the game more and more difficult? Yes, the smaller the bug, the harder to find! We can start game with relatively big bug, but then as the players move from level to level, we can make it smaller and smaller. That‚Äôs sounds like a good plan!

* Ok, first question: how do we change the size of a sprite? Can you name two different approaches? Yes, the first one is to just change the size property in the property panel. The other one is of course using code block. Which code block? Yes, the ‚Äúset size to‚Äù block in the Looks category. Lets drag it out. Ok, next question is: where should we change the bug‚Äôs size? Yes, like going to a random position, we want the size change to happen whenever we go into a new level. Aha, we already have three scripts that handle the events when the backdrop is switched to Level1, Level2 or Leve3. So we can just set the bug‚Äôs size in each of those three scripts! Let‚Äôs add the ‚Äúset size to‚Äù block to each of them!

* Test. Right, let‚Äôs give this a test. Ok, level1, click, level2, click, and level3. Ok, nothing seems to have changed, the game works exactly like before. Why? Yes, because the bug‚Äôs default size is 100, and we set it to 100 when going into each level. Of course, nothing is going to change. As we have discussed earlier, we can make the bug increasingly smaller from level to level. For example, at the first level, we can leave it at 100. Now at the second level, how about changing it to 50%. So it‚Äôs half as big. Finally at the third level, let‚Äôs cut its size in half again by setting it to 25%. Let‚Äôs give this a try. Ok, at level1, everything is still the same, the bug is 100% big. Now, click it to go to level2. Yay! See, the bug is half as big and now it comes more difficult to find! But we can still find it. Click to go to level3. Wow, this is getting serious! Honestly, I did not see the bug at first sight. But after some searching, we can finally spot it! Click and we are back to Level1, when the bug‚Äôs size is also set back to 100%. OK, this is good, the game is getting hard and harder. But I still think it‚Äôs not hard enough. I want to make the bug even smaller and harder to spot. So at level1, I would start with size just 20%, then at level2, let‚Äôs half it to 10% and finally at level3, let‚Äôs half it again to 5%. Let‚Äôs see what this would look like.  Start the game, wow, it‚Äôs getting difficult even at the first level. OK, I can still see it, click and we are through to the next level! OMG, where is the bug? I mean seriously, where is it? Ah, I got it! It‚Äôs there! Click! Now, the final round! This is crazy, can anyone see where it is right now? Oh, I find it! Phew! This game is not so much more challenging and fun to play with! And this is exactly what we want to achieve! |
| Add End Screen Backdrop | * Ok, we have a pretty nice game. It has cool sound effect, multiple levels with increasing difficulty, and it‚Äôs just fun to play! But there is one thing I‚Äôm not still happy with. Right now, when you complete the last level, the game goes back to the first level directly. Usually, at the end of any game, there should an End Screen to sum things up. Here, you can show some useful information to the player. For example, when a player goes through all the challenges to reach the end, it would nice to congratulate them! After all, they spend quite to a lot of effort to get here so they probably deserve some encouraging words. Also, if people are playing this game with friends and families, it would useful to know how well each one did so that they can compete with each other. For this game, the player who completes all three levels in the shortest among of time is the winner. So we should at least let people know how long it took them to finish. And finally, you should also let the player know what he/she needs to do to restart the game. For example, there could be a ‚ÄúRestart‚Äù button of some sort for them to click. Let‚Äôs see how we can add these! 

* But before that, we need an End Screen! That means we need one more backdrop for our stage. So let‚Äôs select the stage first. Then click the ‚ÄúBackdrops‚Äù tab to go to the Backdrop editor. Again, we can see the three level backdrops we already have. Now, you can draw a new backdrop for the end screen or, like the level backdrop, you can select one from the Backdrop library. Here, I would just save some time and choose one that already exists. So select Choose a Backdrop. In the search box, type in ‚ÄúLight‚Äù and I‚Äôm going to select this one called ‚ÄúLight‚Äù. There you go, we have a fourth backdrop added to the list. Now, like the other three, we want to change its name so that it becomes clearer that this backdrop is going to be used for the End Screen. I would just name it ‚ÄúEnd‚Äù. Ok, this is all done and let‚Äôs get back to the main editor.

* Test. Ok, let‚Äôs test this. Start the game, level1, level2, level3, I find the bug, click it and there you go, we reached the End Screen! Nice!  |
| Congratulate player in End Screen | * Ok, let‚Äôs think about how we can congratulate the player for reaching this far! First, how can we show any text on the stage? Yes, we can use the ‚Äúsay‚Äù blocks! We have met those in the very first lesson ‚ÄúSpace Talk‚Äù, remember? Ok, but just knowing to use the say block is not enough. The next thing we need to decide is who, or which sprite, is going to say it? Now, take a look our project, what sprites do we have? Yes, we have just one sprite, the ladybug! So here is one option, we can just use this bug sprite to congratulate the player. Or you can add another sprite to do that. Personally, I prefer the first option since we already have the sprite, so why not? 

* Ok, let‚Äôs go to the Looks category and drag out a ‚Äúsay hello to 2 seconds‚Äù block. The reason we use this one is because, the other ‚Äúsay hello‚Äù block will just display the message forever, which is not what we want. Because after congratulating the player, we also want to show his/her completion time. Ok, just having this block it not enough, we also need to decide when this say block will be run. Any idea? Let‚Äôs think about it, the bug should only congratulate the player when he/she reaches the final end screen, right? How do we know that it‚Äôs the end screen? Yes, when the stage switches to the ‚ÄúEnd‚Äù backdrop! So it‚Äôs not that different from switching to one of the level backdrops, right? Ok, now, do you know when to run the say block? Try it! Ok, seems everyone got it! Yes, we just need to have another ‚Äúwhen backdrop switches to‚Äù hat block and choose backdrop ‚ÄúEnd‚Äù from its dropdown menu. Then, just connect the say block to it. Now, whenever we reach the final end screen, the bug should say ‚ÄúHello!‚Äù. Let‚Äôs see if this is the case!

* Test. Ok, start the game, level1, level2, level3, and End Screen, See? The bug says ‚ÄúHello‚Äù for two seconds. Nice! But right now, the bug is too small. We made it this small for the final level to make it hard for the player to find. But in the end screen, we actually want the bug to be big so that the player can actually see who is congratulating him/her. So once we reach the end screen, we want the reset the bug‚Äôs size back to 100%. This is easy, just add another ‚Äúset size to 100%‚Äù block to this end screen script. Now, here we need to make a choice, do we add this set size block before or after the say block? What do you think? Before? After? Ok, I can here someone say before? Why? Yes, very good, brilliant! Let‚Äôs say we add it after. Run the game and see what happen. See, when we enter the end screen, the bug was still very small when it says ‚Äúhello‚Äù. It‚Äôs only after the hello message is gone that it‚Äôs size was changed back to 100%. Does this look a bit strange? Sure. And the reason is because we place the set size block after the say block. Instead, we want the set size block to be run first as soon as we enter the end screen, then the bug can say ‚Äúhello‚Äù. Let‚Äôs try that. Yes, this is what we would expect. 

* Ok, there are two things we need to fix before moving on. First, of course, we want to congratulate the player instead of saying ‚Äúhello‚Äù. So let‚Äôs change the message in the say block from ‚Äúhello‚Äù, to something like ‚ÄúYou‚Äôve completed all levels! Well done!‚Äù. Also, we want the bug to be placed at the center of the end screen. This can be done by simply adding a ‚Äúgo to‚Äù block before the set size block and use 0s for both x and y coordinates.

* Test. Let‚Äôs give this a test. Yes, it‚Äôs at the center of the stage, has the right size and congratulating our player! Very cool! |
| Click bug to restart | * Ok, earlier, we said that the end screen should also provide a way for the player to start the game all over again. One option is to add a ‚Äúrestart‚Äù button to click. But because I‚Äôm lazy, I want to cheat a bit here. We already have a bug sprite in the End Screen right? What if we just use the bug as a ‚Äúrestart‚Äù button? Meaning if the player clicks the bug, we go back to level1 and the games starts again! So there is no need to add another button sprite! And you know what‚Äôs amazing about this? There is no need to add any code either! What? Are you sure? Well, if you don‚Äôt trust me, let‚Äôs run the game again!

* Test. Ok, start the game, level1, level2, level3 and end screen. The bug congratulates us. Now, see what happen if I click the bug. Hooray! We are back to level1! Isn‚Äôt that magical! But why? Why does that work without us writing any code? Can anyone explain that for us? Aha, bingo! Take a look at this script here when the bug is clicked. We created this to move from level to level, right? Now, when we are at the end screen and click the bug, is this script going to be run? Of course yes, it will be run whenever the bug is clicked, doesn‚Äôt matter whether you are at one of the levels or at the End screen. As long as the bug is clicked, it is run. And what does it do? Yes, it plays a sound and moves to the next backdrop! If we are at the end screen, what will be the next backdrop? Yes, the Level1 backdrop, so we are back to the start of the game without adding a single block! How cool is that! Of course, not every player knows to click the bug again at the end screen to restart the game. So let‚Äôs be a bit more helpful and add some instructions. So after saying ‚ÄúYou‚Äôve completed all levels. Well done!‚Äù, we can add one more say block to say something like ‚ÄúClick me to play again!‚Äù. Now, when we are at the end screen, the bug gives a very clear instruction about how to restart the game. Let‚Äôs click it and we are back to level1! Time to play again to see if you can find all bugs even faster! |
| Reporting time | * The faster the better, right? But there is a problem, how do we know we find all the faster this time? Or if you are having a competition with your friends, how can you tell who is the fastest? Well, you might say, ‚Äúwe can time it from start to finish‚Äù. That‚Äôs a good idea! How do you time it then? Yes, for example, you can use a stopwatch. Start the watch after the Go button is clicked and stop it when the bug is found in the final level. Then you would have the time it took to complete all levels. Pretty simple. But that means you need to have some sort of timing tool with you all the time. That‚Äôs a bit inconvenient to say the least. Would it be nice if Scratch has a ‚Äústopwatch‚Äù to keep the time for us? Well, we are lucky! The creators Scratch have actually thought about this problem and they have come up with something called a ‚Äútimer‚Äù.

* I think the best way to understand what a timer is and how it works is by actually playing with it. Now, I want you to look at a completely new block category called ‚ÄúSensing‚Äù. This name might sound a bit strange. But the blocks inside are some of the most useful ones and we will be using a lot them throughout the rest of the course. But for now, let‚Äôs focus on the ‚Äútimer‚Äù and the ‚Äúreset timer‚Äù blocks. For the ‚Äútimer‚Äù block, we have noticed something new: there is a checkbox right next to it. What is this for? Let‚Äôs try. When you click the checkbox, pay attention to the stage, do you see any difference? Yes, we can now see a timer on the upper corner of the stage! And the interesting thing is that this timer is live! It is ticking second by second as I‚Äôm speaking. OK, right now, it shows that 250 seconds has passed. But you may ask ‚Äú250 seconds from when?‚Äù. Well, think about a 400 meter running race. Say somebody finishes the race in 50 seconds, which is pretty fast. So 50 seconds from when? Well, in a running race, the runner start after the start flag is down. And that‚Äôs when the clock starts ticking, until when the runner crosses the finishing line. So it all starts when the flag is down! 

* Now back to Scratch. Do we have a flag as well? Yes, we do. We have been clicking this big green Go button for all our projects to kick things off! Does that look like the flag in a running race? I think so! Now, our timer is still ticking, it‚Äôs almost 600 seconds now. Watch what would happen if I click the Go button. Aha, see? The timer is reset back to 0 and starts ticking again. This is exactly like the case in a running race. So the timer starts from when the Go button is clicked and records how long it has been since then. To get the current time, you can also click the timer block and it tells you how long it has been ticking, so it‚Äôs 80 seconds now, it I click it again later, it becomes 95 seconds, and so on. 

* Ok, now we can start thinking about how to show players the time it took them to complete all levels. Think about the game as a running race and the player as a runner. When the game starts, the timer also starts ticking from 0 and the player starts ‚Äúrunning‚Äù. After he/she passes through level1, level2, level3, and finally reaches the end, or crosses the line, the timer at that point is the time it took the player from start to finish! Make sense? So in the end screen, to let the player know how well he/she did, all we need to do is just show the current timer. Simple, huh? Right, how do we show the timer on the stage then? Well, as always, the ‚Äúsay‚Äù block is your friend. Previously, we just type in whatever words or sentence we want to show in the first slot of this block. This slot is a rectangle with rounded corners, right? Cool. Now, take a look at the timer block, what shape do you think it has? Yes, it is also a rectangle with rounded corners. Hmmmm‚Ä¶.have we seen this somewhere else? Does anyone still remember? Yes, in the last lesson, when we want the ghost to wait a random number of seconds before showing up again, we put a ‚Äúpick random‚Äù block in the slot of a ‚Äúwait‚Äù block. And the reason we can do that is because both the ‚Äúpick random‚Äù block and the slot of the ‚Äúwait‚Äù block are rectangles with rounded corners! So it fits right in! And we say that you can always put rectangle blocks with rounded corners inside rectangle slots with rounded corners! Remember that? Do we have a similar situation here? Yes, we do! We can put the timer block inside the slot of the say block. Now, if we click the say block, the bug tells us what the current timer is! Pretty cool, huh?

* Now, it‚Äôs finally time to report how long it took the player to complete the game. We already have the say block to do that, it‚Äôs just a matter of finding where to put it. Since this is also going to happen at the end, so it‚Äôs most likely that the block will be part of this ‚ÄúEnd‚Äù script. Right now, the bug congratulates us and then tells us how to start the game again. Now, to report how long it has taken the player to get here, we need to say the time as soon as we enter the end screen. This is like you need to stop the watch as soon as the runner crosses the line. This means it has to be the first thing we say in this script. So we should put this new say block right before the other two. So now, it reports the time first before congratulating us and telling us how to restart the game. Let‚Äôs test this!

* Test. Notice that as soon as we click the Go button, the timer is reset to 0 and then start ticking. We gonna better be quick! Level1, level2, level3 and aha, the bug says 7.38 in the end scree and that‚Äôs how long it took us to finish the game. Not bad! 

* But I want to get better. So let me click the bug and restart the game! Ok, we are back level1. But wait, did you see what happened to the timer? Yes, it‚Äôs still ticking! It‚Äôs almost 100 seconds now. If we start playing now, then there is no way the time at the end would be correct. Because every time when we start from level1, timer should begin with 0. The reason it was set to 0 when we play it for the first time is because we click the Go button to start the game. Remember, clicking the Go button always reset the timer back to 0. But how did we get back to Level1 after the first play? Yes, we just click the bug at the end screen. Did we ever click the Go button? No? So would the timer be reset? Unfortunately No! Hmmmm‚Ä¶.what can we do? When we first introduce the ‚Äútimer‚Äù block, there is another block named ‚Äúreset timer‚Äù, remember? What do you think this block do? Yes, as the name says, it resets the timer! Let‚Äôs try. Now the timer is 700 seconds. Notice what will happen when I click the ‚Äúreset timer‚Äù block. Aha, see, it gets back to 0 and then start ticking again. So every time you click it, the timer gets reset to 0. It‚Äôs just like clicking the Go button, but with a code block! Ok, this could be useful. The next question, where should we use it? Well, let me ask you this: when should we reset the timer? Yes, when the game starts. Ok, next one: when does the game starts? Yes, as soon as we enter level1! Now, can you figure out where to put the ‚Äúreset timer‚Äù block? Brilliant! We should reset the timer as soon as the backdrop is switched to Level1. This means resetting the timer should be the first thing we do in this script. So let‚Äôs insert the ‚Äúreset timer‚Äù block right after the ‚Äúwhen backdrop switches to Level1‚Äù hat block. 

* Test. Ok, let‚Äôs give this one more test. The first thing you notice is that as soon as we click the Go button, timer is still reset to 0 and then starts ticking. So nothing has changed here. Now, let‚Äôs move from level1, to level2, to level3 and then finally the end screen. Ok, as you can see, the bug tells us how has it has taken us. Also notice that the timer is still ticking. But that‚Äôs fine. Now watch the timer carefully when I click the bug again to restart the game. Aha, see, as soon as we are back to level1, timer is also reset to 0 and then starts ticking, just like when we first click the Go button. Now, it doesn‚Äôt matter how many times we replay the game, the timer is always going to be reset to 0 each time. Cool!  |
| Distraction (Bat) | * OK, after we make the bug much smaller, the game is also much harder now. But I like to be challenged, and I think there are other interesting ways we can make the game even more difficult. The first one that comes to my mind is adding distractions. We all know how difficult it can be to focus on something if you are constantly distracted. Distraction can be auditory, for example, a construction site making huge noise when you try to finish your homework. Or it can be visual, for example, your cats or dogs moving around in the house when you try to watch your favorite show. So, let‚Äôs also make it hard for our players to focus by adding some visual distraction! 

* There are many ways you can do this, for example, by using an even more noisy backdrop. That‚Äôs also visual distraction. But I want to make things more interesting: I‚Äôm gonna add an annoying Bat that just flies around aimlessly on the stage forever! Well. you could replace the Bat with anything you like, I just choose Bat because I think they are pretty annoying in general. Right, let‚Äôs see how this can be done!

* The bat is a what? Yes, it‚Äôs a sprite! So what should do first? Yes, add a Bat sprite! Again, the Scratch sprite library already has a Bat sprite. So ‚ÄúChoose a sprite‚Äù, type in ‚ÄúBat‚Äù in the search box, and there you go, the Bat sprite. Click to add it to our project. Ok, the Bat sprite here, let‚Äôs add some code for it. Like all sprite, the script should start with a ‚Äúwhen flag clicked‚Äù hat block. Right, what do we want to do for the Bat when the game starts? Well, first of all, I think it‚Äôs a bit too big now. So let‚Äôs make it smaller by adding the ‚Äúset size to‚Äù block and set it to about 80%. Then we also want it to start at some random position. So add another ‚Äúgo to random position‚Äù block. Let‚Äôs test this.

* Test. Ok, the bat‚Äôs size looks about right and every time we start the game, it shows up at a different random location. Cool.

* Now, let‚Äôs get the Bat to move! Remember? We want the Bat to move constantly, non-stop on the stage, right? In other words, we want it to move forever! Aha, ‚Äúforever‚Äù! Does that ring a bell? Yes, we have just leant a very special loop in the last lesson: the forever loop! What is forever loop? Yes, as the name suggests, it just loops again and again without stopping! Sounds like what we need here. So let‚Äôs first drag one out from the Control category and put it after ‚Äúgo to random position‚Äù. Ok, next, we need to decide what the Bat needs to do inside this forever loop. Any idea? Yes, we want it to move! How to get a sprite to move? Yes, the ‚Äúmove‚Äù block, so let‚Äôs add that in the forever loop. I will leave it at 10 steps for now. We can always change it if the Bat is found moving too fast or too slowly later on. Ok, time to test again. 

* Test. Ok, out Bat moves. But I can immediately see at least two problems? Can you? Yes, the first problem is that the Bat always moves the right. What about the second problem? Yes, as soon as it reaches the edge, it just gets stuck and never moves again. Well, if we leave it like this, then it is not much of a distraction, is it? We need to fix this!

* So, let‚Äôs take a look at the first problem. Our Bat currently starts at a random location each time we run the game. That‚Äôs good. But the direction it points to is not so random. If you run the game again and again and pay attention to the ‚ÄúDirection‚Äù property in the property panel, you can see that it is always 90 degrees! And that explains why it always goes to the right. So we not only want the Bat to start at a random location, we also want it to point to a random direction. In Lesson Catch the School Bus, we have learnt about directions, the direction clock and how to make a sprite point to any direction. Still remember all that? Yes? Good! So we used the ‚Äúpoint in direction‚Äù block in the Motion category to make a sprite point to any direction we want. But if all we do is give it a specific number as the direction in the slot, then it will just always make the sprite point in that direction, right? For example, the default is 90 degrees, and it always points the sprite to the right. Not so much of randomness here! So what can we do? 

* First of all, how many degrees does a full circle contains? Yes, it has 360 degrees. So the direction can go from 1 degree all the way to 360 degrees, right? Now, if we can pick a random number between 1 and 360, and use that as the direction for the sprite to point to, then essentially, we can make the sprite to point to a random direction, right? Aha, I think we‚Äôve got something here. So the question now all goes down to how to pick a random number between 1 and 360? Anyone? Yes, great! We have learnt a very interesting block named ‚Äúpick random‚Äù in the last lesson! Remember that? What does that block do? Yes, it just pick a random number from a range. What is that range? Well, it‚Äôs a range defined by the two numbers to give to the two slots: the first slot is the smallest number of the range and the second slot it the largest number of the range. So the default is from 1 to 10. Now, if we change the range from 1 to 360, it would then pick a number in that range randomly, and that would be a random direction in a full circle. Now, how can we use this block to make a sprite point to random direction? Yes, just like we used this block in the last lesson to make a sprite wait for a random number of seconds, we can also use this block with the ‚Äúpoint in direction‚Äù block to make a sprite point to a random direction! Remember, you can always put a rectangle block with rounded corners into a rectangle slot with rounded corners? So we can put this ‚Äúpick random‚Äù block inside the slot of the ‚Äúpoint in direction‚Äù block just like that. Now, this combined block basically points the sprite to a random direction between 1 and 360, exactly what we need here. So after placing the sprite at a random position, let‚Äôs also point it to a random direction. 

* Test. Ok, time to give this a test. Ok, now every time we run the game, the Bat flies towards a different direction! It seems totally random now! But there is a small problem: since the Bat can now face any direction, it‚Äôs rotation is all over the place, sometimes even upside down. What if we just want it to stay upright without rotating at all? Yes, the solution is once again a block we learnt earlier, it‚Äôs called ‚Äúset rotation style‚Äù. Just to remind us, you can use this block to set three different kinds of rotation: ‚Äúleft-right‚Äù, meaning the sprite can only turn left or turn right, ‚Äúall around‚Äù meaning the sprite can rotate freely, just like the Bat here, and finally ‚Äúdon‚Äôt rotate‚Äù, well, this means the sprite cannot rotate at all. So which one do you think we should use here? Yes, ‚Äúdon‚Äôt rotate‚Äù, we don‚Äôt want the Bat to rotate at all! Let‚Äôs select that, insert this block right before we point the Bat. Now, let‚Äôs test it again. Ok, as you can see, it doesn‚Äôt matter which direction the Bat goes, it always stays upright, exactly what we want! Perfect!

* OK, time to solve the second problem: the Bat gets stuck as soon as it reaches any edge of the stage. Let‚Äôs say we don‚Äôt want the Bat to get stuck. How do you think the Bat should move when it reaches the edges? Ok, good. Now let‚Äôs do a thought experiment: imagine you are in a room and you have a ball. Now, say you throw the ball at any direction as hard as you can. What do you think is going to happen the ball? Yes, it‚Äôs going to hit a wall, the ceiling or the floor, depending on which direction you throw. Now, what is going to happen? Yes, the ball is going to bounce as soon as it hits a surface. Now, if you throw the ball enough, it‚Äôs probably going to bounce a few times before it comes to a stop. Are these all sound reasonable? Ok, now think of the Bat as a the ball and the stage as the room. When the Bat reaches any of the stage‚Äôs edge, what do you think should happen? Yes, it should bounce and then continue to move in a new direction. The only difference comparing to our ball example is that the Bat is going to bounce over and over again within the stage forever, it never stops. how annoying is that! This is how it makes it hard for our players to find the bug! 

* Ok, just saying to let the Bat bounce when it hits the edges is easy. But how can we make it happen? How do we know it reaches the edge and how can we make it bounce? These two seem to be pretty hard problems. None of which can be easily solve by using the blocks we have learnt so far. So are we doomed? Of course not! Actually, bounce a sprite when it reaches the edge is such a common thing to do in Scratch, the creators or Scratch have actually come up a single block to do both! Can you believe that? A single block to do such complex things! Now, the only problem left for us to solve is simply to find where this block is! So question for you: which block category do you think such block is most likely belong to? Aha, yes, hitting and bounce sound like a lot of some kind of motion, so let‚Äôs check the Motion category! Now, see if you can pin point it! Yes! The block is ‚Äúif on edge, bounce‚Äù! Such beautiful name and it just explains everything: it checks if a sprite is on any of the edges of the stage, if so bounce it back! Exactly what we need! Ok, we have the block, now the question is where should we put it? Any idea? OK, once the game starts, the Bat is going to move 10 steps at a time. Now, after each move, there is a possibility that it could hit one of those edges, right? And if it does, we need to bounce it. What this tells us is there, after each move, we need to check if it is on the edge, and if so, bounce. By now, it should be pretty clear that this block needs to come after the move block, inside the forever loop. Let‚Äôs place it there. 

* Test. Right, time to test this again. Woohoo, see that? The Bat is now bouncing around on the stage. It never gets stuck when reaches the edges. Pretty cool. And yes, it is annoying and distracted! But isn‚Äôt that exactly what we want? By the way, where is the bug? 

* Ok, this looks pretty cool and we are almost done, except one thing‚Ä¶ Does anyone know what? Think back at the parrots or the bears in Lesson 3 and can you see what is missing? Yes, we are missing some animation to make the bat look more alive! Still remember how the bear or the Parrot get to the school bus in Lesson 3? Yes, the Parrots flaps and the bears walks. And that‚Äôs what makes the sprite look like a living animal, not just a specimen in a museum. So how did we create such animation? Yes, we did that by continuously switching the sprite‚Äôs costumes. Now, let‚Äôs take a look at what costumes the Bat sprite has. Click the ‚ÄúCostumes‚Äù tab and you can see that the Bat has four costumes. If we click through them quickly, we can see that those costumes together create a flying animation. Right, now we just need to make use of them in our code. After learning Lesson 3, you should know how to do that on your own, right? Ok, let‚Äôs have a 3-min break and see if you can complete this? Ok, time‚Äôs up, everyone get it done? Well done. So let‚Äôs finish it together. The solution is pretty straightforward. All we need to do is just to make the Bat switch to a new costumes after each move. This can be done by using the ‚Äúnext costume‚Äù block in the Looks category. Now whether you put it after the ‚Äúmove‚Äù block or the ‚Äúif on edge, bounce‚Äù block doesn‚Äôt really matter, so I‚Äôm just going to put it here. Now of course, one important thing to remember is that, computer runs code very fast, so to actually see the costumes being changed, we need to slow things down by waiting a little bit after switching to each new costume. So let‚Äôs add a ‚Äúwait‚Äù block from the Control category right after the ‚Äúnext costume‚Äù block. We don‚Äôt want to wait for too long, so let‚Äôs set the wait time to 0.1 seconds.

* Test. Ok, let‚Äôs test everything out! Woohoo, see, the Bat is not flapping its wings while bouncing around on the stage. It looks pretty cool! Now let‚Äôs try to play the whole all over again. Level1, Level2, Level3 and we are done! So it indeed took us longer to finish the game because it is now much harder to find the bug at each level with an annoying Bat flying around. It‚Äôs so distracting. But at the End Screen, we notice something strange: the Bat is still trying to distract us even though we have made it through! Ouch! This needs to be fixed!

* Ok, how about you guys go ahead and figure out a solution for this. Quick tip: you can solve this problem with the blocks we already knew, no new blocks required. Right, 5 mins break and off you go! 

* Ok. Time‚Äôs up, anyone want to share your solution? Don‚Äôt be shy, it‚Äôs ok if you did not come up with the full solution. You can still share whatever you have and that might lead to the final solution. Come on! Ok, that‚Äôs very good. Let‚Äôs follow this lead. Now, at the end Screen, we do not want to see the Bat, right? And what can you do if you do not want to see a sprite? Yes, you hide it! For the Bat, whenever we enter the End Screen, let‚Äôs hide it. How do we know it‚Äôs the End Screen? Well, we already have a pretty good example: how does the bug knows it‚Äôs the End Screen? Yes, we use the ‚Äúwhen backdrop switches to End‚Äù. Can we do the same for the Bat? Of course we can! So let‚Äôs add a ‚Äúwhen backdrop switches to End‚Äù hat block for the the Bat. And what do we want to do there? Yes, we want to hide it. That‚Äôs simple, just add a ‚Äúhide‚Äù block under this hat block. And that‚Äôs it. That‚Äôs all you need! 

* Test. Let‚Äôs give this a try to see if it fixes our problem. Level1, Level2, Level3 and End Screen. Yes! The bat is gone! Nice! What if we click the bug to play again? Argoh, something is wrong, the game restarts, the bug is there, but the Bat is nowhere to be found! Errr‚Ä¶what went wrong? Yes, because we hide it at the End Screen! Remember, if you hide a sprite, then if will be hidden forever, until‚Ä¶.until what? Yes, until you show it again! Aha, when and where should we show it again? Yes, whenever we start the game from Level1. How do you know it‚Äôs Level1? Yes, just like how we know it‚Äôs the End Screen: we need another ‚Äúwhen backdrop switches to‚Äù hat block! But this time, the backdrop should be Level1. And what do we do there? Yes, simple, just show the bat again! Right let‚Äôs give this one more try! Ok, the first time we run the game, the bat is there. Level1, Level2, Level3 and the End. Now, let‚Äôs replay the game, and there you go! The annoying Bat is back! Awesome! |

### Exercise

- Can you add more backdrops and create more levels for the game?
- Can you add some background music to the game that plays repeatedly? Where should you add the code?
- Is there a block that tells you what the number or name of the current backdrop?
- Can you add even more distractions to the game?
- Can you increase the amount of distraction as the players progress from level to level?
- What else can you do to make it even harder to find the bug? (think about different effects you can apply to sprites)
- Play the game with friends and families to see who is the best bug finder!