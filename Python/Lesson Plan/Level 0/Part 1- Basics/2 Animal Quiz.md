# 2 Animal Quiz

### Reference

“Coding projects in Python”

### Code

[My-Programming-Courses/Python/Level0/Basics/2 Animal Quiz/main.py at main · jguo108/My-Programming-Courses (github.com)](https://github.com/jguo108/My-Programming-Courses/blob/main/Python/Level0/Basics/2%20Animal%20Quiz/main.py)

### Key Points

- String
    - String concatenation
    - string method ‘lower’/’upper’
    - string method ‘strip’
    - String comparison’
- Value comparison
    - Equality check
    - Bool valyes: True/False
- Conditional
    - ‘if…else…’ statement
    - Colon after ‘if’ statement and ‘else’ statement
    - Code block indentation
- User-defined function
    - Reduce code repetition
    - Function definition and call
    - Passing arguments to user-defined functions (different between ‘argument’ and ‘parameter’)
    - global variable vs local variable
    - Call function on a value/variable
    - Named arguments
- Misc
    - Sequential execution order
    - Change value in a variable by assigning it new value (‘answer’ variable)
    - Increase/Decrease a value
    - Case sensitive
    - Keywords
    - Indentation

| Step | Note |  |
| --- | --- | --- |
| Introduction | * Ok, welcome to the second Python lesson. Last time, we created a Math Genius and tested it with some pretty challenging questions. Today, we are going to switch roles. This time, our Python program is going to test us on our knowledge about Animals! 
* Let’s first see how it works. When the program starts, it first prints a message ‘Welcome to the Animal Quiz!’. The next, it’s going to ask the first question:  “Which is the fastest land animal?” and waits for our answer. Being a super fan of the BBC Planet Earth series, I have no problem answering it:  it is the Cheetah! And sure enough, it says “Awesome! You got it right”. Then it continues with the second question “Which is the largest animal?”. Well, this one is also pretty obvious, the answer must be the Blue Whale, and I have go it right one more time! Hooray! Ok, the final question: “Which land animal can’t jump?” Hmmm…I’m not too sure about this one. I guess it’s “Giraffe”? Maybe? Oops, got this one wrong, and the answer is Elephant. Didn’t see that coming! And at the end, we get our total score. Since I got two right and one wrong, my score is two! Not too bad!
* You can of course add more interesting questions to the quiz and challenge your friends or families and see who is the animal expert! So let’s begin today’s lesson!  |  |
| Print greeting message | * Ok, let’s print a welcoming message first. This should be fairly easy for you know, just ‘print’, brackets, and pass string “Welcome to the Animal Quiz!” to the ‘print’ function.
* Test. Let’s run it and yep, we can see the message. Cool. Here I have to say this again, when you write code, it’s always a good idea to run the code as often as you can so that you can find any issues or problems as early as possible. Don’t write the entire program without running it and hope that everything will be fine at the end. This will never be the case and it will be more difficult for you figure what what went wrong when there is already a lot of code. So please keep that in mind. |  |
| Ask first question and receive answer | * Ok, next we are going to ask the first question, “Which is the fastest land animal?” and wait for an answer from the user. Ok, in the last lesson, anyone remember how we asked for numbers from the user? Yes, we use the ‘input’ function to print out a message telling the user a number is expected, then wait for the input. Here, we can do the same. Let’s call the ‘input’ function, remember, you always need the brackets when calling a function. Then inside the brackets, let’s pass a string argument as the first question, “Which is the fastest land animal?”
* Test. Now, let’s run this. First, the welcome message and then it asks us the first question. Now let me type in “Cheetah” and the program ends. Ok, so far so good!
* Next we need to check if the user’s answer is correct or not. But before that, we need store the answer somewhere right? Just like in Math Genius, before it can do the math operations, it needs to store the two numbers entered by the user. And, remember, we used two variables, “num1” and  “num2” for that. Here, we also need a variable to store the user’s answer. Let’s just called it ‘answer’ and we assign the returned value from the ‘input’ function into this variable. So let’s recap a little bit, in Python, we create a variable by assigning some value to it. ‘Assign’ here simply means putting whatever value on the right side of the “=” symbol to the variable on the left side. Here, the value is just the return value of the ‘input’ function. Ok, to check that variable ‘answer’ indeed stores what the user has typed in, let’s just print it out for the time being.
* Test. Now I’m gonna type in “cheetah” again and in the next line, “cheetah” is printed out. This just proves that variable ‘answer’ indeed has the correct value. Nice! |  |
| Equality Check | * Ok, since this is a quiz after all, simply printing the user’s answer is not enough. Instead, we need to decide if this answer is indeed correct. For example, if someone answers ‘turtle’, then clearly this is wrong. Ok, let’s forget about Python for now and come back to real life. Say you are testing your friend’s knowledge on animals. You ask him/her the question “What is the fastest land animal?” He/she might then give you an answer, right? Now, how do you check if this answer is correct or not? Well, since you are the one who asks the question, I assume that you already know what the correct answer is, “cheetah”. You would them compare what your friend gives you with the correct answer “cheetah” in your head and see if they are the same or not. Pretty simply, huh?   
* Right, now back to Python. Since we already have the user’s answer in the “answer” variable, the first thing we need to do is to check if the value in “answer” is indeed “cheetah”. Well, you might say, “It is clearly ‘cheetah’ since we have just printed its value out!” Yes, you are right, we know it is “cheetah” because we as human can clearly see it on the screen. But just because we can see it does not mean our python program can see it too. In fact, a Python program has no eyes so it can‘t just look at the output and say “Yep, that’s correct!”. It needs a different way to make decisions. And the decision our program needs to make here is if the value in variable “answer” is the same as string “cheetah”, or in other words, if they are equal to each other.
* Ok, let’s draw some inspiration from math again. In math, when you want show that two numbers are equal, we use the ‘=’ symbol. For example, say “4 = 4”. Now, in a programming language like Python, can we use the same symbol to show that two numbers are equal? Let’s try! Go to the shell and enter interactive mode. Let’s first type in “4 = 4” and hit return. Oops, we have a syntax error! If you recall from the last lesson, we have seen such error there when we forgot to quotes to a string. But the syntax error here is clearly not caused by that. So let’s read on and see what Python is complaining about, it says “cannot assign to literal here”, Ok, that still does not make too much sense, and let’s continue, at the end it says “Maybe you meant ‘==’ instead of ‘=’”. Aha! Do you see where is this going? It’s suggesting maybe it is the ‘==’ that we should be using instead! Hmmm….but why? Isn’t ‘=’ supposed to be used to check for equality just like in math? Can any one guess why it is wrong here?
* In the last lesson, we introduced “assignment” right? What is assignment? Well it basically assigns a value to a variable. How do we do that? We use the ‘=’ symbol, put the value on the right and put the variable on the left, right? Everybody remembers that? Ok, now does anyone know why we are having this syntax error here? Yes! Unlike in math, the ‘=’ symbol means ‘assignment’ in Python instead of equality! So when we type in “4 = 4”, what python thinks is that we are trying to assign the value number 4 to another value number 4. Unfortunately, this does not make sense in Python at all. Remember, only variables are likes boxes that can store values, right? So 4 is clearly not a variable, and in fact, it itself is a value, so how can you put value inside another value, this is crazy! So python also thinks that you are crazy so it spits out this syntax error. But it is also nice and smart enough to suggest something else, maybe you should use “==” instead? Yes, this is Python’s solution for equality check, since I cannot use the ‘=’ symbol again because it is for assignment, so I will just add another ‘=’ symbol to make it two for equality check. |  |
| Bool values | * Brilliant idea worth trying out! Let’s type in “4 == 4” this time and see what happens. Ok, this time there is no error, that’s good. But it prints out a word “False”. What does that mean? Ok, in last lesson, we mentioned that there can be different types of value in Python. We have seen numbers, which can be integers or decimals. And we have see strings as well. We also introduced a built-in function called ‘type’ that you can used to find out the type of a value. For example, “type(4)” gives you “class ‘int’” and “type(’abc’)” gives you “class ‘str’”, which is just short for string. Now, we are going to meet the third type of values in Python, it is called ‘bool’. Ok, this is probably going to be strangest name you will ever see in Python. But the idea is pretty simple, a ‘bool’ can only have two values: ‘True’ or ‘False’. To understand these two value, I find it most useful to think of them as being “correct” or “wrong”. So if something is “True”, it is the same as being “correct”, on the other hand, if something is “False”, it is the same as being “wrong”. For example, earlier when we type “4 == 4”, Python prints out “True” because 4 is indeed equal to 4, this is correct. What if I type in “4 == 5”? This time Python prints out “False”, because 4 is not equal to 5 and this is wrong. As I said earlier, the type of “True” and “False” values is “bool” and we can confirm that by passing them to the “type” function. So “type(True)” and it says its type is “bool”. Same with “False”, the type is also “bool”. One thing I need to point out is that “True” and “False” are very special values in Python and they have to be spelled exactly like this, meaning you can’t use a lower case “t” for “True” or lower case “f” for “False”. Let’s try calling “type” function and this time pass “true” all in lower case, Python complains with a “NameError” saying “true” is not defined.
* This leads to another important point in Python, that is Python is case sensitive, meaning whether a letter is lower case or upper case matter. So “True” with a capital “T” is not the same as “true” with a lower case “t”. This rule applies to pretty much everything in Python. For example, when you name a variable, case matters. If I have two variables, one called “Name” with an upper case “N” and one called “name” with a lower case “n”, these are two completely different variables, like two different boxes. So be careful with that as some Python beginners often mix those up.
* Right, so far we have only been comparing numbers. But the “==” can be used to compare strings as well. For example, if I type “abc” == “abc”, it prints out “True”. If I change that to “abc” == “def”, it prints out “False”. If I just type in “abc” == “Abc” with a capital letter “A”, it prints out “False” this time. This just shows again that strings in Python are also case sensitive, “abc” is not the same as “Abc”.  |  |
| ‘if…else…’ statement | * Ok, now we have a way to compare two strings and see if they are equal or not, let’s come back to the script. For this first question, we know the correct answer is “cheetah”. So to check if the user’s answer is correct, we need to compare variable “answer” with string “cheetah”. Instead of printing variable “answer” here, let’s first print the result of comparing “answer” with string “cheetah”. From what we have just learnt, this is as simple as <answer == “cheetah”>.
* Test. Let’s run the program. Say I type in “cheetah”, the program prints out “True” as expected. If I run it again and type in “tiger” this time, the program prints out “False” which is also expected. So we can now check if the user’s answer is correct or not. That’s a step forward! Nice!
* Ok, we can now decide whether the answer is correct or not. As I have shown you at the beginning of this lesson, when the user answers correctly, we are going to print message “Awesome! You got it right!” and when the user get it wrong, we print a different message “Oops, this answer should be cheetah!”. 
* So far, our programs always run ALL code from top to bottom: it runs the first line, then the second line and so on and so forth until the last line is finished. This is what we call the “Sequential Order”, meaning all lines of code are run one after the other in a sequence. This is the most common order when running a program. However, if this is the only order the run code, then there is a problem: in our case, we want to run different code depending on whether the answer is correct or not: if it is correct, we print one message, else we print a different message. It’s a bit like when you are driving on the road and come to a Y junction, you can go either left or right. For example, if you want to go home, then maybe you would take the right arm, else, take the left arm. In a program, we also need to be able to go left or go right at times!
* If you have listened carefully so far, all the examples I gave go like this: if something is True, then do this, else, do that. This “something” is what we call a “condition”. What is a “condition”, well, it is something that can be either True or False. For example, in the Y junction case, the condition is “I want to go home”, if it is True, then I go right because that’s the way home, if it is False, then I go left. In our Animal Quiz example, the condition is “the user’s answer is ‘cheetah’”, if it is True, we print one message, if it is False, we print a different message. 
* This is all good, but it is all in plain English, how can we translate that into Python programming language so that the computer can understand and run it? Fortunately, in Python and pretty much all programming languages, there is something called “conditional statement” for you to make decision and take action accordingly. Let’s see how it works.
* Let’s first see the most common conditional statement: the ‘if’ statement. Type in “if”. Conditional statement is special in Python, the word “if” is what we call a “keyword”, so is highlighted with a different color. Now after the “if”, we need to provide the condition for it to check. In this particular case, we need to check if variable “answer” is equal to string “cheetah”. We already know how to do that, so let’s type in <answer == “cheetah”>.  Now, it is very important, after you finish with the if condition, always add a “:”, it is like saying “Ok, I’m done with the condition, now it’s time to add the code to run when this condition is True”. What do we want to do when “answer” indeed has the value “cheetah”? Yes. we want to print a congratulation message. Let’s do that!
* After the “:”, hit return. You would notice that the cursor does not start at the very beginning of the next line. Instead, it is “indented”, meaning some spaces are added at the beginning of the line. To be exact, there are four spaces. Space is a character that you can type in to your code when pressing the space bar on your keyboard. It is special because you cannot see it, but it is there. The indentation, or the four spaces at the beginning of the line, is very important here. It basically says “all code indented here belongs to the ‘if’ statement and will only be run if the condition is True”. Ok, if this sounds too confusing, let’s actually write some code and see how it works. In the current line, lets print “Awesome! You go it right!”. Make sure you have the indentation at the beginning.
* Test. Ok, let’s run it. Type in “cheetah” and hit return. Cool, it says “Awesome! You got it right!” Let’s walk through the code slowly and see how we got here. When I typed in “cheetah”, this string is received and returned by the ‘input’ function and then stored inside variable “answer”. Then the “if” statement checks if “answer” is equal to string “cheetah”. Because this is true, so it runs all code that is indented next, which calls function “print” to print out the congratulation message. All good? Now let’s run the code again, this time I will type in “tiger”. Hit return and nothing is printed? Can anyone walk me through this time to explain why? Yes, when I type in “tiger”, variable “answer” stores string “tiger”. When the if statement compares “answer” with “cheetah”, clearly they are not equal this time. So the next line of indented code, which is the “print” here, will not be run at all. Remember, the indented code after the if statement will only be run when the if condition is True. So the entire if statement is finished and since there is no code after it, nothing is printed. 
* Ok, to show you why indentation is important, let’s call “print” again to print message “The first question is pretty simple, huh?” and indent this line of code.
* Test. Let’s run it. Type in “cheetah”, and now we see both messages being printed out. Because both calls to ‘print’ are indented after the “if” statements, so they become a block of code that will be run together when the condition is True. For comparison, let’s now remove the indentation before the second print so it now starts at the very beginning of the line. What do you think would happen if I type in “cheetah” now? Not sure? Let’s try out! Type in “cheetah” and we still see both message, it is as if nothing has changed. But there is actually a very important difference. Previously, when the condition is True, we run all the code inside the “if” statement, which are the two ‘print’ function calls. That we already know. Now after we remove the indentation before the second ‘print’, it is no longer inside the ‘if’ statement, but why are we still seeing two message? Well, let’s trace it step by step. When ‘answer’ is ‘cheetah’, the condition is True, so we go inside the ‘if’ statement and print the first message, right? No problem with that? Then since there is nothing else in the ‘if’ statement, if finishes. And because programs outside of an ‘if’ statement is fun sequentially from top to bottom, so it continues to run the next line of code, which is the second ‘print’ that prints the second message. That’s why we still see the two message being printed out. So the difference becomes very obvious when the condition is False. Let’s try! First, add the indentation back to the second ‘print’ and this essentially moves it back inside the ‘if’ statement. Now run the code. This time, let me type in ‘tiger’. Now see what happen. Nothing is printed! Why? Well, this time ‘tiger’ is clearly not equal to ‘cheetah’, so the condition becomes False. As we have learnt, code inside the ‘if’ statement is only going to be run when the condition is True. So when it is False, no code will be run and no message will be printed. Make sense? Now, see what happen when remove the indentation before the second print, essentially moving it out of the ‘if’ statement again. Run the code, and type in ‘tiger’. Wow, this time, we only see the message from the second ‘print’. Why? Yes, because the condition is False, Python will not run the code inside the ‘if’ statement and when the ‘if’ statement finishes, the program continues with the code after it, which is the second ‘print’. It runs that and prints the second message out. Hopefully, this example helps you to understand what the indentation really means and when and why you should have it. Ok, let’s delete the second print because we no longer need it.
* Ok, let’s now look at the other side of the coin, what should happen when the answer is incorrect? Well, we would like to let the user know that he/she is wrong and give the correct answer too! So we would print message “Oops! The answer should be cheetah!”. Ok, now question for you: where should we put this ‘print’? Now clearly, we cannot indent it and put it inside the ‘if’ statement. If we do that then what would happen? Yes, when the user gives the correct answer, we will print “Yeah, you are right!” and then ”Ah, you are wrong!”. People must think the program has gone crazy! At the same time, if the answer is incorrect, then we will not see any message, that’s not good either! How about removing the indentation of the second print and move it out of the ‘if’ statement. This time, when the answer is incorrect, we only see the message “Oops! The answer should be cheetah!” Wow, this looks promising, it is exactly what we expect! Are we done here? Well, try what happen when the answer is correct! Oops, we are still seeing both messages being printed! Not good! 
* So to get out of this problem, what we really want is to only print the first message when the answer is correct or when the condition is True and only print the second message when the answer is wrong or when the condition is False. Hmmm…how can we do that? Remember the Y junction example? We have the option to either go left or go right. Here the ‘if’ statement allows us to go one way when the condition is True, we need to have the other option to go a different way when the condition is False.  Fortunately, there is an ‘else’ statement in Python just for that. Unlike the ‘if’ statement, this ‘else’ statement cannot be used by itself, it has to be used together with an ‘if’ statement. When used together, they provide two directions for you to go, one when the condition is True and the other when the condition is False. You can add the ‘else’ statement after all the code inside the ‘if’ statement. But be careful, do not indent it because it is not supposed to be inside the ‘if’ statement. Also, remember to add the “:” after “else” to say “Now it’s time to add code for the ‘else’ statement”. Ok ,once this is done, let’s move this second ‘print’ inside the ‘else’ statement by indenting it. Ok, we now have what people often refer to as the ‘if…else…’ statement. When the code reaches here, like a Y junction, it can go either way, if the condition is True, it runs all the code inside the ‘if’ statement, else, or when the condition is False, it runs all the code inside the ‘else’ statement.  
* Let’s test this out! When I type ‘cheetah’, it only prints ‘Awesome! You got it rigth!’, and when I type in ‘tiger’, it only prints ‘Oops! The answer should be cheetah!’. Cool, looks like we have the correct message printed no matter what the answer it! Nice! Problem solved!  |  |
| ‘lower’ method | * Ok, let’s address a small problem before moving on. 
* Test. Run the program again and this type I type in “Cheetah” as the answer. Can you spot the difference here? Yes, I used a capital letter ‘C’ this time. So which message do you think is gonna be printed? Anyone want to have a guess? Not too sure? Let’s try out. Hit return and it says “Oops! The answer should be cheetah” so we got it wrong? But why? Ha, the secret lies in the capital letter ‘C’ here. Earlier we mentioned that things in Python are case-sensitive, meaning a capital letter is not the same as its lower case counterpart. So when type in bool value ‘True’ always use capital letter ‘T’ and when type in keywords ‘if’ or ‘else’ never use any capital letters. Same for strings, a string “cheetah” with all lower case letters is not the same as a string “Cheetah” with the the letter ‘C’ being capitalized. But you might then argue: “This is stupid, you can’t just say the answer is wrong simply because I use a capital letter ‘C’ for the word ‘Cheetah’, right? It clearly means the same thing!” Well, you and right and wrong: right because they do mean the same thing, wrong because they only mean the same thing for us human. Computer are very rigid, or as some people like to put it “stupid”. It always follow very strict rules. The rule here is that “strings are only considered equal if they have the same letters and case”. If this rule is broken, then sorry, the strings would look different to me, as a stupid computer. 
* Ok, what can we do then? Now the string we use to compare with ‘answer’ is all in lower case, right? So what if we can somehow convert the answer into all lower case as well? So it doesn’t matter whether the user enter ‘Cheetah’ with a capital letter ‘C’ or even ‘CHEETAH’ will all caps, we will convert it into all lower cases. So all we care about is if the answer has the exact letters ‘c’, ‘h’, ‘e’, ‘e’, ‘t’, ‘a’, ‘h’. Whether they are lower case or upper case, we don’t care. Fortunately, converting a string into all lower case is pretty simple. Let’s go to the Shell again. Let me type a string “ABC” with all caps. Suppose I want to convert it into all lower case string ‘abc’. Now watch carefully, after the string, type in a single dot ‘.’ and then after the dot, type in ‘lower’ and a pair of empty brackets. Ok, this might look very strange to you so let me explain a little bit more.
* Previously, when we introduce built-in functions like ‘print’ and ‘input’, I said that calling those functions is like giving instructions to a computer to do something, right? So ‘print’ asks a computer to print something on the screen and ‘input’ asks it to take some input from the user. And we also know that to call a function, you always follow the function name by a pair of brackets, and in some cases also need to pass one or more arguments in the brackets. So take a look at this ‘lower’ here, it also has a pair of brackets, so that kind of suggests it is also a function call. But what does it mean to have the string and the dot at the beginning? Well, it means to call a function on a value. Ok, I know this still sounds confusing but the easiest way to understand this is, instead being very general and giving an instruction to a computer to ask it to do something, such as the ‘print’ and ‘input’ functions, we give a value an instruction and ask it to do something. So we are being very targeted this time, the instruction is specifically for the value before the dot. In this case, the value is the string ‘ABC’. So what instruction are we sending to the string here? Yes, we call the ‘lower’ function and can you have guess what it is asking the string to do? Yes, it asks it to convert itself into all lower cases. Let’s hit return and there you go, the string has been converted into a all lower case string “abc”.  
* There are actually a lot more functions you can call on a string value. For example, if I have string “abc” all in lower case this time and I want to convert it into all upper case, I can call function ‘upper’ on the string value using the dot syntax again. Hit return and there you go, an all capital string ‘ABC’.
* Before we move on, there is a small thing I want to point out, when we call a function on a value, this function is often referred to as a ‘method’. It is just a different name that people often used. Other than the name, everything else is the same as a function, for example, you call it with a pair of brackets and you can pass arguments to it as well. I just mention this so that you are not confused when seeing the word ‘method’ in the future.
* Now, you might be thinking, “Ok, I now know that you can call ‘lower’ or ‘upper’ method on a string, but how do I find out what other methods are available?” Well, the easiest way is to go to this [web page](https://www.w3schools.com/python/python_ref_string.asp) where all string methods are listed. If there is one you want to know more about, just click it and this brings you to a bew page for that method with more information. For example, I can find the ‘lower’ method here, click it and this brings up a new page. Here, we can see a small example, its definition and the syntax of using it. Notice that the syntax is exactly what we have talk about, you have the string and a dot and finally the method with a pair of brackets.

* Now, back to the script. Our original goal was to convert the string value in variable ‘answer’ into all lower case and compare it with string ‘cheetah’ right? So, after the variable ‘answer’, type in dot, and then ‘lower’ and finally a pair of brackets. For the ‘lower’ method, there is no need to pass any arguments, so let’s just leave the brackets empty. What is is doing is, it converts the string value in variable ‘answer’ into all lower case. So it doesn’t matter if the user enter ‘Cheetah’, ‘CHEETAH’ or ‘ChEEtah’, they are all consider correct answer. 

* Test. Let’s test this out. Now, see? Case does not matter here, as long as we type in ‘cheetah’, the program thinks we got it right! Cool! |  |
| More questions | * OK, now we have finished the code for the first question. Time to add more. Let’s have a 5 min break here and see if you can add the other two questions yourself. You can choose any fun fact about animals you like and turn it into a question. The more surprising the better! Off you go!
* Ok, times up! Anyone got it done and want to share your questions with us? Good! These are all very interesting questions. Actually, I don’t even know that! 
* OK, let’s me finish mine before we move on. For the second question, first, take the input from the user. So let’s reuse the variable ‘answer’ and assign it a different return value from the ‘input’ function. Note that you can always change the value stored in a variable just like you can change the stuff in a box. The question I chose is ‘Which is the largest animal?’ and let me pass this string as the argument to the ‘input’ function. Next, lets check the answer. This is going to be very similar to the first question. So I will just copy all the code here and paste it after the input. So some of you ask me how to copy and paste code. This is pretty simple, hold down your mouse and drag it to highlight all the code you want to copy, then press ‘Ctrl+C’ on the keyboard. Next move the mouse to where you want to paste the code and press ‘Ctrl+P’.
* Ok, once we have the code pasted, let’s make some change in two places. First, the correct answer is not ‘cheetah’ any more. Does anyone know which the largest animal? Yes, it’s the Blue Whale. So change the string from ‘cheetah’ to ‘blue whale’. Next, when the user got it wrong, we need print out the correct answer, so let’s change the ‘cheetah’ here to ‘blue whale’ too! That’s it! Second question done! Simple, huh?
* Ok, I only plan to have three questions, so one more to go! Same thing, first assign a different input value to variable ‘answer’, change the question to ‘Which land animal can’t jump?’ Wooo, this is hard one! Next, copy the ‘if…else…’ statement, and change the answer to… anyone want to guess this one? Yes, it’s the ‘elephant’. And we are done!
* Test. Ok, let’s run the program and test all three questions! |  |
| Score | * In any kind of quiz, it’s always a good idea to let user know how well he/she did. The most common way is add some kind of score. This score only increased when a question is answered correctly. When the quiz is completed at the end, the final score is then shown to the user. So let’s add that to our quiz too!
* First let’s think about what a ‘score’ really is. It is just a number, right? Or to be more precise, it’s an integer number. The next question is, what should this number be? Should it be 0? 1? 2? or something else? Anyone have any idea? Yes, we don’t know what it should be! It’s a score so the number depends on how well the user answers those questions. If he/she did really well, then the score might be big number, on the other hand, it might be a small number. Also, it might change as the user answers each question. So what should we do then?
* Well, if it is a value that can change, then I think we might something just for that? What do you think? Anyone? Yes! Variable! You can put anything into a variable, a number a string, just anything. And more importantly, the value in a variable doesn’t have to be the same always. You can change it later on if needed and that’s what it has the name ‘variable’. For example, you can have number 0 in a variable at the beginning, then later change it to 1, and then 2 and then 3 and so on and so forth. All up to you! So this sounds like a perfect solution for us and let’s see how the code looks like!
* First, we need a variable and what name can better than ‘score’? So let’s type in ‘score’ at the beginning of the program. Remember, you always need to assign an initial value to a variable to create it. Otherwise, Python would not be happy. When the quiz first start, the user has not answered any question yet, so the score must be zero. Let’s assign that to variable ‘score’. Ok, after that, variable ‘score’ is officially created and can be used by the rest of the program.
* Now, we want to add one point for the user if he/she answers a question correctly. Where in the code do we know that a question is answered correctly? Yes, it is inside this ‘if’ statement. So, we need to change increase the value stored inside variable ‘score’ by one here. But how?
* Some of you might say, this is simple, we just need to add one to ‘score’. Yeah, let’s try. So after printing the congratulation message, let’s type in <score+1>. And we need to do this for all three questions. Cool!
* When the quiz completes, we also let the user know his/her final score. This is simple, we just call the ‘print’ function, and pass two arguments to it, the first one is a string ‘Your score is:’ and the second argument is the ‘score’ variable. 
* TEST. So let’s test this. This time, let me be an animal expert and answer all three questions correctly. So I’m expecting my score to be three, right? Make sense? Let’s see. One, two, three. Wait…it says “Your score is 0”? Why? Why is that not three? I clearly see all three congratulation messages! What went wrong here?
* Ok, does anyone still remember how we change the value of a variable? Yes! We use assignment again. Let’s go to the shell. Let me create a variable ‘score’ and assign an initial value 0. Now say I want to change it to 1. How do I do it? Yes, simply assign one to it this time. If I print ‘score’, you can clearly see the value one now. Now, what if I don’t want to assign a specific value to ‘score’, but just to increase its current value by one? Well, in the script, what we did was ‘score’ plus one, right? Now, hit return, and the result is two! Cool, so it did increase by one! Or is it? Now see what happen what I print ‘score’ again. It should show ‘2’ this time, right? Ouch! It still says ‘1’! What is going on here?
* Ok, previous it shows ‘2’ because the result of ‘score’ plus one is indeed ‘2’, no problem with that! But let me ask you a question: have we ever stored this new result ‘2’ back into variable ‘score’? Have we? Clearly No! Why do I know that? Because to store something into a variable, you need to use…? Yes! Assignment! Did we use any assignment here? No, not at all! So what should we do? Yes, we should assign the result of adding ‘score’ and one back to the variable ‘score’! So what we really need is <score = score  + 1> and hit return. This time, if we print ‘score’ again, the current value becomes two! Awesome!
* Ok, so this is why it is very important to understand that the ‘=’ symbol in Python does not mean equality as it is the case in maths. Because there is no way that ‘score’ can be equal to ‘score+ 1’ in math. A number can never be equal to itself plus one. Fortunately, in Python, the ‘=’ symbol means assignment. So what this says is, take whatever value that is in ‘score’ right now, which is one, add one to it, and finally assign this result two back to variable ‘score’. And after this, ‘score’ has a new value two. How cool is that!
* Ok, now back to our script, we can now understand why this is not working. Every time a question is answered correctly, we add one to the current ‘score’, nothing wrong with that. But what is wrong is that, we did not store the new result back to the ‘score’ variable. That’s why we are no seeing ‘score’ become three at the end. So knowing what the problem is, the solution is pretty simple, all we need to do is just assign the result of this adding one back to variable ‘score’. And we need to do this for all three questions. 
* Test. Now if I answer all three questions correctly, the final score becomes three. Just to make sure that ‘score’ is not increased for an incorrect answer, let me type the wrong answer for the second question and the final score become two this time. Perfect! So to change the value of a variable, simply adding a number to it is not enough, you need to remember to assign the new result back to the variable.  |  |
| User defined function (definition) | * OK, so at the point, our program is pretty much done:  we have a animal quiz that asks us three questions, and based on our answer, it shows us the final score at the end. Pretty cool, huh? Of course, you can change the question to make it easier or harder and take it to you friends and families to test their knowledge. You are not even limited to animal quiz, you can do all sorts of quiz, it can be about space, about plants, anything you can think of. So we can call it a day and finish with today’s lesson.
* But, you guys are some of the best programmers or coders in the world, right? And the top coders always try their best to make their code as perfect as they can, they are not going to be satisficed with code that is just Okish. And the code we have here is far from perfect! Why? Well, if you are brave enough, let’s take a deep dive!
* Let me give you a small challenge first, what if I want to change the congratulation message to something like “Awesome! You are such a genius!” Well, I know what you are thinking: how can this be a challenge? I just need to go to each ‘print’ function call here, and change the string to “Awesome! You are such a genius!” Yes, you are absolutely right, these are all the three places you need to change. Good job! Now, what if I want to change the Oops message to “Ouch! You got it wrong and it should be XYZ”. You might be thinking: ok, this is boring, but I will just go and change these three print function call, and job done. Cool, now what if I want to increase the score by 2 instead of 1 for each correct answer. Ok, same thing, go the three assignments and change the number from 1 to 2. What if I want to change the congratulation message again to something else? And what if …. ok ok ok, I know you are probably getting a bit annoyed by now. Why? Because for each change I want you to make, you have to go to code for each question and change it. It’s not too bad for three questions, but what happen if this is a serious big quiz with maybe 10 or even 100 questions? Do you really want to make a small change 100 times each time I ask you? Can you see the problem here? 
* But more importantly, what causes this problem? Why a simple request such as changing a message requires you to go to 3 or maybe100 difference places to make it happen? Let’s recall how we create the code for each question, the first one, we type it in line by line, right? But for the second and third one, what did we do? Yes, we copy and paste code and make some small modifications. Why did we copy and paste? Well, because the code for each question look almost the same! And because of that, a change we make to one is almost certainly going to be needed for the others! That’s why we are in trouble!
* To solve this problem, let’s briefly leave the world of Python and back to the real world. Say you are a baker who is famous for your delicious bread. And a lot of people want to know how you make them. So one day someone comes to you and asks for the recipe. Being a helpful and nice person, you say “Ok, it’s pretty simple,
step 1 - find a big bow
step 2 - add some flour
step 3 - add some sugar
step 4 - add one egg
step 5 - add some butter
step 6 - add some water
step 7 - mix them all up
step 8 - put the dough into oven for 10 mins
and then you have a delicious bread!”
Ok, that’s good. But then half an hour later, another person come to you and ask for the same question. So here it go again “step 1 - find a big bow, step 2 - add some flour and blah blah blah” Now think about  this, what if every half an hour or so, someone will come to you and ask for the recipe. So you need to repeat the steps again and again. And imagine what would happen if the recipe changes a little bit, for example, instead of adding one egg, you need to add two eggs this time. And all the previous people are coming back to ask you again for the new recipe. I wonder how much time you got left to actually make some bread! So finally, you have had enough and decide to make a change! You say to yourself:  “Ok, I’m gonna write the recipe down on a piece of paper and stick it my front door. Whoever comes next time, I’m just gonna ask him/her to go and check that piece of paper and follow the steps there!” What is brilliant idea! No one is gong to bother you again! 
* Ok, back to world of Python. This ‘if…else…’ statement is basically checking the user’s answer and print an appropriate message accordingly. All three ‘if…else…’ statements are almost the same. Yes there are some small differences, but let’s not worry about them for now. So this is like repeatedly telling the same recipe to different people again and again. Now, can we also put this on a piece of paper so that we can just tell whoever comes over to go and follow the steps on that paper instead? 
* Yes, there is a way to do it in Python and we have actually come across that before! Guess what that is? Yes, it is the functions. Functions? You mean like ‘print’ or ‘input’? How are they going to help here? Well, I do mean functions, but not those built-in ones we have been using so far! Remember, when we learnt functions like ‘print’ and ‘input’, I mentioned that they are called ‘built-in’ functions because they come with Python. You can just call them to do things for you without any extra work. Ok, here is time to introduce another type of functions, called ‘user-defined’ functions. On the one hand, they are still functions, meaning they can also do work for you and all you need is to call them. But on the other hand, they are defined by users. ‘Define’ here means “to create” and ‘User’ here means YOU, the programmer or coder who create the functions. So together, ‘user-defined’ functions are those created by you yourself, the programmer. This means you have to do the extra work to create those functions before they can be called and do work for you; but the good news is that you have the powerful to decide what those functions do and how they do it. So such functions are like that piece of paper where we can put the same recipe, so that different people can just look at that instead of having us telling them again and again.
* Ok, enough talking and let’s see what this means to our code. We have already identified the ‘if…else…’ statement as the repeating recipe, so let’s move it to a piece of paper or, in Python terms, a user-defined function. So the first step is to create or define such a function. Let’s start from an empty line here. To define a function, we always start with the word ‘def’, which is short for ‘define’. As you can see, ‘def’ has the same color as the word ‘if’ and ‘else’. This means it is also a keyword in Python. Next we need to type in the name of the function. This is like naming your recipe to something like ‘Wonder Bread’. So if someone asks you about the recipe, you can tell them to go and checkout the one called ‘Wonder Bread’. For our function, we always try to give it a name that tells people what it does. Since the code we want to move to this function is for checking the user’s answer, so let’s just call it “checkanswer”.  Type that in. But here are some rules about function names: first all letters of a function name should be in lower case. There is nothing wrong by having upper cases. Your program would still work and Python won’t complain a thing. It’s just a convention that most people follow, so I will do the same there. Second, if the function name has more than one word, we should separate those words by using the ‘_’. Again, your program would still work if you don’t do that, it’s just another convention to follow. So the final function name is “check_answer”. Next, just like calling a function, we also need to add a pair of brackets after the function name when defining one. Remember in the ‘if…else…’ statement, we add a “:” after the “if” statement and the “else” statement. Does anyone still remember what that “:” means? Yes, it means all the code that are indented next belong to the “if” statement or the “else” statement. When defining a function, we also want to have some code that belong to this function, right? So we also need to add a “:” after the brackets. This means all code that are indented next belong to this function. What code do want to add to this function? Yes, this “if…else…” statement. Let’s copy that and paste it here. Make sure that an indentation is added to each line of this “if…else…” statement. Ok, that’s it, we have created or defined a function. As you can see, for such user-defined function, we get to decide what its name is and what kind of work it should do. Most often, this whole thing here is called a “function definition”. 
* Now, we have the recipe on a piece of paper showing all the steps. Next, it’s time to tell people to go and check it out whenever they need to make bread. In Python, it just means calling this “check_answer” function. So let’s see. For the first question, since we already have a function that checks the answer, we no long need this “if…else…” statement here. Instead, we can just call function ‘check_answer’. And as before, always add a pair of brackets when calling any function. 
* Test. Ok, let’s run this and see if it works. Type in “cheetah” and… Oh no, it does not work! We have a very strange error:  “UnboundLocalError: local variable ‘score’ referenced before assignment”. And it seems to be complaining about the line <score = score + 1> in the function definition. Ok, you might be very confused now: we do not have this error before defining the “check_answer” function. We have only moved the “if…else…” statement inside this function without changing any code, why all of a sudden we are having this error now? Ok, before explaining the reason behind it, we need to talk “local” and “global” variables. |  |
| Local/Global Variables | * If you have learnt Scratch before, you know that when creating a variable, there are two options, “For all Sprites” and “For this sprite only”. The first option creates a “global variable”, meaning all sprites can access it. The second option creates a “local variable”, so only the current sprite can access it. So simply put, global variables can be accessed by more parts of the program than local variables.
* Since different programming languages usually share common concepts, variables can also be global or local in Python. But Python does not have sprites, so what does the “global” and “local” here mean then? So far, there is one important thing about variable that I have been avoiding, that is WHERE do you create variables?
* Now, think of the entire Python program as a house. A house has public area that are shared by everybody, such as the living room and the dining room. It also has private area such as your bedroom. In a python program, things such as the ‘if…else…’ statements and user-defined functions are like the private bedrooms; and anywhere outside of them are like the public living room. Variables are like the different items in the house, some of them are in the living room, such as TV, that everybody can use and watch, others are in the bedroom, such as your XBox console that only you can play. Running Python code is a bit like wondering in the house, some times you are in the living room watching TV and some times you are in your own bedroom play XBox.
* Ok, enough of analogy and back to Python. The private area in Python include all the statements, such “if…else…” and user-defined functions. Of course, there are more, but these are the only two we have learnt so far so let’s focus on them for now. In python, it is called “local scope”: “local” means private and “scope” means a code region. So they together mean private code region. In contrary, the public area in Python are anywhere outside of any statements or user-defined functions. It is called “global scope”: “global” here means public and they together mean public code region.
* Like items can be placed in either private or public area in a house, a variable can be created in either “local scope” or “global scope”. The ones created in “local scope” are called “local variables” and those created in “global scope” are called “global variables”. All the variables we created so far are in the global scope so they are global variables. We will see some local variables pretty soon. Like when you are in the living room, you cannot play the XBox in your bedroom, when you are in the global scope, you cannot see or use the variables created inside a local scope. 

* Let’s see some actual code to make sense of all these. In this lesson’s folder, there is a .py file called “global_vs_local.py” that we will be using to show the differences between local and global variables. It has only one line of code: a variable called ‘x’ is created and assigned value 10. Can you tell me if this is a ‘local’ or ‘global’ variable? Yes, it’s global because it is not created inside any statement or function definition. Next, let me print ‘x’. Do you think this line of code in local or global scope? Yes, it is not inside any statement or function either, so it is also in global scope. Since the variable is in global scope and the code that uses it is also in global scope, we should be fine here. Remember, if you are in the living room, you can definitely use and watch the TV there. In fact, all the code we have seen so far are like these. Just to double check, let’s run it and number ‘10’ is printed. Cool!
* Now, based on what we have just learnt about user-defined function, let’s create one. So, ‘def’, and I would like to name it ‘go_to_bedroom’ and then empty brackets and “:”. The next line starts with an indentation so we are now inside this function. What I want it to do is pretty simple, I create another variable ‘y’ and assign 20 to it. So what kind of variable is this? Global or local? Yes, it’s local this time because it is created inside a function. After that, I just print ‘y’ and this should be fine because our print is also inside the function. Finally outside of this function, I’m gonna call it. Run the program, and this time we see 10 followed by 20. 10 is from the ‘print’ function call in the global scope and 20 is from the ‘print’ function call inside the function. Now, calling this function is like going into your bedroom, and the variable ‘y’ inside is like your XBox. When you are in the bedroom, you can play the XBox and when are in the function, we can print variable ‘y’. Ok, so far so good?
* Now let’s try something else. What if I move this “print(y)” outside of the function and place it after the function call? What do you think is going to happen? Not sure? Let’s run it! Oops! Looks like there is an error with this ‘print(y)’. Let’s take a look at the error message, it says: NameError: name ‘y’ is not defined? Python basically complains that variable ‘y’ has not been created yet: how can you print something that does not exist? But you might be thinking: I have created ‘y’! Look! It’s inside function ‘go_to_bedroom’! Now, let me ask you something, is this <print(y)> in local or global scope? Yes, it’s in global scope because it’s not inside any statement or function. It’s now as if you are in the living room and try to play XBox in the bedroom, do you think it would work? Of course not! Code in the global scope can never access variables created in local scope. This is another very important rule in Python. But funny enough, the opposite of this rule is also true. That is code in the local scope can always access variables created in the global scope. Ok, this is like saying even when you are in the bedroom, you can always watch the TV in the living room. This is probably not possible in real life, but hey, we are in Python, so nothing is impossible! To show you that,  let’s move both <print(y)> and  <print(x)> back inside the function. So <print(x)> is now in local scope, trying to print a variable created in the global scope and let’s see if that works. Run the program and there you go, we have 20 followed by 10, which is the value of variable ‘x’. Perfect!

* Ok, let me now add a <print(x)> in the global scope just after the function call. Run the program, and we see 20,10 and 10. So the first two numbers 20 and 10 are from the two print function calls inside the ‘go_to_bedroom’ function and the final 10 is from the print here. Everyone ok with that? Cool. Ok, now watch carefully what I’m going to do: I will assign variable ‘x’ with value 30 in the function definition just before <print(x)>. Now, do you want to guess what the output is going to be this time? Ok, somebody says 20, 30, and 30? Why? Ok, so because ‘x’ has been assigned 30 in the function, so when it is printed here at the end, it should has value 30. Sounds reasonable, let’s run the program to find out!
* Oops…the actual output is 20, 30, and 10! So the last ‘print’ prints 10 instead of 30. But we have clearly assigned a new value 30 to ‘x’ before that, how come the value is still 10? That’s bizarre! Ok, this needs some explanation. Previously in the global scope, if it is the first time we assign a value to a variable, we define or create that variable, right? We already know this. Now, it is the same in local scope, meaning the first time you assign a value to a variable in that scope, you define or create that variable in the local scope. Let’s take a look at this assignment in the function definition. Is this the first time we assign a value to variable ‘x’ in this function? Yes, it is, there is no other assignment before that in this scope. So, this might surprise you, what we are doing here is creating a new local variable that just happens to have the same name ‘x’ in the local scope. It is NOT the same variable ‘x’ in the global scope. So even though we assign a new value 30 to this local variable ‘x’ here, it does not change the value of the global variable ‘x’ because they are two completely different things. Like two different boxes with the same label ‘x’, putting an apple in one box does not change what is inside the other box. Before we add this new assignment, this ‘print’ is printing the global variable ‘x’, but since there is a new local variable with the same name as the global variable now, the ‘x’ in this print is now referring to this local one instead of the global one. And because value of the global variable ‘x’ has not been changed, it still has 10 and that’s what’s been printed at the end of the program.
* Now, you might say: OK, this is good to know. But what if I do want to assign 30 to the global variable ‘x’ and I don’t mean to create a new local variable that also has the name ‘x’? How can I do that? Well, the creator of Python has thought about the problem and came up with this solution: if have a variable in the global scope and want to assign it a new value in the local scope, all you need to do is to tell Python in the local scope that this is a global variable and please do not create a new local variable for me. And the way to tell python is to add the keyword ‘global’ followed by the name of the global variable ‘x’ at the beginning of the function definition. This is also sometime called “declaring a global variable”. If you do that, then when Python run this assignment, it knows that what you want to do is to assign 30 to the global variable ‘x’, and not trying to create a new local variable whose name is also ‘x’. Now, if we run the program again, the output becomes 20, 30, and 30. This is because we have changed the value in the global variable when calling the ‘go_to_bedroom’ function. 

* So this is a pretty long detour from our program about local and global variables, but understand this is very important. So, before we get back to our main track, let’s me just summarize the key points here:
- There are two scopes in Python program: local and global. Local scope is any code region inside a statement or a function definition whereas global scope is anywhere outside of that.
- Variables created in local and global scope are called ‘local variables’ and ‘global variables’ respectively.
- Code in global scope and only access variables created in the global scope. Code in a local scope can access variables created in the same local scope or variables created in the global scope.
- To assign a new value to a global variable in a local scope, you need to declare the variable as global at the beginning of the local scope using the ‘global’ keyword. |  |
| User defined function (parameter) | * Ok, back to our main Animal Quiz program. Just to recap, we created a user-defined function ‘check_answer’ and call it after getting the user’s answer for the first question to see if it is correct or not. But unfortunately, when we run the program, we get this “UnboundLocalError”. Now since we have a pretty good understand of what local and global variables are, we can further investigate this error.
* The error says: “UnboundLocalError: local variable ‘score’ referenced before assignment”. And it seems to be complaining about the line <score = score + 1> in the function definition. Let’s try to understand this bit by bit. First, it says “local variable ‘score’”, but wait, we can clearly see that ‘score’ is created here, in the global scope. Then why python thinks it is a local variable? Well, remember, if the first time you assign a value to a variable in a local scope, this is the same as creating a local variable in the current scope. So inside the ‘check_answer’ function, is this the first time we assign some value to variable ‘score’? Yes, definitely! So what does this assignment do? It creates a new local variable that has the same name as the global ‘score’ variable, make sense?  Cool, this explains the “local variable” part in the error message. Next, the error message says “referenced before assignment”. We already know that “assignment” is, but what does “referenced” mean? Well, don’t be scared by the word, it simply means “used”. So the whole message basically says “You are using a local variable ‘score’ before it is assigned”. Where do we use this local variable ‘score’? Yes, on the right hand side of the assignment. Remember, we take whatever value that is in ‘score’ and add one to it right? It was ok before we create the ‘check_answer’ function because it was referring to the global variable ‘score’. But since we have moved it inside a function, and as we have discussed above, ‘score’ is now a new local variable inside the function, then this ‘score’ is also referring to the new local variable. So can you see the problem now? The assignment is creating a new local variable ‘score’, but we try to use the value of this ‘local’ variable before it is even created? What value is it storing? I don’t know, you don’t know and nobody knows! So, you are trying to use a variable before it’s even been created, no wonder why Python is not happy with that! 
* OK, the problem really is that python thinks variable ‘score’ is a local one inside function ‘check_answer’ whereas we programmer actually mean the global ‘score’ variable instead. So I think you probably already know that the solution should be. Anyone? Yes, the solution is to tell Python that this ‘score’ in the function should refer to the global one, and we are interested in creating another local variable that has the same name ‘score’! What should we do? Yes, we declare ‘score’ as global at the beginning of the function! 
* Test. Now let’s run the program again. Type in ‘cheetah’, and this time no error, let’s finish the other two questions and our final score is three. Nice!
* Now, since we have the recipe written on a piece of paper now, we can point everybody to that! For the second and third questions, let’s replace the “if…else…” statement by a call to function ‘check_answer’ just like the first question.
* Test. Let’s run the program again. First question, type in cheetah, and second question … Oh wait, why is the second question the same as the first one? How about the thrid one? It’s also the same as the first question? What is going on here? 
* Well, remember, we replace all three “if…else…” statements with calls to function “check_answer”, right? But if you look carefully at the function definition, what does it do? Well, it checks if ‘answer’ is “cheetah” first, if it is, a congratulation message is printed, if not, it tells you the answer is “cheetah”. Do you notice that it’s always ‘cheetah’ and never other animals like the blue whale and the elephant? So essentially, we made a mistake when creating the function, we put the ‘if…else…’ answer checking code for the first question into the function definition and call it for the second and third questions, of course, that won’t work.
* So how do you think we should solve this problem? Good, these are all very good suggestion. So essentially, we want function ‘check_answer’ to be a bit more flexible, meaning if the question is about cheetah, then the function should compare answer with string ‘cheetah’ and give this as the answer if user got it wrong, if the question is about blue whale, then it should compare answer with string ‘blue whale’ and give this as the correct answer if user got it wrong. Similarly for the third question. 
* So we have been using the built-in ‘print’ function many times, do you think it is flexible? Yes, without a doubt, because we can ask it to print anything! How is that possible? Because we can pass different strings as arguments to print exactly what we want. This is inspiring! Is there any chance that we can make our ‘check_answer’ function more flexible by using arguments too? Probably! Arguments are not exclusive to built-in functions, there is no reason why we can’t pass arguments to user-defined functions too! |  |
| Passing arguments to user defined function (detour) | * To understand how arguments can be used with user-defined functions, we need to take a small detour again. There is another python file in the lesson’s folder called ‘parameters.py’.
* If you open the file, I have already prepared some code for you. It’s pretty simple, we have a user-defined function called ‘add’. Inside it, we create two number variables ‘num1’ and ‘num2’. We assign 10 to ‘num1’ and 7 to ‘num2’. Then print both numbers and finally their sum. Ok, nothing crazy here. At the end, we just call function ‘add’. Run it, and the program prints both numbers and the sum 17. Ok, all good? Cool!
* Right, can anyone see the biggest program with function ‘add’ here? Yes, it doesn’t matter where you call this function or how many times you call it, it can only do 10 plus 7, always! That can’t be very useful, can it? What if I want to add 16 and 90, what if I want to add 485 and 1094? Sorry, can’t do it! See how inflexible it is? This function can do one and only one thing!
* Would it be nice if, every time we call this function, we get to decide what the two numbers are. For example, if I want to add 16 and 90, just tell it “go and add 16 and 90”. If this is possible, then function ‘add’ can become way more useful and be used to add all kinds of numbers! That would be really cool!
* So as I mentioned before, the build-in ‘print’ function is a pretty cool one because you can ask it to print anything you want. How do it do that? Yes, it allows you to pass different strings as arguments. So, can we do the same here? Can we pass arguments to our user-defined function? Let’s give it a try!
* Say I want to add 16 and 90, let’s pass them to the function call. Ok, we already know that when you pass more than one argument, you use comma to separate them out, so let’s me type in 16 and comma and finally 90 inside the brackets of the function call. Looks good! We are asking ‘add’ to add 16 and 90.
*  Let’s run it! Oops, it’s not working! We have a ‘TypeError’. Ok, don’t worry if you don’t know what ‘TypeError’ is, the more important thing is this detailed error description here, which says “add() takes 0 positional arguments but 2 were given”. What does that mean? It sounds like Python saying “I don’t want to take any arguments but you gave me two, so I’m gonna throw up!”. It’s a bit like my mum when I was little, sometime I’m not hungry, but she just keeps asking me to eat more food, so, you know how it feels! But why doesn’t Python think function “add” take any arguments? Well, because you have not told it to do so! What does that mean? Ok, when we define a function, we add code to tell it what to do, right? For this ‘add’ function, we ask it to do addition and print out the sum. But you can not only tell a function what to do, you can also tell it what to take in to do the work. It’s like baking a cake, you can have the best recipe in the world, but still can’t make one if you don’t have the ingredients! Unfortunately, we only have the recipe here, that’s the code, but not the ingredients. So what should the ingredients be? In the case of a function definition, the ingredients are called “parameters”. A ‘parameter’? What is that? Ok, it is just a variable inside the brackets of a function definition to accept an argument passed in when the function is called, like feeding the recipe with ingredients. Unfortunately, we only have a pair of empty brackets in the function definition right now, meaning “I’m going to take in arguments or ingredients”. That’s why Python complains when we pass ‘add’ two number when in fact it is not expecting any! 
* This is when parameters come to the rescue! Because we pass two numbers to ‘add’ when calling it, we also need to add two parameters to the function definition accordingly. This is pretty simple. A parameter is kind of like a variable, it needs a name. Let’s call them ‘num1’ and ‘num2’ and just add them inside the brackets, separated by a comma. Unlike a variable, you don’t need to assign a value to a parameter. So when does it get its value? Well it get its value when you call it. For example, here we call it with numbers 16 and 90. So what values do you think parameter ‘num1’ and ‘num2’ are going to have? Yes, ‘num1’ is going to have value 16 and ‘num2’ is going to have value 90. Looks good! Let’s run this!
* Test. Ouch! Why are we still having 10 and 7 here? Yes, it’s because of these two assignment in the functions. Previously, before adding parameters, these are two local variables created inside the function. Now, after we have added parameters ‘num1’ and ‘num2’, these two becomes assignments that change the value of these two parameters. So what happen was, when the function is call, ‘num1’ and ‘num2’ are assigned number 16 and 90 initially. Then when the function runs, value in ‘num1’ was changed to 10 because of this assignment, and value in ‘num2’ was changed to 7 because of this assignment. So in the end, we are still computing 10 plus 7. So the solution is simple, because we already have the two numbers passed in as parameters, we no longer need to create the local variables ‘num1’ and ‘num2’ here. So let’s just remove these two lines. Run again, and Yes, this time it’s 16 plus 90 what is 106. Cool!
* Also note that, when you call a function, the order in which you pass the arguments matters. Right now, the first number is 16 and the second number is 90, as can be seen from the output. But if I change the order, so that 90 is passed before 16, and run it again, this time, the first number becomes 90 and the second number becomes 16. As you can see, the first argument is always assigned to the first parameter, the second argument to the second parameters, and so on and so forth. 
* OK, this is one way and the most common way to pass arguments to a function. But there is another way that can be useful sometimes, and it is called “named arguments”. So far, when deciding which parameter gets assigned by which argument, we always assume some kind of order. As this examples shows, the first parameter gets assigned the first argument and the second parameter gets assigned the second argument. What “named arguments” allows you to do is to explicitly assign an argument to a parameter without considering the order at all. What does that mean? Let’s take a look at the code. Right now, parameter ‘num1’ gets argument 90, and parameter “num2” gets argument 16, right? But what we can also do is that, when passing the arguments, we can make this more explicit by typing <num1=90> and <num2=16>. Now, let’s run this program. The result is the same. But watch, with “named arguments”, the order does not matter any more, so I can also switch the order between them, so it now looks as if we pass 16 first and then 90. Without “named arguments”, “num1” would be 16 and “num2” would be 90. But with “name arguments”, because we explicitly assign 16 to “num2” and 90 to “num1”, to “num1” would still have value 90 and “num2” would still have value 16. We can run this program to confirm that. Yep, as you can see, the first number is still 90 and the second number is still 16. The order in which we pass those two arguments are not important any more when using “named arguments”. Ok, you might be wondering, why do we need this? Is it just for fun to change the order the arguments? Actually, “named arguments” can be pretty useful in some cases, but I’m not gonna go into the detailed examples here and we will see this being used later in the course. Here, I just want you to know that there is a different way to pass arguments.
* OK, once we added parameters to the ‘add’ function, it becomes a lot more useful now. We can add any two numbers together by just passing them as arguments to ‘add’ when we call it. For example, I can add 45 and 78, and I can add …. |  |
| User defined function (parameter) | * Ok, now we understand what function parameter is and see how it can be used to make a user-defined function more flexible and useful. Let’s get back the animal quiz one more time.
* Like the ‘add’ function, we are facing a similar problem here: how can we make ‘check_answer’ more flexible so that it can be used when checking the answer for different questions. In the case of ‘add’ function, we use parameters so that it can add different numbers. For ‘check_answer’, maybe we can use parameter so that it can check the user’s answer with different correct answers? So the first question, it needs to check against ‘cheetah’, for the second question, it needs to check against ‘blue whale’ and for the final question, it needs to check against ‘elephant’. So it looks like we need to pass the correct answer as an argument to this function. Let’s do it!
* First, let’s change the function definition so that it accepts argument now. As we have already learnt, this can be done by adding a parameter. For this function, we want to accept a correct answer to check against, so let’s named the parameter ‘correct_answer’. Now, we have a parameter, the next step is to use it in the function code. Where do we need it? Well, the first place is in the ‘if’ statement here, this time, we are not comparing the user’s answer with string “cheetah”, instead we compare it with the parameter ‘correct_answer’ instead. Is there anywhere else where we need this parameter? Yes, when the user gives a wrong answer, we need to let him/her know what the correct one is, so in the ‘else’ part where we print the Oops message, we should replace this cheetah here by the parameter ‘correct_answer’ again! Ok, all good? Shall we run it?
* Test. Oops, error! It’s a ‘TypeError’ again, but the detailed message is different this time. It says “check_answer() missing 1 required positional argument ‘correct_answer’”. Hmmm.. looks like it’s saying “function check_answer() is expecting one argument but none has been given!” And it also tells you which line has gone wrong. So looks like the call the ‘check_answer’ for the first question is the problem. Fortunately, the solution is pretty simple and straightforward: Remember we have added a parameter to ‘check_answer’ function definition right? So when calling it, we need to pass an argument! For the first question, the correct answer is ‘cheetah’, so let’s pass string ‘cheetah’ to the function call. 
* Test. Run the program, type in ‘cheetah’, this time no error and we on to the second question. Nice! 
* Ok, so it is time to really show the benefit of using user-defined function! Because we already have ‘check_answer’ function for checking answer, there is no reason why it can only be used for the first question. In fact, the whole point of defining this function is so that it can be used again and again for other questions. For the second and third questions, we can safely delete both ‘if…else…’ statements and call the function ‘check_answer’ instead. All we need to be careful is to pass the appropriate correct answer as argument. For the second question, the correct answer is “blue whale”, so let’s pass that in; for the third question, the correct answer is “elephant”, so let’s pass that in!
* Ok, so we are finally there, our Animal Quiz program is not just completed, but also have the best code we can! Wonderful! Let’s test it for a last time!
* Test. Run, type in ….. |  |
|  |  |  |

### Exercises

- Play with other string methods
- How to decrease the value of a variable