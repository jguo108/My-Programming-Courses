# 3 Secret Message

### Reference

### Code

[https://github.com/jguo108/My-Programming-Courses/blob/main/Python/Level0/Basics/3 Secret Message/main.py](https://github.com/jguo108/My-Programming-Courses/blob/main/Python/Level0/Basics/3%20Secret%20Message/main.py)

### Key Points

- String
    - String as a sequence of ordered characters
    - String indexing ([])
    - String search (’find’)
    - upper/lower/isupper/isalpha methods
    - Empty string
    - Update string using ‘+=’
- Operator
    - modulo operator %
- Conditional
    - ‘if … elif .. else’
- Loop
    - for loop
    - Two different ways to use for loop to iterate all characters of a string
- User-defined function
    - Reduce code duplication
    - Return value from function
- Built-in function
    - len
- Programming general
    - Handle errors and make code more robust
    - Local variable hide global variable with the same name

| Steps | Notes |
| --- | --- |
| Introduction | * Ok, welcome to this new lesson! Today, we are going to create some secret messages. And only those who holds a secret key will be able to reveal the truth behind it!
* Back in the early days, I mean as early as the Roman times, people have always been thinking how to hide their message before it is sent so that even if someone else sees it, he/she would have absolutely no idea what it is about. This is very important, because as we know, a lot of wars were fought at that time. So if a message, such as “attack tonight”, is intercepted by the enemy, you don’t want them to be able read it. That’s why you need to hide it before it is sent and only reveal it when received by one of your guys. So the process of hiding and revealing a message is called ‘cipher’. Hiding a message is called ‘encryption’ and revealing a message is called ‘decryption’.
* Cipher is still super important in today’s world even we don’t have that many wars these days. This is because we are using electronic devices such as computers and phones to send messages all the time, and there are hackers out there, hiding in the dark, waiting to intercept those messages and steal our personal information. So we still need cipher to protect ourselves from being exposed to those hackers.
* Ok, enough of history and let’s start today’s lesson!     |
| Caser Cipher | * There have been many different ciphers throughout human history, some are very simple but give limited protection, some are very complicated and is almost impossible to break. In our lesson, we are going to look at a pretty simple but fun one, called ‘Caeser Cipher’. As you can probably guess from the word ‘Caeser’, it was invented in the Roman Times and is one of the oldest ciphers known in history. Let’s first take a look at how it works.
* To encrypt a message, this cipher replaces each letter in a word with a different one. For example, the word “hello” becomes “khoor” after encryption. See? Just by looking at “khoor”, you would have no idea that it was actually the word “hello”. We have successfully hide the actual message from our enemy! But here you might be asking: how do I know what a letter should be replace with? How do I know that “h” should be replaced with “k”? 
* To answer that, let’s first look at the English alphabet here. This alphabet is a little bit unusual, all 26 letters are arranged in a circle. This is what we are going to use to find out what a letter should be encrypted to. So how does the letter “h” in word “hello” gets encrypted to letter “k”? Let’s first find where “h” is in the circle, it is here. Then, here is the important step, think of this circle as a clock and from where “h” is, move 3 letters clockwise, so, “i”, “j” and finally end up at “k”. Now this letter “k” is what we are going to use to replace “h”. Simple huh? Ok, you might be asking, why three? Why not four, five? So you don’t have to use three, four is fine and five is fine too. In fact, it’s ok as long as you don’t use 26 or multiples of 26. Can anyone guess why? Yes, because there are 26 letters in the alphabet, so if you choose 26 or any number that is a multiple of 26, you end up where you start from, so “h” is encrypted as “h”, and this is silly! OK, the number of steps you choose to move is called a “secret key”. In my case, since I choose to move 3 steps clockwise, so my secret key is three. It’s important to keep your key secret and never let your enemy know about it. Do you know why? 
* Ok, let me ask a different question, we have encrypted the word “hello” to “khoor”. And we send this encrypted word to our friend. Once our friend gets the message, how can he/she know what the original message was? He/she needs to reveal it or decrypt it. But how? Anyone? Yes, our friend can just do the opposite of what we did for encryption: so start from the letter “k” in the encrypted word, then move 3 letters counter-clockwise, so “j”, “i” and finally end up at “h”. Now this letter “h” is what the decrypted letter is. And if our friend do the same for the rest of the letters, he/she will eventually get the original word “hello” back. So the most important piece of information our friend needs to know to decrypt the message is the secret key. Without knowing the secret key, he/she would have no idea how many steps to move counter-clockwise, and therefore not able to decrypt the message.
* And now we can answer our question earlier, why we should never let an enemy know about our secret key? Yes, because if the enemies know it, then it will become a piece of cake for them to decrypt our message! And we are hiding nothing from them! 
* Ok, so this completes our brief but interesting introduction to the Caeser Cipher. But it’s all on paper and we have to manually encrypt and decrypt messages each time. Wouldn’t it be nice if we can let a Python program to do this for us automatically? That would be very cool! And that’s what we are going to achieve in today’s lesson, let’s get right in! |
| Input message and key | * First, let’s ask the user to input a message and a key. These are the two most important pieces of information we need. So we have seen this a million times by now, create a variable called ‘message’ and assign the return value of ‘input’ function to it. Because this is asking for the input message, let’s give ‘input’ an argument string “Enter a message: ”. And next, we need the secret key. So create another variable ‘key’ and also assign the return value of ‘input’ function to it. This time, the string argument is “Enter a key: ”. Ok, remember ‘input’ always returns a string but the key should be an integer number instead. So how can we get an integer from a string? Yes, in the Math Genius lesson, we have seen that you can use the ‘int’ conversion function to convert a string into an integer. So let call that with return value of ‘input’ before it is assigned to variable ‘key’. Just to make sure things are working correctly, let’s print the message and the key at the end. Ok, let’s test this.
* Test. Run the program and type in “hello” as the message and “3” as the key. Then we see the message and the key being printed on the screen. Looks like everything is fine and we can move on! |
| Encryption - String indexing | * Now we have the message and the key, let’s encrypt the message first. As we have discussed in the introduction, we need to look at each letter of the message one by one and convert it into a different letter. There are two problems we need to solve here: the first one is how to go through the letters in the message one by one and the second problem is how to find the right replacement for each letter. Let’s tackle them one by one.
* When we introduced string for the very first time, I said that a string is just a sequence of individual characters. Well, I use the word “character” instead of “letter” because string can contain special symbols such as “@”, “#” or “$” and it does not have to be something in the alphabet. But for our message, we assume that every character in it is a letter. Now, all characters in a string are in some order, for example, in string “hello”, letter “h” comes first, letter “e” comes second and so on and so forth. And because of this order, given a position, we can immediately tell what character is at the position. For example, if I ask you what is the second letter in string “hello”, you can just start from the first letter, move one step forward and arrive at letter “e”. So the second letter is “e”. This is all clear and straightforward. But how can we do this in Python? How can I write code to get the second letter in this string and print it to the screen, for example?
* OK, time for some interactive fun stuffs. Let’s go to the shell! First, create a variable “message” and assign string “hello”. Type “message” and hit return to just confirm the value is “hello”. Ok Cool. Now, it’s the exciting bit, let’s see how to get each individual letter from the message. How about the first letter, now watch carefully what I do: type in the variable “message”, then a pair of SQUARE brackets, and finally inside the brackets, type 0. Yes, I know this syntax looks very strange so let me explain.
* We already know that all characters of a string are ordered from the first one to the last. So each character has a number associated with it. For example, the first character always has number 0, the second character has number 1, the third character has number 2, and so on and so forth. So as you can see, these numbers start from 0 and increases by 1 for each of the next character. And have a name for these numbers, it’s called ‘index’. 
* Can you think of something in your life that uses this word very often? Yes, in books! Quiet often, there is a section, normal at the end of the book, called the ‘index’. What does it have? Well, it contains all the most important words that appear throughout the book, usually in alphabetically order. So why do we need this? Well, the clever bit is that each word also has the numbers of the pages where you can find it. So can you guess what it is good for? Yes, it allows you to quickly find a certain word in the book so that you can read more about it. So the purpose of ‘index’ is to allow you to find things quickly, simple as that. 
* Now back to our code here. Like the index in the book, the index number in Python is also used to find things quickly. In this case, what are the things we want to find? Yes, we want to get each character in a string quickly. Because each character is now associated with an index number, like a word is associated with a page number in a book, we can now very quickly get each character from a string. And this is the way to do it, you first have the string or a variable that stores a string, then a pair of square brackets, and in those brackets, the index number of the letter you want to get. Because we want the first letter, so 0 is used here. Remember, the first letter of a string always starts from 0. This is the how you get any character from a string and it often called ‘indexing a string’. So let’s hit return and it prints character ‘h’. Note that ‘h’ is also in quotes, so it is also a string, it’s just a very short string with only one character. Now we can try to get the second character by type <message[1]> and hit return and ‘e’ is printed this time. Here, I have point out a mistake that beginners often make, the index number always starts from 0, so the first number has index 0 and the second number has index 1. People new to Python sometime would think that the first number has index 1 instead. This is probably how we human think, but computer sometimes thinks differently. So please keep that in mind! |
| Encryption - for loop (index based) | * Ok, so back to our script. Let’s remove these two print function calls. OK, with our knowledge about string indexing, let’s try to print the message one character by one character. 
* So the first character is <message[0]> and let’s print that. The second one is <message[1]> and print that as well. So let’s just copy and paste the code to print the third, and fourth and the last characters. Simply change the index number to 2, 3, and 4. 
* Test. Let’s run the program. Enter message “hello” and key “3”, and this time it prints each character one by one. Cool.
* Ok, remember in the last lesson Animal Quiz, we start defining and using user-defined function to check the answer because we find ourselves copying and pasting pretty much the same code many times, right? As it’s often the case in programming, whenever you find yourself copying and pasting code, you should think to yourself:  There must be a better way of doing this! This is because programmers are pretty lazy, and we want to do things the quick and easy way. Copying and pasting code again and again is not quick and easy! Further more, such code are often a lot harder to change and less flexible as we have already seen in the Animal Quiz lesson. And it’s the same here, what if I want to change the name of variable from “message” to “information”? Then you have to go through each of these lines and change the variable “message”. That’s a lot of work!
* And there is another problem, if I run the program again, this time, type in “awesome” as the message and the key is still 3, hit return. Ok, did you see the problem? Yes, the program still just prints the first 5 characters because we still just print characters from index 0 to 4. Ok, you might say, fine, let’s me just add two more prints at the end to print the sixth and the seventh characters. Right, this works fine, but what if I have an even longer message next time, do you want to do this again? So the problem is that, our code is not flexible at all, it cannot adapt to the actual message. 
* Ok, since our code is not perfect, it’s time for a change. Let’s address the first problem first. Could we make the code so that there is less copy and paste, and it’s easier to change, for example, the variable name. Let’s take a look at these five ‘print’s. They are doing the same thing again and again, that is to print a character from a string “message”. The only difference is that the actual character that is printed in different. Ok, with the knowledge from last lesson still fresh in you mind, I can see you jump out of your seat and shout: “I know what to do! We can use user-defined function!” Wow, I’m glad you actually said that! So let’s give it a try!
* OK, before adding this function, I would like to quickly talk about how people normally arrange all the different parts of their Python programs. Because you can have function definitions, variable definitions and some other code, a proper order makes a program more organized, and more importantly, easier to find stuffs you need. So here is the convention, normally, I would put all definitions of user-defined functions at the beginning of the file. This is then followed by all the global variables and finally, the rest of the code that uses the global variables and call those user-defined functions. Of course, you can arrange the code anyway you like, but just be consistent and make sure things are well organized. 
* Right, let’s go to the beginning of the file and define a new function. Because I want this function to print a single character, I will just name is “print_character”. So first the “def” keyword, always start with this when defining a function. Then the name “print” underscore and “character”. Next, a pair of empty brackets. And before finishing this line, don’t forget to add the “colon” to start the body of the function. Ok, what do we want to function to do? Yes, we want it to print a character! So let’s call ‘print’ and brackets. Now, we need to think about this: we want to print a character here, but where does that character some from? Well, it comes from the string variable “message” right? Now, can we do this, inside the brackets, let’t pass <message[0]> to it? Do you this is going to work? No, it’s not going to work! Why? Because it always print the first character of the string! What want the function to do is to print any character! What should we do then? Yes, we can use parameter to pass the character we want this function to print! We have seen how to use a parameter in last lesson, right? It’s pretty simple, we just add a parameter inside the brackets of the function definition, because it’s supposed to be a character, I will just name it “character”. Now, we have a parameter, we can just pass it to the ‘print’ function to print it out.
* Ok, the function definition is done, we can call it now! All we need to do is just replace all the calls to built-in function ‘print’ with calls to user-defined function “print_character”, and the rest stays the same, we still pass each individual character of the string to “print_character”. Let’s test this!
* Test. Run, type in hello and 3, and we get the same output as before! Cool.
* OK, I know some you might be a bit confused now and thinking: right, so we still have these five lines of code that look very similar, and if I want to change the name of variable “message”, I still need to do it five times here. In fact, things are getting a bit worse now, we have to type in more characters because the function name “print_character” is clearly longer than just ‘print’ and we have an extra user-defined function that dose not seem to do too much! If this is your observation, then great, I’m super pleased with the way you think! And yes, your are right! We still have the repetitive code here and the problem has not been solved! Absolutely! Then why do this? Well, I thought it is probably a good exercise to practice defining a function again! Don’t you think so? But more importantly, this function is only useless for now, and later in the lesson, we will see why it is needed. 
* Ok, having said all that, the problem remains, and we need to think of something else. Let’s take a closer look at these five lines again. They are almost the same except the index numbers. But those numbers are not some random ones, they are a sequence that starts from 0 and increases by one each time all the way to number 4. What if there is a way to say: “Hey Python, I’m a bit lazy, so please call function ‘print_character’ five times for me, the firsts time with index 0, the second time with index 1, the third time with index 2, the fourth time with index 3 and the fifth time with index 4”?
* Fortunately, there is something to save you lazy programmers here: it’s called “loop”. OK, when you think of the word ‘loop’, what comes up in your mind? For me, I can imagine something going round and round, like a Ferris Wheel, you start at the bottom, then it goes a full circle and back to the bottom again. Now if you have the money and time, you can take one more round, and another round, until you said: ok, that’s enough. So in Python, or actually any programming language, your code can also run in a loop. Previously, we mentioned that running a program can be like driving on the straight road when it runs the code line by line, top to bottom. And it can also be like arriving at a Y junction when you can take either path. This is the “if…else…” statement. Well, we are seeing the third type of road here, when you just drive round and round in a loop until you decide to leave it. In Python, we can repeat certain code round and round using a “for loop” statement. And each time round is called an “iteration”. 
* Ok, let’s see that this looks like in Python. Let me comment out all the ‘print_character’ function calls and try to do the same using a for loop. I’m typing in the code first and then explain what each part means. So first type in word “for”, as you can see, it has the same color as some of the keywords we have seen before such as “if” or “global”, so this is also a keyword in Python. Then a variable, I name this “i”, and since it’s a variable, you can call it whatever you like. After this, another keyword “in”, followed by a call to a built-in function “range”. We pass number “5” as the argument to function “range”. When this is all done, just like the “if” statement, we need to end it with a “:”, this means what comes next is inside this for loop statement. And what do we want to repeat here? Yes, we want to call the “print_character” function, so let’s type that in. Note that there is now an indentation before this function call, so it’s inside the for statement. For the argument, we get the character to print by using variable “i” as index for the string variable “message”.
* OK, if this is the first time you see something like this, it might look too complicated to understand. But don’t worry, let me break it down for you. First a “for” loop always starts with the keyword “for”, well, this is why it is called a “for loop” in the the first place. Then there is this “loop variable”. It’s a variable, meaning it can store different values. More importantly, it stores a different value for each iteration of the loop. But where are those different values coming from? This is what the rest of this “for loop” statement about. The keyword “in” essentially says: “ok, all the values for the loop variable is going to come from what is next”. And what is next? Well it’s the return value of a build-in function called “range”. Now, the “range” function here accepts one parameter “5”. So what is its return value? Well, its name kind of gives it a away: it returns a range of integer numbers that starts from 0 and goes all the way to 4. 4??? How do you know that? Well, remember the number “5” we pass to ‘range’, this argument sets the upper bound for the number range to be 5. So the maximum of the range must be less than 5, which is 4. Now this is something you need to be careful of, every time you call function “range” and pass it a number as the upper bound, the maximum number of the returned range is always one less than the upper bound. So “range” here return a number range that includes, 0, 1, 2, 3, and 4. And these are the numbers where the loop variable “i” gets its value from. So when this for loop is run, variable “i” has value 0 the first iteration, then 1 the next iteration, then 2 the third iteration and all the way to 4 in the final iteration. After that, the loop completes and we are out.
* Next, let’s look inside that loop. Any code here will be run in each iteration. In this case, we just have one line of code, this call to “print_character” function. Although the same function is called each iteration, but the argument passed to this function is different. Remember, the loop variable “i” is going to store a different integer number each time round. For the first iteration, “i” has value 0, and since we use “i” as the index for string “message”, this essentially gets the first character of the string which is letter “h” and pass that to the function. In the next iteration, “i” has value 2 and this gets the second character of the string which is letter “e” and pass that to the function. This continues until each of the 5 letters of the message has been printed to the screen.
* Test. Let’s run this again, type in “hello” and 3 and there you go, the output is the same as before, but instead of us writing 5 lines of print, it is now printed from a loop that iterates 5 times. Awesome!
* OK, so do you remember the first problem we want to solve? Yes, now if we decide to change the name of the variable from “message” to “information”, we just need to change it once inside the loop. So easy! 
* Right, but has this loop solved our second problem? That’s it still just prints the first 5 characters when there are more than 5 characters in the string? Let’s try test this out!
* Test. Run the program, this time, type in “awesome” and again 3 for the key. Ah, we still have the same problem, only the first 5 characters were printed. Does anybody know why? Yes, it’s because we use “range(5)” here in the loop. This always returns a range from 0 to 4 with 5 numbers in total. So our loop always iterates 5 times, no more and no less. Looks like the solution is to set the range according to how many characters there are in the message. Here we have 5 to set the range from 0 to 4 because “hello” has 5 characters, and for a message like “awesome”, we should have 7 here to set the range from 0 to 6 because it has 7 characters. 
* So the question now becomes how do we know the number of characters in a string? Well, because finding the length of a string is such a common thing to do, like all the other common tasks, Python provides yet another built-in function for that, and this one is called “len”, short for “length”. Let’s play with it a little bit in the Shell first. Create a variable “message” and assign string “hello” to it. Now type in “len” and pass “message” to it as the argument. Hit return and see? It 5 is printed because the string has 5 characters. Now let’s change the value by assigning string “awesome” and call “len” again. This time, 7 is printed because “awesome” has 7 characters. So as you can see, this function is pretty simple and straightforward to use, throw it string and it gives you the number of characters in it. 
* Now back to the code, the solution is pretty obvious, all we need to do is pass <len(message)> to the “range” function instead of a specific number. So the range that returns is going to be adjusted to the length of the string in the “message” variable. Lets test this.
* Test. First we still type in “hello”, and the it still works. Ok, now run it a second time and type in “awesome”, now see? All 7 letters are printed and not just the first 5. Problem Solved! Awesome!  |
| Encryption - for loop (iterator based) | * Ok, we have just seen how to use a for loop to go through each character in a string and print them out one by one. We created an integer range, and during each loop iteration, assign one number of that range to the loop variable. This loop variable is then used as an index to get each character from the message string. There is nothing wrong with this approach and it works perfectly. But since our goal is just to go through each character in a string one by one, starting from the first character, there is actually a more direct way to do this without using the index at all. 
* This is also using the for loop. So let’s type in keyword “for”. Next is the loop variable. Previously, this is used as a string index. But this time, it’s different. I’m gonna name it “character”. From this name, you can probably guess that it is going to store a character this time. More importantly, just like the index loop variable before, “character” is going to have a different value for each iteration of the loop. So the next question is where do those values come from. Well, as before, let’s type in keyword “in” first, so what follows “in” is going to be the source of those values. Previously, it was the return value of the “range” function, but this time, it’s going to be the variable “message” itself! Finally, don’t forget to add the colon at the end.
* Let’s pause for a minute and look at what this entire line means now. This is a for loop with a loop variable named “character”. It is going to be assigned a different character from the message string each loop iteration, starting from the first character. So if the message is “hello”, “character” has letter “h” the first iteration, “e” the second iteration, “l” the third iteration, another “l” the fourth iteration and “o” the five and last iteration. Once all characters in the string has been looped through, the loop completes. 
* Ok, next is the code inside the loop. We are still gonna call function “print_character”. But this time, instead of using the loop variable as index to get character to print, we can just pass variable “character” as argument directly to the function. So as you can see, this solution does not need the index at all, we go through all the characters of the string directly and the code is much simpler and cleaner. Actually, this is the preferred way to go through all characters of a string. So we will be using this form of for loop in the future.
* Ok, let me delete the first for loop and run the second loop. Type in  “hello”….  |
| Encryption - single letter - string find method | * Ok, we are finally able to go through each character of the message. This is the first important step for the encryption. Does everybody still remember how encryption work in Caeser Cipher? Yes, just as a quick reminder, we find each letter of the message in the circular alphabet, then move clockwise certain steps to the get the new replacement letter. The number of steps to move is determined by the ‘key’ value. Right now, we only print each letter as we are getting them from the string. But we really want to do is to find the replacement letter for it, or more formally, to encrypt it. 
* Let’s change the name of our function first. Instead of calling it ‘print_character’, renmae it to ‘encrypt_character’. We will leave the ‘print’ function call inside for now. Ok, to encrypt, we first need an alphabet. An alphabet is just a sequence of the 26 letters in the English. So let’s create a global variable called ‘alphabet’, and assign a string to it. This string is just going to be the 26 letters, one after the other. Just a reminder, a global variable is not inside any local scope and therefore can be used anywhere in the script. Also as discussed before, I always put my global variables after all the function definitions. 
* Ok, the alphabet is ready, time to encrypt ‘character’. The first step is to find where ‘character’ is in the alphabet. We already know that each character in a string has an index associated with it, the first character has index 0, the second character has index 1, and so on and so forth. To find where ‘character’ is in the alphabet is the same as finding its index in the ‘alphabet’ string. Previously, we have an index, and use that to find a character in a string; now it’s the opposite, we have a character and want to find its index in a string. The question is HOW? No idea? Let me give you some hint: Do you still remember the web page I showed you in last lesson about all the string methods? Yeah! Ok, what if the solution lies in one of those methods? Can you try to find it? Ok, I can hear two answers here: some say the “find” method, and some say the “index” method. First of all, well done to all of you! These are indeed the two methods we need. If you look at the descriptions next to both methods, they are exactly the same. So why there are two then? Well this has too do with how each method handles error when something has gone wrong. But this is outside the scope of this lesson and I do not plan to explain it in detail here. So I would just say use the ‘find’ method for our code. You can open page for the ‘find’ method and read more about it. But, to save us some time, I will just quickly show you how it works.
* In the Shell, create a “message” variable and assign string “hello”. Now, how do we call a method of a string? Yes, first the name of the variable, “message”, followed by a dot, and then the name of the method ‘find’. For this method, we need to pass one argument, which is the string we want to find in message. By the way, when you want find a string in another, this string if often called a “substring” and I will use that from now on. Now, let me pass character ‘e’. Note that this is also a string, it’s just very short and contains only one character. Hit return, and “1” is printed. What does this number stand for? Yes, it’s the index of substring ‘e’ in string “hello”. Because ‘e’ is the second character, so its index is 1. Remember, index always starts from 0. Let me try another substring ‘o’, this time 4 is printed because its the fifth character in the string. Now watch, what if I pass substring ‘l’, what number do you think it’s going to return? Let’s try, aha, it prints “2”, this makes sense because the third letter is ‘l’, which has index 2. But the fourth letter is also ‘l’ and its index is 3. Why the ‘find’ method returns 2 instead of 3? Well, it turns out that if the substring you try to find occurs more than once in the string, ‘find’ always returns the index of the first occurrence. In other words, it’s the place where it first occurs. OK? Finally, let me be a bit naughty and asks it to find a substring that does not exist, say ‘x’, hit return and it prints -1. Ok, so we know that the indices for string “hello” should be in the range from 0 to 4, right? Because it has 5 characters. -1 is clearly not in that range and it is a special value used by the ‘find’ method to tell you something has gone wrong and I cannot find it. This is important, please keep that in mind as it will be useful later on.  |
| Encryption - single letter - get replacement letter | * OK, let’s get back to the ‘encrypt_charater’ function. We have a character to encrypt passed in as a parameter. So let’s first find where it is in our alphabet. Based on what we have just learnt, we can call method “find” on the alphabet string to get the index of ‘character’. So type in variable ‘alphabet’ then a dot and the method name “find”. Finally, pass parameter ‘character’ as the argument in a pair of brackets.  This will return the index of ‘character’ in the alphabet. Next, we need to store this returned index somewhere, so define a local variable ‘index’ and assign the returned value from “find” to it. Remember, a variable defined inside a function definition is a local one within this scope and can be only used in this scope. Nobody else outside of the function can see or use it. Ok, now we have the character and its index in the alphabet, let’s print both out to check if everything works fine. So after the <print(character)>, let add another print to print the index. Ok, before I run it, can you take a guess of that the output is going to be if I type in “hello” as the message? Yes, let’s try out!
* Test. Run, type in “hello”, and 3, and there you go, for each character in the message, it first prints out the letter then its index. So, for the first letter, it prints “h” followed by number 7. So is 7 really the index of letter “h” in the alphabet? Let’s count. So one, two, three, four, five, six, seven, and eight. ‘h’ is the eighth letter in the alphabet, and as we know, index always starts from 0, and the index of “h” is indeed 7. Our program got it right. And if you want, you can count and check if indices for the other four letters are correct. But I will save you some time and just say: Yes, they are all correct!
* OK, we have been going through all these to just get the index of each character in the message, but let me ask you: Why? Why do we need these indices? Can anyone answer this question? Maybe try to recall what the Caeser Cipher does? Yes, we need the index of each letter so that we can work out where the encrypted letter is going to be, because that is always ‘key’ steps away clockwise. Remember the alphabet clock? We first find where the original letter is, then move clockwise ‘key’ number of steps to get to the replacement letter, right? Now, we have the position of the original letter in variable “index”, what do you think the position of the replacement letter is going to be? Let’s try some examples, suppose the key is 3, letter “h” is at index 7, and if we move 3 steps clockwise, we arrive at the replacement letter “k”, and what is the index of “k”? It’s 10, right? Now how about letter “e”, its index is 4, if we move 3 steps clockwise, we arrive at the replacement letter “h”, and what is the index of “h”? It’s 7. As you can see, the index of the replacement letter is just the index of the original letter plus the value of key, right? So 7 plus 3 is 10, and 4 plus 3 is 7. 
* Ok, let’s define a new variable called ‘new_index’. We are going to use this to store the index of the replacement letter. As just discussed, this is the index of the original letter plus key, so lets add variables ‘index’ and ‘key’ and assign the result to “new_index”. To check if everything is correct, let’s add one more print to print ‘new_index’. Let’s test this!
* Test. Run, type in “hello”, and 3 for the key. As you can see from the output, the new index is always 3 larger than the original index. Cool!
* So, once we have the index for the replacement letter, we can now finally get this letter from the alphabet, right? Given an index, how do you get it from a string? Yes, we use indexing. Still remember the syntax for it? Yes, first the string, which is variable “alphabet” then a pair of square brackets, inside the brackets, use variable ‘new_index’ as the index. And finally, let’s assigned the replacement letter to another variable ‘new_character’. Again, just to show everything works as planned, let’s also print “new_character”. 
* Test. Ok, let’s run it. Type in “hello” and 3 for the key, and the output is getting a bit too long. But that’s Ok as long as we know what to look at. So the first letter is “h”, then it’s index 7, then the index of the replacement letter 10 and finally the replacement letter itself “k”. Looks good to me. And if we take all the replacement letters from this output, it’s “k”, “h”, “o”, “o” and “r” , “khoor”, which is exactly the encrypted message we saw at the beginning of this lesson. Looks we have made it! We have encrypted our message! Hooray! Ok, now this function see to work find, we can delete all the print function calls here because they are only used for debugging.  |
| Encryption - create final encrypted message | * Ok, clam down a little bit, we have achieved quite something here, but there are still more work to do before we can call it a day. Let’s first look back at what we have now: we can take in a message and a key value from the user, go through each letter of the message, and encrypt each letter of the message to a different one based on the key value. As we have seen from the output, if we string together all the replacement letters, we have the final encrypted message! But, did we string those replacement letters together? No, we just printed them out! So do we have an encrypted message now? Not yet!
* So let’s first think about how such an encrypted message can be created. In the ‘encrypt_character’ function, we already have each encrypted character in this “new_character” variable, right? So to get the final encrypted message, all we need to do is just to join them together, right? Take a look at this loop, during each loop iteration, it encrypts one character of the original message and print it out. But what if, instead of printing the character out, we return it from function ‘encrypt_character’ and join it to the encrypted message one by one?
* Ok, if this is going fast for you, let’s break in down and look at it bit by bit more slowly. First, like built-in function such as ‘input’, a user-defined function can return value too! In the case of our ‘encrypt_character’ function, we want it to return the encrypted character. How do we do that? Well, it’s actually pretty simple, first, figure out the value you want to return, in this case, it’s the ‘new_character’ variable, right? Next, after you have finish all the work in the function, at the very end it, type in “return” and then the value you want to return, which is variable ‘new_character’. Simple, right? Bye the way, all the four print function calls here are only used for debugging. Since we have already shown that the code works, we can now delete all of them.
* For the built-in ‘input’ function, we often use a variable to store its return value. Same here, since ‘encrypt_character’ now returns the encrypted character, we also want to define a variable to store it. Let’s also call this ‘new_character’ and assign the return value from function ‘encrypt_character’ to it. Now, there is something I want to point out. In function ‘encrypt_character’, we have a variable called ‘new_character’ and here we define another variable called ‘new_character’. Do you think they are the same variable? Yes, absolutely not! Remember the local scope we talked about in last lesson? So the function definition is one local scope and a variable ‘new_character’ is defined there. Here, within the for loop statement, it is another local scope and a different variable ‘new_character’ is define here. So they are two completely different variables that just happen to have the same name. Ok, let’s just print this ‘new_character’ out to check that the return value is what we expect.
* Test. Type in ‘hello’ and 3 for the key, and the output is “khoor”. Perfect, same as before when the encrypted character is printed inside the function. This shows our function has returned the correct value. Nice!
* Ok, now we have the encrypted character retuned back to the for loop, it’s time to join them together. Since we only get one encrypted character in each loop iteration, we cannot join all characters together at once. This has to be done iteration after iteration, meaning joining one character each iteration. Now, in the Animal Quiz lesson, we have a ‘score’ variable. It starts with value 0 and as the user answers each question correctly, we add one to it. In a way, we are building the final score value one point at a time. Now, think about the final encrypted message, it starts with nothing because nothing has been encrypted yet. Then, during each loop iteration, a single character from the original message is encrypted, so we can joint the encrypted character to our final encrypted message. Similar to the ‘score’ variable, this time we are building the encrypted message one character at time! 
* Let’s see how the code looks like. First I’m gonna define another global variable called ‘new_message’ and use that to store the final encrypted message. Initial, let’s assign an empty string to it. Now, an empty string is just one without any character, so it is just a pair of empty quotes. Now, back inside the for loop, all we need to do is just join ‘new_message’ with ‘new_character’. Now, after the loop, let’s print ‘new_message’. I’m just gonna say “The encrypted message is: ” and the variable ‘new_message’. Do you think this would work? Let’s find out. 
* Test. Run it, type in “hello” and 3 as the key, ouch, although we do see “khoor” being printed on the screen, but at the end, no encrypted message was shown. What happened? I think we have seen something very similar to this in the Animal Quiz lesson. Can anyone recall? Yes, it happens to the ‘score’ variable too. This was because even though we added one to ‘score’ each time a question is answered correctly, we did not assign the new score value back to the ‘score’ variable. So the value in ‘score’ always stays at 0. Do you see the similarity here? Although we did join the new character to the new message, but this new value has not been assigned back to the ‘new_message’ variable. So ‘new_message’ variables always has its initial empty string, and that’s why no encrypted message is printed in the end. The solution is also not difficult, all we need to do is assign the new string after the join back to variable ‘new_message’. By the way, because it seems like changing the value of a variable and assigning the new value back to it is such a common thing people do, Python actually provides an easier and shorted way of writing code for it. So instead of <new_message = new_message + new_character>, we can write <new_message += new_character>. So this “+=” operator takes the variable ‘new_message’ on the left, join string “new_character” to it, and assign the new string back to variable ‘new_message’. Similarly, code to increase variable ‘score’ from last lesson can be re-written as <score += 1>. Of course, you can choose whichever way you like and both are correct. Personally, I prefer the shorter one. Ok, let’s also delete this print function call here as it is no longer needed.
* Test. Now if we run the program again, we can see the final encrypted message printed to the screen. Woohoo, job done! Let’s open the champagne and celebrate!  |
| Bug fix - character is upper case | * Or can we? Are we really done here? Let’s find out! Now run the code again. This time, I still want to encrypt message “hello”, but this time, the message is in all CAPITAL letters.  And I still use 3 as the key. Hit return and… what? What is this? It prints ‘ccccc’ as the encrypted message! Something is seems wrong here! Let me try again, let me try a different message, “WROLD”, but still all caps and 3 as key. Hit return, Hmmm… I’m still getting “ccccc”, what the hell is going on here? I will be very glad if any one of you can tell me what the exact problem is! Because finding this problem is pretty challenging. But give it a go and see if you can spot the error in our code.
* Ok, let’s be a detective and trace the code so find the culprit. First let me ask you a question, what is common about these two examples? Yes, all letters are in upper-case. Take the all-cap message “HELLO” for example, when we get its first character, letter “H”, we pass that to function ‘encrypt_character’ for encryption. Now, what does the function do, it first tries to find it in the alphabet. Right, what is our alphabet? Yes, it is a string containing all 26 lower-case English letters, right? So is the upper-case letter “H” in the alphabet? Of course not! Remember, Python is case sensitive, meaning the lower-case and upper-case version of a letter are not the same. So what does method ‘find’ returns when it cannot find what you are asking? Yes! It returns -1, a special value that says “No, I can’t find it!”. Ok, so variable ‘index’ now has value -1. Right, next, we add variable ‘key’ to index, because ‘key’ is 3, so the result -1 + 3 equals 2. So, variable “new_index” now stores value 2, right? Ok, when you use 2 to index the alphabet string, which character do you think it’s going to return? So what letter is at index position 2? “a” is 0, “b” is 1 and “c” is 2. So lower-case letter ‘c’ is going to be returned! Because all letters in message “HELLO” is now upper-case, none of them are in the alphabet, so all of them are going to be encrypted as letter ‘c’ and that’s why we see an encrypted message with 5 letters ‘c’ at the end. All good? 
* Ok, we found the culprit but what to do with it then? Can anyone suggest some solutions? Right, even though we cannot find the upper case letter ‘H’, can we find the lower-case letter ‘h’ in the alphabet? Of course and that’s what we have been doing so far, right? So how about we convert the upper-case “H” to lower case “h” before trying to find it in the alphabet? Yeah? Sounds like a plan? How do we do the conversion? Yes, we have leant in the last lesson about string method “lower” that can convert English letters in a string from upper-case to lower case. So in function ‘encrypt_character’, before we this line, let’s first convert ‘character’ into lower case by calling the ‘lower’ string method on it. This returns the lower-case version of ‘character’. We then assign this return value to a new variable called ‘lower_character’. Now, in the next line, instead of trying to find ‘character’, we find ‘lower_character’ instead. This guarantees that we are going to find it in the alphabet. Let’s run this again!
* Test. Type in “HELLO”, all upper case, and 3 as the key, hit return and voila! It’s no longer ‘ccccc’, we have the encrypted message ‘khoor’. And if I run it again and type in “HeLLo” with a mix of lower case and upper case letters, the result is still ‘khoor’, all lower case. 
* Right, but there seems to be a problem here, ideally, if a letter in the original message is upper case, we want it’s replacement letter to be upper case in the encrypted message as well. So if it is an upper case letter ‘H’, we want it’s encrypted letter ‘K’ to be upper case as well. But right now, even though the encrypted message seems to the correct, but it is always in lower case. We need to fix this! 
* Let’s first see where we get the encrypted letter. It’s here this line, in ‘new_character’, right? And right now, it’s always in lower case. How do I know that? Well, this letter is coming from the alphabet, and all letters in the alphabet are in lower case, so this must be a lower case letter! But here, instead of just returning the encrypted letter, we want to make some choice here: if the original letter in the message was upper case, then we need to convert ‘new_character’ into upper case too before return it. Otherwise, nothing needs to be done we can just return it. 
* Ok, we have a challenge here, how do we know if a letter is upper case? Can anyone maybe suggest where we might find the answer? Yes! Brilliant! Still remember the string method web page? Maybe we can find something useful there! Everytime we need to do something about a string, that page is going to be your friend! Let’s open it. Ok, can you find a method that might be useful for us? Yes, the ‘isupper’ method! What does the brief description says? “Returns True if all characters in the string are upper case”. That looks like exactly what we need: so it returns True if all characters in the string are upper case and False otherwise. In last lesson, we learnt about the ‘True’ and ‘False’ bool values. They are often used to decide whether something is “correct” or “wrong”. 
* So, let’s go to the shell, if I type in a lower case letter ‘h’ and call this method by typing a dot and follow that by a pair of empty bracket, because it does not need any argument, and hit return, it says ‘False’, because this letter is clearly a lower case one. If instead I call this method on a upper case letter ‘H’, it says “True” because this is indeed an upper case letter. Now in the method description, it actually says “all characters in the string”, so if I call it on a string that has more than one letter, for example, ‘Hello’ with only letter ‘H’ being upper case, it still returns ‘False’ but if I call it on string “HELLO” with all upper case letters, it return ‘True’ this time. In other word, it only returns ‘True’ if all letters in the string are upper case, just as what the description says. This is just a side note for you to know, it doesn’t really matter that much here because the string we have here is just a single character. 
* Another thing I want to mention is that, we have seen string methods such as ‘lower’ that change the string in some way, right? That’s one type of string methods, another type is something like this ‘isupper’ method, they do not convert the string into something new, instead they just check if the string has some properties or features, for example, if it is all in upper case. And returns True if it has this property and False otherwise. There are a lot of this kind of string methods and their all start with the word ‘is’. For example, there is complementary method called ‘islower’ that returns True if all letters in the string are lower case. If you are interested, you can explore some of the other methods on your own after class.
* Ok, now we have a way to check if the character to be encrypted is upper case or not, what do we do next. Well, if it is upper case, we want to convert the encrypted character ‘new_character’ into upper case too, right? Else, nothing needs to be done and just return ‘new_character’ like we do here. Ok, did you hear I say something like “if something is True, we do this, else we do that”? Sound familiar? Yes, we can turn this sentence that makes decision into Python code by using the ‘if…else…’ statement! So what is the condition we want to check? Yes, whether ‘character’ is upper case or not? Do we know how to check this? Sure, we just saw the ‘isupper’ method! So, we can put together the ‘if’ statement now. Let’s do it!
* After getting the encrypt character from the alphabet, let’s type in the keyword ‘if’, what follows that? Yes, the condition to check. That’s <new_character.isupper()>. And finally, do not forget the colon. Ok, that’s the ‘if’ statement. Now it’s time to add some code. What do we want to do if ‘character’ is upper case, yes, we want to convert its encrypted character ‘new_character’ into upper case too! How do we do that? Yes, there is a ‘upper’ string method just for that, so let’s call it on the ‘new_character’ variable, and assign the return value back to ‘new_character’. Now, ‘new_character’ would store the upper-case version of the encrypted character. Finally let’s return ‘new_character’. Ok, we are done with the ‘if’ statement. Next, how about the ‘else’ statement? First type in keyword ‘else’. Note that ‘else’ should have the same indentation as the ‘if’ keyword. Then the colon. Ok, what should we do when ‘character’ is not upper case. Easy! Nothing extra needs to be done and we just return ‘new_character’. Ok, that’s it, that’s I think all we need to do to encrypt upper case letter. Does it work? Let’s find out!
* Test. Run the program, type in “HELLO” all in upper case, and 3 as the key, Hooray! We have ‘KHOOR’ as the encrypted message, but this time, all letters are in upper case, just like the original message! And let’s run the program again with a different example, this time, a mix of upper case and lower case letters, such as “HeLLo” with letter ‘H’ and ‘L’ being upper case and rest lower case. Still 3 and the key and hit return, aha, nice! This time, the encrypted message also has a mix of upper and lower case letters: the encrypted character ‘K’ for letter ‘H’ is upper case, encrypted character ‘O’ for letter ‘L’ is also upper case, and the rest stays lower case. This is exactly what we want! Perfect! 
* TODO: the two returns in function ‘encrypt_character‘ is ugly, but since the kids just start to learn python, so probably leave it there as it is a bit easier to understand. |
|  Bug fix - character is not an English letter | * Ok, so we can now deal with messages with both upper and lower case letters. This is a big step forward! But are we all good here? Can we deal with number characters or non-letter characters in a message? Let’s find out!
* Let me run the code again. This time, let’s encrypt a message with an equation “1+2=3” and I still use 3 as the key. Hit return and… Boom! It exploded again! We are seeing the all familiar ‘ccccc’ again! Let me try a different example, how about encrypting a bored face: bracket, minus, underscore, minus and bracket, 3 as key and hit return. Hmmm….it’s ‘ccccc’ once again! Ok, if this is the first time you see it, you might be really surprised by that. But since we have seen this before and I think you should probably be able to explain why. Can one wants to have a go at this?
* Yes, brilliant, that’s exactly what happened! In both examples, none of the characters in both messages are in our alphabet. Further more, they are not upper case either, so what we have just done is not going to help here. So what should we do? 
* Ok, first, we need to make a decision about what to do when a character is not an English letter, such at the ‘=’ symbol, the bracket etc. One way is to encrypt it as well. But what do you encrypt a ‘=’ symbol to? Well, there might be some complex process to do that, but I want stay away from those in this lesson and you can explore on your own after class if you want. Instead, I will just pick the simpler route: We do not encrypt any non-English letter and just leave it as it is.
* Ok, let’s see how to do it. Back to function ‘encrypt_character’. Ok, all the code we have here are assuming that parameter ‘character’ is an English letter. But as we have seen, user can be crazy and this is not necessarily the case. So, I think the very first thing this function should do is to check if ‘character’ is indeed an English letter. If, it is, good, we run all these code here. Else, if it is not an English letter, still simple, just return ‘character’ because nothing needs to be done here. Right, every time we say if this, do this, else, do that, something could come to your mind immediately! Yes, the ‘if…else…’ statement! So, let’s put that in place first. 
* Because this check is going to be the first thing to do in the function, let’s type in keyword ‘if’ at the very beginning. Next, is the condition, here, we want to decide if ‘character’ is indeed an English letter, but we are not sure how to do it now, so let’s just leave this empty and completes the if statement with colon. Of course, if we do that, the Replit editor won’t be happen and gives us this squiggly line to say “Hey, look here, something is wrong, the condition is missing!” But that’s fine, we know it, and will come back to that later. Now, what should we do if the character is an English letter? Yes, all the code here, right? So do you think it’s OK if I just leave it like this? Of course not, because they are now code that run when the condition is True, so, all of them need to be indented to put inside the ‘if’ statement, right? So let’s do that, indent them all. Ok, that completes the ‘if’ part. Now, what should we do when ‘character’ is not an English letter, or in other words, the if condition is False? Yes, we just return ‘character’. But where should we return it? Aha, we just have the ‘if’ part, now it’s time to add the ‘else’ part. Remember, the ‘else’ statement is for code that runs when the condition is False. So, after the last line of the code, type in keyword ‘Else’, but make sure, ‘else’ has the same indentation as ‘if’ because they are the two equivalent part of the ‘if…else…’ statement. And do not forget the clone at the end. Then it’s the code for the ‘else’ statement: easy, all we need to do is just return ‘character’.  Nice!
* Ok, it’s time to take on the big boss: how do we check if ‘character’ is an English letter or not? Ok, previously, we are able to check if the character is upper case or not, right? How did we do that? Yes, we use the ‘isupper’ string method. So, do you think there is another method to check if a character is an English letter or not? Not sure? Let’s find out. Open our string method web page again! See if you can find anything useful here? Can you find one? Yes, the ‘isalpha’ method! Here ‘alpha’ is short for ‘alphabet’. It’s description says “Returns True if all characters in the string are in the alphabet”. Looks promising! Let’s go to the shell and play with it a little bit!
* Say I have a string with a single character ‘a’, and let’s call ‘isalpha’ on that. Dot, isalpha and brackets. Hit return and it prints True. Now, this is a lower case letter, how about an upper case one, so same string, but upper case this time, and call ‘isalpha’ again, and it also returns True. So how about a number character, so string “1” and call ‘isalpha’ on that, and this time it returns False. Now, let’s try some other character, for example, the ‘=’ symbol, and it returns False. So this method will only return True if the string contains only English letters, lower case or upper case. In fact, the string can be more than one character, for example, if I have “abc” and call ‘isalpha’, it also returns True because all three characters are English letters. But if I have “a1b”, this time it returns ‘False’ because ‘1’ is not an English letter. 
* Ok, so looks like this is the perfect method we need to check if our ‘character’ parameter is an English letter or not, let’s finish the last piece of the puzzle. In the ‘if’ condition, let’s call ‘isalpha’ on the ‘character’ parameter. So if ‘isalpha’ return True, meaning ‘character’ is an English letter, we run all the code here that encrypts it. Otherwise, we just run the code in the ‘else’ part, which simply returns ‘character’ without doing anything. So, would this work now? Let’s find out!
* Test. I will test the program with the two examples, the first one is equation ‘1+2=3’ and 3 as the key, now, it prints “1+2=3” again as the encrypted message. This is expected, because we are not encrypting any non-English letters. How about the other example, the bored face, and it prints the face without any changes again. Perfect, exactly what we want. Now, if I test it one more time with a mix of English letters and non-English letters, say another face with both eyes width open, and the two eyes are upper case English letter “O”, what do you think the result is going to be? Let’s find out, run it, and the output is “(R_R)”. Why? Yes, because the two upper case “O”s are English letters, so they get encrypted to upper case letter “R”. Whereas the other three non-English letter characters are left unchanged. Nice! |
| Bug fix - character is letter x, y or z | * Ok, so after all these changes, we have made our code much better, we can handle message with lower and upper case, and we can handle message with non-English characters as well. That’s pretty nice! But there is one more problem! And this one is harder to spot and more hideous. Let’s see what else could go wrong!
* Let’s me run it again and type in message ‘w’, that is a string with a single letter ‘w’, in lower case. And I still use 3 as the key. Ok, question time, what do you think the encrypted message is going to be? Yes, I can hear some of you answer it correctly! The encrypted message is ‘z’, a string with a single letter ‘z’! And how do we get that? Yes, remember the alphabet clock, we first go to letter ‘w’ and move clockwise 3 steps, so, ‘x’, ‘y’ and finally arriving at ‘z’, and this is the encrypted letter. So the final encrypted message is ‘z’.
* Right, now let’s have a different message, this time string ‘x’ with a single letter ‘x’ in lower case. What do you think the encrypted message is going to be this time? Ok, you might think, this is easy, all I need to do is just go to letter ‘x’ in the clock alphabet, move steps clockwise, arriving back at the first letter ‘a’ again, so the encrypted message must be string ‘a’, right? Yeah, I think so, let’s run it! Ouch! It exploded again! And this time, there is an error message as well. Previously, we have seen different error types, such as NameError and SyntaxError. But this is a new one, it’s an IndexError and the detailed message says “stirng index out of range”. Ok, this tells us something: first it’s an error with an index, and second, it’s an index of a string. So when you see such an error, the first thing is to locate where exactly that error happened in the script. Since we know it’s an error about a string index, and we have only one string index in the program here, right in function ‘encrypt_character’, this is easy to locate. But often, your program can be large and sometimes it’s difficult to find exactly where the error occurred. In this case, it’s very important to pay attention to the ‘Traceback’ output in the Console. It is basically a sequence of code that finally leads to where the error [is.](http://is.So) So here we have two lines of code, the first one is at line 86 in our file and the code is the function call to ‘encrypt_character’. The second one is at line 48 and it is the indexing code to string ’alphabet’. So from top to bottom, it gives to a sequence of events, first we call the function then inside the function, we index the string, and final line is where exactly the error occurred. So when you see a ‘Traceback’ output, the last line is usually what you need to locate the exact place of the error.
* Ok, so we now know that the error occurs at this line of code. But why? Ok, let’s become a detective again and try to trace the code to see what really has happened. Remember, the input message is ‘x’, right? So when the code tries to find the index of ‘x’, what do you think this ‘find’ method is going to return? Well, simple, we just need to find out what the index of ‘x’ is in the alphabet string right? So we can count, 1, 2,3 … and 23, so the index of letter ‘x’ is 23. Actually, there is a quicker way, we know that there are 26 letters in the alphabet, right? And index of the first letter ‘a’ starts at 0. So the index of the last letter ‘z’ must be 25. Now, if we count backward, ‘z’ is 25, ‘y’ is 24 and ‘x’ and 23. Ok, next, since variable ‘index’ is 23 and variable ‘key’ is 3, adding them together gives 26, and this is assigned to variable ‘new_index’. So ‘new_index’ now has value 26. Ok, so far so good? Cool. Now we have arrived at the line of code that gave us trouble. We are using indexing string ‘alphabet’ using number 26. Hmmm….remember, the last letter ‘z’ is at index 25. So what is at index 26? Anyone? Ok, some of you say letter ‘a’ because you are thinking of the circular alphabet, right? But the sad truth is that, this circular alphabet is only imaginary which does not exist. What does exist is this ‘alphabet’ string, that has 26 letters, one after the other, in a straight line, there is no circle here. So the question again, what is at index 26? Yes, the answer is nothing! There is nothing here. And more importantly, if you are dared enough to try to access anything beyond index 25, you are trying to enter no one’s land and Python will just throw this IndexError at your face. Ouch! So now, this message ‘string index out of range’ kind of makes sense, it basically means the index 26 you used is outside of range, because the range is from the first letter 0 to the last letter 25. 
* So, what we really want is that if the index is greater than 25, we want it to “wrap around”. What does that mean? Now it’s time to get the circular alphabet out again. When encrypting letter ‘x’ at index 23, we move 3 steps clockwise, so, ‘y’, ‘z’ and finally going back to the first letter ‘a’ at index 0. This is what I mean by wrapping around, if the index is greater 25, start is again from the beginning. So index 23 plus 3, which is equal to 26, turns into index 0. Now, how about encrypting letter ‘y’ at index 24, again, we move 3 steps clockwise, so, ‘z’, and going to to the first letter ‘a’ and finally arriving at letter ‘b’ at index 1. So index 24 plus 3, which is equal to 27, turns in to index 1. And if you do this for letter ‘z’ at index 25, it wraps around and is encrypted as letter ‘c’ at index 2. So index 25 plus 3, which is 28, turns in to 2. 
* Ok, so we can clearly see how the circular alphabet helps us to understand how the wrapping works. That’s good. But unfortunately, as I said earlier, our alphabet string here is not circular, instead it just a sequence of letters one after the other in a straight line. After all, that’s the reason why we have the IndexError in the first place, right? So, how can we make the index wraps around in Python code?
* Here's where our super helpful friend, the modulo operator (%), comes in! It's the magic key that helps us figure out where an index should be after wrapping around. For anyone who has learnt basic maths, you should already know about the concept of division and remainder. And the modulo operator in Python, like the addition and subtraction operators, takes two numbers and gives you the remainder after a division. Let’s see how it works in the shell. So if I divide 4 by 2, what do you think the result is going to be? 2, right? Ok, the result is acutally 2.0, a decimal number. This is because Python always returns a decimal number for division, even if it is an exact division. But that’s not important here, just for you to know. Ok, let’s try the modulo operator, what do you think the result is going to be if I have 4 modulo 2? Yes, 0! Remember, the modulo operator gives you the remainder when 4 is divided by 2, which is 0. Let’s see if that is the case, yes, it’s 0. Now, what is the result of 5 modulo 2? Yes, it’s 1 because the remainder is 1. Ok, you might be wondering, how is this going to help for wrapping around the string index? Right, let’s let change the numbers a little bit. This time, let’s have 1 modulo 26, what do you think the result is going to be? Yes, it’s 1. Then how about 2 modulo 26, it’s 2, and 3 modulo 26, it’s 3. This goes all the way to 25, when you have 25 modulo 26 you still have 25. So far so good? Now is the interesting bit, what about 26%26? Well it’s 0 because 26 divided by 26 is 1, and the remainder is 0. Hmmm… interesting, remember earlier, when we encrypt letter ‘x’ at index 23, we first add the key 3 to it gives us index 26. And this is the same as moving 3 steps clockwise to arrive at letter ‘a’, which is at index 0. Right? Now if we have just the right operator to turn index 26 into index 0, all you need to do is 26 % 26 and that gives you 0. So essentially, we wrap around to go back to the beginning of the alphabet. How about the letter ‘y’ at index 24? Same, add 3 to it to get index 27. Then modulo that by 26, which gives you the remainder 1. If we use that as the index of the encrypted letter, this is letter ‘b’ at index 1. Again, we turn index 27 into index 1. And this goes on. You can see the pattern here, if we apply the modulo operator with an index and 26, it always gives us a number in the range between 0 and 25 even if index is greater than 25. And this range is exactly where all the 26 letters of the alphabet are. Try to play with this a bit on your own and you can see how cool it is!
* Ok, so with our new magic friend the modulo operator, all we need to do to fix our problem is to use it for the ‘new_index’ variable. Because we want ‘new_index’ to wrap around when it’s greater than 25 and always stays in the range between 0 and 25. So let’s use ‘new_index’ modulo 26 at the actual index for string ‘alphabet’ here. That’s it! Once you know what the problem is, solving it can sometimes be very simple. Let’s test this!
* Test. Run the program again, and type in ‘x’ as the message and 3 and the key.  Hooray, see, this time, instead of an IndexError, we actually get the final encrypted message ‘a’. This the because, now the cipher wraps around and go back to the first letter in the alphabet. Let’s try ‘y’, and this time it’s ‘b’, and ‘z’ and you get ‘c’. Very cool! Now just to make sure that our change has not cause any new problem, let’s try the ‘hello’ message again, and the encrypted message is ‘hkoor’, same as before! We are all good here!
* Wow, we have solved another problem! So are we finally done yet? Hmmm… I’m not too sure and I think there must still be some cases where our code will explode. Of course, we don’t have all the time to solve each and every one of them in the class. So I will leave that as an exercise for you to explore. Try to be crazy and throw all kinds of weird messages at our program and see how it deals with it. If it explodes, try to figure out why and see if you can fix it. This is pretty common when you write programs, always prepare for the worse. Never expect all your users to be nice people, actually, some of them might be working very hard to try to break your program at all costs. So you need to make your program as robust as you can, this means being able to cope with as many unexpected situations as possible. And this is very a important skill you needs to have. |
| Decryption - if…elif…else statement | * Ok, finally, we can move on from fixing bugs to writing some new code! Right now, we have completed one side of the story: to encrypt a message. However, there is the other side of the story: to decrypt a message. For example, given message ‘khoor’ to decrypt, it should print out ‘hello’ back. Let’s work on that next!
* The first thing we want to do is to give the user a choice between encrypt and decrypt. So our program is going to ask him/her what they want to do. So, after getting the message and the key, we are going to ask for encryption or decryption. So let’s have another function call to ‘input’ and ask “Do you want to encrypt or decrypt?” And let’s store the return value in a new variable called ‘choice’.  
* Test. Let’s run it, type in message “hello” and 3 as the key, now we are asked for our choice, let me type in “encrypt” and it prints out the encrypted message. Ok, this might look the program encrypted the message because we say so. But it is actually not, we are just getting the user’s choice without doing anything with it. This will be clear if I run it again, type in “hello” and 3 as the key, and type in ‘decrypt’ this time. Now, see? It still encrypts the message and print it out. No decryption at all! Let’s fix that!
* We have the user’s choice in the ‘choice’ variable, so we can decide what to do base on that. Now, every time we need to make a decision, what should come to your mind? Yes, the ‘If … else …’ statement. I hope this should become fairly natural to you by now. OK, let’s bring that [out.](http://out.So) So, keyword ‘if’, then what the condition is going to be? Yes, we want to check is the value in ‘choice’ is string ‘encrypt’. In last lesson, we have seen how to use the ‘==’ to compare two strings to see if they are equal. So let’s check if ‘choice’ is equal to ‘encrypt’, and finally the colon. Ok, if the user want to encrypt a message, what should we do? Yes, we encrypt it! And do we have the code for encryption? Of course, and that’s what we have been doing most of this lesson so far! The code is just this ‘for’ loop and the final print function call. So they all need to go inside the ‘if’ statement. Are they inside now? No? Why? Yes, because they are not indented, so they are still in the global scope. Let’s put them inside by adding the indentation. Cool! So let’s this out!
* Test. Type in ‘hello’, 3 as the key and ‘encrypt’. Yes, it encrypts the message. Nice. What about decrypt, let’s try, ‘hello’, 3, and ‘decrypt’. Ok, nothing is printed on the screen and the program just finishes. Can anyone explain why? Yes, because we only have the ‘if’ statement to handle the encrypt case, but there is no ‘else’ statement, so nothing gets done when the choice is not ‘encrypt’. Let’s add an ‘else’ statement then.
* So without any indentation, type in ‘else’ and colon. Ok, this starts the ‘else’ statement. What do we want to do here? Yes, decrypt of course! But right now, we have no idea how to do it. Python is not happy with that as you can tell from the red squiggly line here. It basically says “hey, you have started an ‘else’ statement, but you have not added any code for it yet”. Ok, so right now, just to keep Python happy, let me print out a message that says “The decrypted message is:” and use the ‘message’ variable here for the time being. We will change that later on. Let’s test this!
* Test. “hello”, 3 and this time choose ‘decrypt’. Ok, it’s better this time, we see ‘The decrypted message is : hello’. So our ‘else’ statement works also. Now, let me run the program again, ‘hello’, 3. And this time, I do not choose encrypt or decrypt, instead I just type in some garbage, and the program still says “The decrypted message is : hello”. Now, anybody knows why? Yes, because our ‘else’ statement deals with all cases that are not ‘encrypt’, even if it’s just some garbage choice! This is not very good, ideally, we want to encrypt only is the user types in ‘encrypt’, and ‘decrypt’ only if they type in ‘decrypt’ and for anything else, we could probably print something like “Invalid choice”. Remember about how to make your program more robust? Well, this is another case, user can type in any garbage and you need to prepare for that! So let’s prepare for that!
* So far, all we have see is the ‘if…else…’ statement, and it’s like an Y junction where you have two and only two ways to go, left or right. But sometime, you might arrive at a junction where there are more than two ways ahead to choose from. And Python have you covered in that case too! The statement is called “if … elif … else …” statement. The ‘elif’ here is short for ‘else if’. Now let’s first see how it is used and then I will explain it. Now, after the ‘if’ statement for encryption, instead of just having an ‘else’ statement that covers all the other cases, I will add an ‘elif’ statement for decryption. Now, this starts with keyword ‘elif’, which has the same indentation as the ‘if’ statement. Then just like the ‘if’ statement, you also need to give it a condition to check. We want to check if variable ‘choice’ is ‘decrypt’ here. So <choice == ‘decrypt’> and finally the colon. So this starts the ‘elif’ statement, and for its code, let’s move this print from the ‘else’ statement to here. And finally, we add the ‘else’ statement, and this time let’s print “Invalid choice”. Ok, that finishes up the ‘if … elif … else …’ statement. So now we have more than one condition to check, first, it checks if ‘choice’ is ‘encrypt’, if it is, it run the all the encryption code here. If not, it then moves to the next condition in the ‘elif’ statement and check if choice is ‘decrypt’, if so, it should decrypt the message, but since we don’t have those code yet, we just put a simple print here for now; if not, it then moves on to the final ‘else’ statement where it prints ‘Invalid option’. As you can see, with the ‘if…elif…else’ statement, you can now have more than one condition to check. In fact, there can be multiple ‘elif’ statements. And the program is going to check those conditions one after the other, as soon as one is True, it runs the code there and the whole statement is finished. If none of the condition is True, then it finally falls to the ‘else’ statement and runs its code. |
| Decryption | * OK, we are finally ready to take on the decryption challenge! Ok, before we write any code, let’s first think about how decryption works. Can anyone walk me through? Ok, good. Let’s do it together! So, we first have the message to decrypt, right? Then what next? Ok, we go through each character of this message, and convert it into a decrypted character. How do we convert it? Well, it’s the exact opposite of what we do for encryption: first, we find the character in our circular alphabet, then, very important, instead of going clockwise three steps, we go anti-clockwise three steps and arrive at the replacement character. Let’s see an example.
* I will use string ‘khoor’ as the message to decrypt. As we have already seen, this is the encrypted message of “hello”. So if we decrypt that, we should get “khoor” back, right? First character, ‘k’, let’s find it in the alphabet, then move anti-clockwise three steps, so, ‘j’, ‘i’ and finally arriving at ‘h’. So the decrypted character is letter ‘h’. Next, letter ‘h’, again, find it in the alphabet, then move anti-clockwise three steps, so, ‘g’, ‘f’ and finally arriving at ‘e’. So the decrypted character is letter ‘e’. Now we have ‘h’ followed by an ‘e’, this starting to look like message ‘hello’. If we continue with the rest of the letters, we will decrypt the message to ‘hello’. So, this is what decryption looks like.
* Ok, now let’s me ask you a question, if you compare the encryption process with the decryption process, can you find the main differences? Anyone? Yes, I can only find one difference: in encryption, we move clockwise in the alphabet to get the encrypted letter whereas in decryption, we move anti-clockwise to get the decrypted letter. That’s it! That’s the only difference! Nothing else! So in the code, how do we move clockwise for encryption? Yes, it’s here in function ‘encrypt_character’, we add ‘key’ to ‘index’, right? So, in the case of decryption, what do you think we should do here instead? Yes, we should subtract ‘key‘ from ‘index’. And that’s all you need to do decryption! Pretty amazing huh? All the hard work, such as finding the replacement letter, checking for non-English character and upper-case letter have all been done already! And you just need to change this single line! Of course, we cannot do it here because this function is for encryption. Instead, let’s create another function ‘decrypt_character’. Because we have seen that this is going to be almost the same as ‘encrypt_character’, I will just copy everything here, and paste it below. Now, I only change two things: first, the function name should be ‘decrypt_character’. Then, instead of adding ‘key’ to ‘index’, we subtract it from ‘index’ to move anti-clockwise. And job done! We have a function to decrypt a character. 
* Now, it’s time to complete the code in the ‘elif’ statement. This is also pretty simple because it’s almost the same as the encryption code. So, let’s copy the entire ‘for’ loop and paste it here. Again, we just need to change two things: first, we are calling ‘decrypt_character’ this time for decryption. Then, since the encrypted message is in variable ‘new_message’ now, we print this one instead of ‘message’ when the loop completes. Job done, we go through each character in ‘message’, encrypt it and build the final encrypted message one character at a time. Let’s test if this works!
* Test. Type in ‘khoor’ and 3 as the key, hit return, and there you go, we have the original message ‘hello’ back. Amazing! |
|  | * As you can see, we have done all the hard word in encryption, and since decryption very similar, the code is pretty easy to write, just copy and paste, change a few things and we are done!
* OK, the code works perfectly, but before I call it a day and finish today’s lesson, there is still one more thing I want to improve. Remember I said that every time you copy and paste code, you should think of a better way, right? Here we copy the code of function ‘encrypt_character’ to create ‘decrypt_character’ function. And if you take a look at both, they are 99% the same with only 2 minor differences. So as a lazy programmer, ideally I only want to write the code once and use it twice for both encryption and decryption. So how can we do it? In lesson Animal Quiz, to avoid having the same code to check answer for each question, we created a single function ‘check_answer’ and call it for each question. But the answer to check for each question is different, so how did we manage to use one function for all? Yes, we passed the correct answer as a parameter so the function can be used to check different answers.
* Now, here we have two very similar functions that are called by encryption and decryption respectively. Can we combine them into one function so that we can call it for both encryption and decryption? Well, let’s try! First, let me copy ‘encrypt_character’ again and paste it below. This is going to be the single function to call for both encryption and decryption. So we need to change the name. Now, it’s up to you what you want to call it. Since both encryption and decryption are converting a character into another one, I will just call this “convert_character”. Ok, do you still what is the other difference between ‘encrypt_chracter’ and ‘decrypt_character’? Yes, it’s how we use the key, for encryption, we add it to ‘index’ and for decryption we subtract it from ‘index’. So how can we handle both cases in this single ‘convert_character’ function? I can hear some of you say “use parameter”. Yes, that’s right, we can use parameter. But what parameter should we pass in? Now, think about this, in the case of decryption, we subtract ‘key’ from ‘index’, right? Now subtracting a number is the same as adding the negative of that number. So 5 - 2 is the same the same as 5 plus -2. So you understand that, this gives us a solution, we can pass the key as a parameter into function ‘convert_character’. For encryption, we pass the key as it is, so if user type in 3, we pass 3 in when calling the function. For decryption, however, we need to negate the key before it is passed in. Again, if user type in 3, we pass -3 in instead. The benefit of doing this is that, inside ‘convert_character’ function, we can still add ‘key’ to ‘index’, no code needs to be changed. The only difference is that, for encryption, because a negative key value is passed in, so this essentially becomes subtracting key from index, which is exactly what we need. So let’s change the code!
* First, I will add a new parameter called ‘key’ after the existing parameter ‘character’. Please do not forget the comma to separate them out. Now, here I want to point out that this parameter ‘key’ is not the same as the variable ‘key’ in the global scope. Remember, a parameter is like a local variable for the function only. So in case where you have a global variable and a local variable, both have the name, what is actually being accessed or used in the local scope is the local variable, and not the global one. So inside this function, whenever you see ‘key’, it’s referring to the parameter ‘key’ instead of the global variable ‘key’. This is very different from ‘encrypt_character’ and ‘decrypt_character’, in those two functions, the variable ‘key’ actually refers to the global ‘key’ variable because there is no local variable having the same name. Ok, that’s it, that’s all we need to do to the function definition. 
* Now, let’s turn to the place where this function should be called. In the ‘if’ statement for encryption, we call ‘convert_character’ instead and pass an extra ‘key’ as the second argument. In the ‘elif’ statement for decryption, we also call ‘convert_character’ instead. But for the second argument, we need to turn ‘key’ into a negative number before passing it in. This is pretty simple, just put a ‘-’ symbol before variable ‘key’ and this turns it into a negative number. 
* Now, since both encryption and decryption are now calling the new function ‘conevert_character’, we no longer need ‘encrypt_character’ and ‘decrypt_character’, so let’s delete both of them.
* Test. Now, let’s test the program again just to make sure everything still works as before after all these changes. We need to test both encryption and decryption …  |
| Summary |  |

### Exercise

- Can you use negative number as string index? If so, what does that mean?
- Can you find other cases where user input can break the program? How to handle them?
- Can you use user-defined function to reduce code duplication between the two ‘for’ loops?
- Try different messages and key value. Does your program still work?
- Do you know other ciphers? Can you share it with us?