# 5 Guess the Word

### Reference

“Coding Projects in Python”

### Code

[https://github.com/jguo108/My-Programming-Courses/blob/main/Python/Level0/Basics/5 Guess the Word/main.py](https://github.com/jguo108/My-Programming-Courses/blob/main/Python/Level0/Basics/5%20Guess%20the%20Word/main.py)

### Key Points

- String
    - ‘replace’ method
    - String formatting (f-string)
- List
    - Change item in a list
    - Create character list from a string
- Loop
    - Complex while loop condition with ‘and’
    - forever loop
    - game loop
- File Handling
    - Open and read from file
    - Use ‘splitlines’ to convert lines in a file to a string list directly
    - Close a file (TODO: This is not done yet!!!!)
- Operators
    - Logical operators: and, or, not
    - “-=” to decrease a number variable
- Misc
    - “pass” statement
    - nested statements

| Steps | Note |
| --- | --- |
| Introduction | * Good morning, good you see you all again. Welcome to a new Python lesson! Today, we are going to use Python to play a word guessing game. Let’s first see how to play!

* When the program starts, it prints 5 stars that will be used to display the answer. It hides a 5-letter word for us to guess. We can attempt a total of 9 times, and since the game has started, we still have 9 attempts left. Now it’s our turn to guess a single letter or an entire 5-letter word. For this demonstration, I have also printed the secret word at the beginning so that I know what it is. This allows me to show you how the program works. But when we actually want to test other people, we should never print this out! So the secret word is “plane”. Now, if I type in letter ‘e’ as my first guess, the fifth star,  which corresponds to the last letter of the word, changes to ‘e’ because this is what the last letter of word ‘plane’ is. And because we answer it correctly, we still have 9 attempts left, and the program is asking for the next letter. Now, if I type in letter ‘p’ this time, then the first star, which corresponds to the first letter of the word, becomes ‘p’ because this is what the first letter of word ‘plane’ is. Again, because we answered correctly, the number of attempts is still 9. Now, if the letter we type in is not in the word, for example ‘x’, it prints a message telling us that this is wrong, and current answer is still “p * * * e”, and because we go it wrong, the number of attempts we got left becomes 8. Next, let me type in letter “l” and this one is correct. And now, at any point in the game, if you think you know what the whole word is, you can just type in the the entire word in one go. For example, here a word that starts with “p” and “l” and end with “e”, I think it’s the word “plane”. So let me type in “plane”. Hooray! It says “You won! The secret word was: plane”. Pretty cool! 

* Now, let me run the program again. The time it’s a different secret word “pizza”. So say I’m being very unlucky this time, none of the letter I guess is in the word, so “x”, no, 8 attempts left; “b”, no, 7 attempts left; “e”, no 6 attempts, left; “h”, no, 5 attempts left; “o” no, 4 attempts left, “s” no, 3 attempts, left; “y” no, 2 attempts left; “d” no, 1 attempt left, “f” no, ouch, we lose the game! It says “You lost. The secret word was: pizza”. Oh no, how did I manage to miss each and every single letter! Unbelievable!

* Right, this is what the whole game is about and how you can play with it.  Let’s complete this together in today’s lesson! |
| Pick and print secret word | * So let’s start by picking a word for the user to guess. As we can see from the demonstration, every time you play the game, it gives you a different word. So how can this be done? Anyone? Yes, we can first prepare a collection of words and then just randomly select one each time the game runs. Now how can we store a bunch of words? Yes, we have just learnt in the last lesson about one very useful type of value called “List”. So if we can have a list of students, there is no reason why we can’t have a list of words! So let’s do that!

* Still remember how to create a list? Yes, a list always has a pair of square brackets. Then inside the brackets, we add individual items or elements, all separated by comma. Here, the items are going to be words. I’m just gonna add a few, “pizza”, “teeth”, “shirt”, “plane”, “grass”. Did you notice anything common among the words? Yes, they all have the same number of letters, that is 5. This is important, for all the words you add, make sure they are all of the same length. And we will see why later on. Finally, let’s assign this list to a variable “words”. 

* OK, we now have a list of words to choose from. Each time the game is run, we want to pick a different word for the user to guess. How can we do that? Yes, again, as we have learnt from the last lesson, we can pick a random item from a list. Still remember how to do that? Yes, we need the ‘choice’ method in the ‘random’ module to do that. Now, to use anything inside a different module, what is the first thing we need to do? Yes, we need to import whole module or the method in the module we are going to use. Still remember the three different ways to import module methods? Yes, very good. So which one do you think we should use here? Well, actually anyone would do here, I’m just keep it simple and import all methods using <from random import *>. Remember, all import statements must be at the top of each file. 

* Right, after the import, we can call the ‘choice’ method and pass in list “words” as argument, this would then return a randomly chosen word from the list. And we assign that to a new variable called “secret_word”. Now, when we are still developing the program, we need to know what the secret word is. Otherwise, it is going to be very difficult to know if our code is correct or not. So let’s print this out: print, pass string “The secret word is:” as the first argument, and variable “secret_word” as the second argument.

* Test. Let’s run this. Yes, it prints out secret word “pizza”. And if we run it again, this time the secret word becomes “teeah”. Pretty cool! |
| f-string | * Ok, before we move on with the rest of the code. I want to first take a detour and talk about strings. Ok, I know what you are thinking: what is so interesting about strings? Haven’t we been using it all the time since the first lesson? Is it still worth talking about? Well, here, we are going to introduce a new kind of string call “f-string”. What does that mean and why is it useful? Well, a good example is better than a thousand words! 

* Let’s open the shell. Now say I want to print a message “Hello, my name is Jason, I’m 12 years old”. And both the name and age are stored in two different variables. So let’s create variable “name” and assign “Jason” to it, and another variable “age” and assign 12 to it. Now, with these two variables, how can we print this message? Well there are two ways. The first approach is to pass the individual parts of the message as arguments to the ‘print’ function. So let’s call ‘print’, first pass string “Hello, my name is”, then the “name” variable, and next string “, I’m”, then variable “age” and finally string “yeas old”. Now hit return and the message is printed out: “Hello, my name is Jason, I’m 12 years old”. The second approach is to create the whole message by joining all the parts together, and then print this message. So let’s create another variable used to store the entire message. We can join all the different parts using the “+” symbol and assign the result to “message”. Finally, we just print “message” and we get the same output. Right, this is pretty much what we have been doing so far. But what do you think about these two approaches? Do you like them? Do you think they look good? What do you think? 

* Well, to be honest, I hate them. I think they are ugly as hell! Neither approach makes it clear to me, at least at first glance, what the message really is. All the different parts of the final message are separated by either commas or “+” symbols. I have to mentally piece all the parts together to understand what it tries to say. The cause of this problem is because we are mixing strings and variables. This breaks a single sentence into a million pieces. As a result we have to somehow join them together. Unfortunately, having a mix of strings and variables are very common in Python so we have been seeing such ugly code all over the place. Then, eventually, someone in the Python community says: Enough of this and let’s create something better. And here comes the ‘f-string’.

* So, an **f-string** is a way to create strings in Python that can include variables directly inside a string. What does that mean, well going back to our example. Previously, in the second approach, we use the “+” symbols all over the place to join the different parts of the final message together. With an f-string, this is no longer needed! It is called ‘f-string’ because the string always starts with letter ‘f’, short for the word “formatted”. Then let’s start the string with a quote. Time to start typing in our message: “Hello, my name is”, now, here is important bit, with the second approach, we would finish the string and join the “name” variable with what we already have using the “+” symbol, right? But with f-string, all we need to do is to add a pair of curly brackets, and put the variable “name” inside. There is no need to cut the string off and add a “+” symbol, the entire string just continues to flow. Now, after the name, it’s the comma, then “I’m”, again here we need the variable “age”, so just add another pair of curly brackets, and put variable “age” inside. Again, no need to add the “+” symbol. After that, we can finish the rest of the string “years old” and end it with another quote to match the beginning one. Finally, let’s assign this entire f-string to variable “message”. Now take a look at this, isn’t that message better than the other approaches. The whole message is now a single string without being broken up into pieces. And it’s also much clearer to read. f-string is definitely the way to go! 

* Now let’s see what happen if I print “message”. Wow, the message is the same as before! So as you can see, when an f-string is printed, all its variables are going to be replaced by the values inside those variables. And this is exactly how f-string works. The syntax might look a bit strange and unusual to you. But as you start to use it more and more, I can guarantee that you would never want to go back to the old ways again. And for this reason, from this lesson on, I would also use f-string as long as it’s possible, because I just love it! |
| Pick and print secret word - f-string | * Ok, coming back to the code, since we now know how wonderful f-string is, I would like to use it now to print the secret word. So instead of passing two arguments to ‘print’ here, I would just pass a single f-string. Remember, f-string always starts with letter “f”, then a pair of quotes. Inside the quotes, start typing “The secret word is: ”, now we need the value of variable “secret_word”, so in the f-string, add a pair of curly brackets, and then variable “secret_word” inside. 

* Test. Let’s test this out. Here you go, the same message, of course, this time we have a different secret word. Amazing! Before we continue, I want to point out a common mistake people often make when using f-string, they sometimes forget to add the letter “f” at the beginning. If that is the case, then it won’t work. So please keep this in mind.  |
| Answer list | * Ok, Time to move on. Each time after the user guesses a letter, we print out the current answer so far. For a 5-letter word, there are initially 5 stars. Then every time a letter is guessed correctly, the star at that letter’s position is changed to that letter.  For example, if the word is “plane”, if the user guesses letter “p”, then the first star is going to changed to “p”. 

* Now, let’s think about the answer with 5 “*”s. What type of value do you think it should be? Ok, I can hear some of you say use a string with five “*” characters! This is a good try! Ok, let’s create an “answer” variable and assign a string with 5 “*” characters, and let’s print it out. 

* Test. Let’s test this and 5 stars are printed out after the secret word. Ok, in the demonstration, we have a space between each pair of starts, but let’s not worry too much about that for now. 

* Now, we have the answer in its initial form. Ok, as the user plays the game, what do you think is going to happen to the “answer” string? Yes, it’s characters are going to be changed to the letters that are in secret word when guessed correctly. In other words, we need to be able to change individual character of a string. But how? So for, we have been just using a string, but never try to modify its characters. How can we do that? Awesome! Maybe it’s time to take another look at the string method web page? So go ahead and see if you can find anything useful there. Right, so looks like method ‘replace’ is the most promising one. It says “Returns a string where a specified value is replaced with a specified value”. What does that mean, let’s play with it in the Shell.

* Let’s create a string “abcde” and assign it to a variable “str”. Now, let’s call method ‘replace’ on str. For this method, you need to pass at least two arguments, the first one is the sub-string you want to replace, for example, I want to replace letter “c”, so pass that in. The second argument is the string you want to replace “c” with, so I will pass a “*”. Now, if I hit return, see, the original string becomes “ab*de”. If you have more than one letter “c” in the string, then by default, “replace” is going to change them all. For example, if I change the string to “abcdec”, with an extra “c” at the end, and call “replace” again to replace “c” with “*”, now hit return and see? Both letters “c” are changed to “*”. However, if you only want to change one occurrence of “c”, there is a third argument you can pass for the number of occurrences. So if I reset the string to “abcdec” and pass number one as the third argument, this time, only the first occurrence has been changed to “*”.  

* Right, back to our code. We now have a way to change a single character of a string, but do you think it is going to help here? Again, say the secret word is “plane”, and the user guesses letter “n”. We can find out where “n” is in the word, it’s the fourth character at index 3. With all these information and the “replace” method, can we write code to replace the fourth “*” symbol in “answer” with letter “n”. Let’s take some time to think about it. If we write <answer.replace(”*”, “n”, 1)>, do you think it would work? No! Why? What do you think the result is going to be? Yes, because ‘replace’ method always replaces the FIRST occurrence of a “*”, so what we end up with is string “n****”, not really what we want, right? 

* OK, previously, we have seen that to change the value of a variable, we use assignment to assign a new value to it, right? Now, if we have the index of a character in a string we want to change, can we just directly assign a new character to that position? For example, if we want to change the character at index 3 of the “answer” string to “n”, first the character at the position is <answer[3]> and what if we just do <answer[3] = “n”>? Sounds like a reasonable solution? Would it work? Let’s find out in the shell. First create an “answer” variable with 5 star characters. Then do <answer[3] = “n”> to change the fourth character to “n”. Hit return. Ouch! We have TypeError! The error description says “’str’ object does not support item assignment”. Ok, to translate that, it basically say: you cannot assign a value to an individual item in a string. For a string, an individual item is just a single character. So, it you cannot change a single character in a string by assigning a new value to it (Should I explain that a string is “immutable”?). But don’t give up, all the thinking and work we have done so far are not completely wasted! From the error message, it seems that Python supports something called “item assignment”, just not for a string!  So what could support “item assignment”? Well, let me ask you a question: what is very similar to a string? Yes! A list. As we have seen from last lesson, a string and a list are very similar. The are both a sequence of items, and both support indexing etc etc. So would a list support this form of “item” assignment? Let’s find out! Now, what if I assign a list of 5 items, each being a “*” character, to variable “answer”? Now, say I want to change the fourth item at index 3, type in <answer[3] = “n”> and hit return. Ok, nothing shows up, but at least we are not getting an error! Now let’s print “answer”. Hooray! The fourth character has been changed to letter “n”. So, even though string and list are very similar, they still have some differences. And one important difference is that: list supports item assignment while string does not. This means, once we know the index of an individual item in a list, we can change it by assigning it a new value. How cool is that! And this seems like exactly what we need! (Do we need to introduce the two shortcuts for creating the star list from a string)

* So, back to our code, instead of assigning a string to variable “answer”, let’s assign it a list with five “*” letters!  Now, if we run the program, a list is printed instead. Of course, the output format can be made prettier: We want to just print the star symbols without all the brackets, quotes and commas. And we want the stars to be separated by spaces. So in the last lesson, we have learn a way to print a list of all students separated by commas, right? Still remember how we did that? Yes, we called the string’s ‘join’ method on a string with a single “comma”. Now this comma is then used as the separator to separate all the students in the final string. Can we do something similar here? Sure! What separator do we need this time? Yes, a space character. So let’s have a string with a single space character and we call “join” on this string, passing the “answer” list as argument. Let’s see what the output looks like this time.

* Test. Bingo, it’s exactly what we want, all fives star separated a single space. No brackets, no quotes and no commas. Perfect! Now it’s important to have the space in this string, because if you don’t have that, what does this string becomes? Yes, it becomes an empty string. If you use an empty string as the separator, what do you think the output is going to be? Yes, there will be no spaces between the stars and they will just stick together. We could try, remove the space, and run, see, no more space between the stars.  |
| Number of attempts left | * Ok, we now have the secret word and the answer list, but before the game can start, we need one more thing. As we have seen in the demonstration, there is a upper limit on the number of times a user can get his/her guess wrong. In my case, I have set this to 9 times. So if the user guessed wrongly for 9 times without coming up with the answer, he/she loses the game. So we need another variable to store how many more times the user has got left so that we know when he/she fails. So in the global scope, let’s create another variable, and I will call it “attempts_left”. It ‘s pretty clear from this name that the variables stores how many more attempts the user has got left. And for its initial value, I’m gonna assign 9. Of course, you can choose any number, the bigger the number, the easier the game, and vice versa.   |
| Game loop concept | * Ok, we have got everything ready for now, time to enter the game. Now, before we start writing any code, I want to talk about about how the code for games usually look like. Even though what we have in this lesson is a very simple game, it still follows the same pattern.  

* First, we have what is called a “Game Loop”. Ok, we have learnt about loops, including ‘for’ loop and ‘while’ loop in the previous lessons. And we know that it is just a way to run the same code again and again. Now, what is a “Game Loop”? Well, it is a loop, which means it’s going to run something again and again, right? But what is that “something” about? Well, that’s where the word “game” comes in, that “something” is the “game logic”. Well, don’t let that name scares you, it basically just means what your game does. So when you know what your game does, and you do it again and again, you have a “Game Loop”.

* So what does our game does here? Well, let’s first talk about it without writing any code. The game is just going to ask a user for a guess, and if his/her guess is correct, it updates the answer; otherwise, it encourages them to try again. of course, we have ignored quite a lot of details, but they are not important   
here to understand the game loop. So the game does this again and again inside a “game loop”. So the game loop cannot just continue forever, right? It should eventually end with the user winning or losing. This is the final important piece of a game loop: the “terminating condition”, which means under what condition should we jump out of the game loop and end. In this game, if the user finds out that the secret words is, the game loop ends with user winning the game. If the user runs out all the attempts without figuring what the secret word is, the game loop ends with user losing the game. So this is the “terminating condition” of our game loop. 

* So, the game is first going to ask the user to guess a single letter or the entire word. Then it takes whatever the user types in, checks if the input is either a letter that matches one or more in the secret word or an entire word that is the same as the secret word. If it is the first case, it reveals the letters in the answer and lets the user know how many attempts are left. If it is the second case, it just congratulates the user for winning the game and ends the program. However, if the user’s input is incorrect, it let’s the user know and reduce the number of attempts by one.  |
| Forever game loop header | * Ok, after understanding what a game loop is, let’s see it actually being used in our program. So first, we have learnt two types of loops in Python: the ‘for’ loop and and the ‘while’ loop. Can anyone reminds us all what are the differences between them and what each one is good for? Good, great answer! So a ‘for’ loop is often used when to want to go through everything in a fixed set, for example, a number range or a list of item. You have a clear start, such as the first number in the range or the first item of a list, and a clear end, such as the last number in the range and the last item in a list. This is what a ‘for’ loop is good for. Now, a ‘while’ loop is good for the case where you just want to do something again and again until some condition is met. For example, in last lesson, we need to pick students one by one from the student list until there are no more left, a perfect case for a “while” loop. So, in the case of a game loop, which one do you think we should use? A ‘for’ loop or a ‘while’ loop? Yes, a ‘while’ loop! Remember, we want to let the user take a guess again and again until he/she wins or loses, another perfect cast for a ‘while’ loop! So let’s beginning writing some code. 

* A ‘while’ loop always starts with keyword “while”. Ok, what follows next? Yes, it should be a condition that can be either True or False, if it is True, we run the code inside the loop; otherwise, we stop the loop and jump out. So what condition should we have here? Well, we know that the game stops when user wins or loses, in which case, we no longer need to ask for any more guesses. So when should we continue to run the ‘while’ loop then? Yes, when the user has neither won or lost the game. But how to translate this condition into Python code? Well, we don’t know yet. In fact, when it comes to a game loop, it’s often the case that you can’t fully write down the condition for the ‘while’ loop at the beginning. The conditions become clearer as you start writing code for the “game logic”. In this case, what we can do is just to have the “True” value as the condition for the ‘while’ loop. Ok, I know this looks strange, so let me explain. Usually, you would have a condition here that gives you either a True or a False value, right? And the ‘while’ will decide whether to continue or not depending on this value: True to continue and False to stop. Now think about this, what would happen if I put the “True” value as the condition here? Yes, this means the condition is always True, and if it is always True, then the “while” will always run and never stops! Essentially what do we have here? Yes, if you have learnt Scratch before, you must be pretty familiar with the “forever” loop block, right? What does that loop does? Yes, it just runs the code blocks inside again and again, forever, never stops! So with this “Ture” value as a condition here, we have essentially create a forever loop in Python! The loops just runs the code inside forever, never stops! Well, to be honest, it will stop eventually as we will see later. So this is it, this what a “game loop” looks like, it is often a forever loop with a “True” value as its condition! This is also sometimes called an “infinite loop” in Python. 

* By the way, since we have just finished the loop header without its body, Python is not happy and gives us a red squiggly line saying: “Hey, you have forgotten to add code inside the loop!” Of course, we have not forgotten about it, it is just empty for the time being. But still, this red squiggly line can be annoying sometimes. This can happen in other cases as well. For example, when you define a function, if you just wrote down the function header without its body, you have the same squiggly line. So to keep Python shut up, we can just say “Ok, I know this is empty now, but I will add code later, I promise!” And the way you say it in Python is to write a “pass” statement like this. This is a placeholder for any future code. It won’t anything at all and is just there to keep Python happy so that it won’t complain anymore. 

* Now, with code now being correct, let’s do a small experiment. What if I print “End of game” after the “while” loop? What do you think is going to happen if I run the programs now? Shall we try?

* Test. Ok, we see the secret word and the answer being printed out, but unlike before, we never see the message “End of game”  and the next prompt again. Looks like the program is still running!  Why is that? Yes, because we have a forever game loop here. It runs forever! So our program just gets stuck in this infinite loop, running it again and again, but never jumps out of it. So we will never get the chance to reach the final print here. So hopefully, this small example makes it even more clear to you what a forever loop really means. Cool! This print is just for demonstration, we don’t need it in the final program, so let’s just delete it.  |
| Forever game loop body - show info and ask for input | * Ok, the loop header is done, time to move on to its body to write some game logic. Each time before we ask the user to guess a letter, we want to first print out what the current answer is and the number of attempts left. This makes it very clear to people how they have been doing so far and how many more times they can try. So let’s do those first!

* They are pretty simple, we already know how to print the “answer” list, so we can just copy the ‘print’ here any put it inside the ‘while’ loop. Remember to add the indentation at the beginning. Now, we do not need to print answer at the beginning anymore, so let’s just delete this one here. Also, since we now have actual code inside the “while” loop, we no longer need the “pass” statement to keep Python happy, so let’s delete that too! Ok, that’s the first print done. Now the second one is to tell how many attempts are left, so, we call ‘print’ again. The message we want to print is something like “Attempts left: ” and then the actual number of attempts. So there is another a string mixing the string “Attempts left:” and variable “attempts_left”. Time to use what we have just learnt: the f-string. So in the ‘print’ function call, we pass an f-string that starts with letter “f” and a pair of quotes. Inside the quotes, first type in “Attempts left:”, then to insert the variable, let’s add a pair of curly brackets and in the curly brackets, add variable “attempts_left”.  Ok, let’s test this code!

* Test. Wooo…the program prints the current answer and then message “Attempts left: 9” again and again, never stops. Well, this is not difficult to understand, because both prints are inside a forever loop, that will just run them again and again. Ok, everything as expected, nothing is wrong here! Cool!

* OK, next, we want to ask the user to type in a guess, this can be either a letter or the entire word. Again, nothing too hard here, all we need is just to call the ‘input’ function, and pass string “Guess a letter or the whole word:”. So it is going to prompt the user with this message and return whatever the user types in. Finally, we want to store the return value into a local variable for later use. I will call this “guess”. 

* Test. Let’s run the program again, this time, after printing the first two lines, it stops asking us to guess a letter or the whole word. I will just type in letter “t”, and hit return. Now, nothing is going to happen because we have no code after the ‘input’ function call. So loop repeats again, and the program asks for a guess again after printing the current answer and the number of attempts left. Cool. |
| Forever game loop body -  | * Right, once we have the user’s guess, we are finally ready to work on the most exciting stuffs: how to check if the guess is correct or not. 

* Let’s first think about what does it mean for a guess to be correct. There are two cases when the guess is considered correct: the first one is when it is a single character and that character actually occurs somewhere in the secret word. For example, if the secret word is “teeth” and the input letter is “t”, then this is correct guess, because letter “t” appears twice in “teeth”. The second one is when the guess is a whole word, in which case, it is correct if this word is exactly the same as the secret word. For all other cases, the guess is just wrong. And this is the basically decision logic here. 

* Now, we have arrived at a junction that can lead to three different paths. One path for when the guess is a single character and that character is in secret word, one path for when the guess is a whole word that is exactly the same as the secret word and a third path for all other cases. So in Python, how can you handle a situation like this? Yes! We have learnt about the “if…elif…else” statement in lesson “Secret Message”, and it is exactly for a situation like this! Each branch of the statement is going to handle a different case. So let’s see how this can be used here!

* Let’s deal with the first case first, when the input is a single character in the secret word! We start the statement with the ‘if’ keyword. Now, what should the condition be? Based on what we have just said, it seems that there are two parts about this condition: first the input should be a single character string and second, that single character should be in the secret word. Let’s look at both one by one.

* How do you know a string has just one character? Easy, we know how to find out the length of a string using the built-in “len” function, and if the length is exactly one, then it is a single-character string, right? So to check if “guess” has just one character, all we need to do is just type in <len(guess) == 1>. So first part done, easy. Now what about the second part: the character needs to be in the secret word? This essentially means if we can find a character is in a string. Hmmm…interesting and looks familiar? Maybe you already know where to find the answer? Yes, in lesson “Secret Message”, remember how we find each character of the message in the alphabet? Yes, we used the ‘find’ string method, right? And do you still remember what this method returns? Yes, it returns the index of the character in the string if it is found, otherwise, it return -1. Sounds like the perfect solution here! So we can write the second part of the condition as this: we call ‘find’ method on the secret word string and pass “guess” as argument to try to find it in the word. Then, we compare its return value with number -1 to see if they are not equal. Still remember how to check if two numbers are not equal? Yes, we use the “!=” symbol. And let’s finish the condition with a colon. Now as we have seen before, if you just leave the code empty for this “if statement”, Python is going to complain about it. So to keep its mouth shut, we just add a “pass” statement temporarily. 

* OK, but it looks like Python is still not happy here with this squiggly line under “secret_word”. If we ignore it, go ahead and run the code, Python throws out an SyntaxError. Unfortunately, this time, the error description is not very useful, it just says “invalid syntax”. Well, we already know that. So what went wrong after all? Looks like the error happened inside the “if” condition. As we can see, the condition has two parts, and each part is also a condition itself, right? We often call such parts “sub-conditions”, meaning they are conditions inside another condition. Now, when will the “if” condition becomes True? Well, it is True if the length of “guess” is one AND “guess” is inside the secret word. Now, let me say this again, the condition is True if the length of “guess” is one AND “guess” is inside the secret word. Do you hear the word I have been putting a lot of stress on on purpose? Yes, the word “AND”! So the condition is only true if its first part is True AND its second part is also True. But take a look at our code here, can you can see “AND” anywhere? If not, then how can Python know what you mean is the first sub-condition and the second sub-condition need to be both true?  |
| Logical operator | * So to really solve this program, we need to talk about “logical operators” in Python. So far in this course, we have seen different “arithmetic operators” being used all over the places. What? “arithmetic operators”? I don’t remember seeing any of those! Well, do let the name fool you, it’s pretty common and simple, remember in the Math Genius lesson, where our program did a bunch of operations on two numbers? What are those operations? Yes, addition, subtraction, multiplication and division, right? And the symbols we used for these operations are called “arithmetic operators”, that is the “+”, “-”, “/” and “*” symbols. 

* Ok, so what are “logical operators” then? Well, “arithmetic operators” work on number value, it could be integers or decimal numbers. Logical operators work on bool values. Still remember what bool values are? Yes, there are just two: True and False. And they are used to make decision in the code. So why do we need logical operators to work on bool values? Simple, because a lot of times, we want to combine multiple conditions to make more complex conditions, just like the case we have here. So what exactly are the logical operators? Well there are only three of them: “and”, “or” and “not”. 

* Ok, let’s leave Python for now and back to real life to truly understand what those three operators mean. And you will see that we actually use those all the time, just not being aware of it. Imagine you and your friend are planning a fun day out. But here are the three important rule that you have to stick to:
- First, you can go to the park if you have finished your homework AND your friend has also finished his/her homework. If even one of you hasn't finished, you can't go. That’s rule Number One.
- Rule number two, you can go to the zoo if either it's a weekend OR it is a holiday. But if it’s not a weekend and not a holiday, then you can’t go. 
- Last rule, if you only go out if it is NOT raining. If it's raining, you can’t go anywhere and have to stay at home. 

* Did you notice the interesting words in those rules? Yes, they are “AND”, “OR” and “NOT”. See? We have been using logical operators all the times in our life! So how do those rules can be translated into Python code? If you take a look at this lesson’s folder, there is another file called “logical_operators.py”. Let’s open it. Currently, the file has just one variable “go_out” with an initial bool value False, meaning don’t go out. Let’s see how to use these three operators.

* First, the ‘and’ operator. Let’s defined two variables “I_have_finished_howework” and “friend_has_finished_howework”. Now, rule one says we only go out if I have finished homework and my friend has finished homework too. So we first assign “True” to both variables, meaning me and my friend have both finished our homework. Next, we apply the ‘and’ operator to both variables. Just like you can apply the “+” operator to two number values, we can apply ‘and’ to two bool values. And we assign the result to variable “go_out”. After this, we print “go_out”. Finally, let’s add an “if…else…” statement. The condition is just “go_out”. So if “go_out” is True, we print “We can go out!”, else, we print “We have to stay home”.  Now, let’s run it. As you can see, it first prints out True, which is the value of variable “go_out”. And because the “if” condition is now True, “We can go out” is printed. I have finished homework and my friend has finished homework, so of course we can go out. In other words, if you apply “and” operator to two True values, the result is also going to be True. Now, let’s try a different case, what if I change the value of “I_have_finished_homework” to False, meaning I have not finished my homework yet. Do you think we can still go out? Let’s find out! Run the code and now, the value of variable “go_out” becomes False, so it takes the “else” branch and prints out “We have to stay home”. As you can see, when applying ‘and’ to a False and a True value, the result is going to be False. This is the same if we swap things around, so instead of me not finishing my homework, my friend has failed to finish his/her homework this time. Now, if we run the code again, the output is the same, because we are still applying “and” to a True value and a False value, just in a different order. It’s like when you add two numbers 1 and 2, the result is always going to be 3, doesn’t matter whether it’s 1+2 or 2+1. Now, it’s the final case, also the worse case, I have not finished my homework and my friend has not finished his/her homework either. What do you think the result is going to be this time! Yes, without even running it, I’m pretty sure we are going to stay at home. But let’s just confirm that. Yes, indeed, “go_out” is False and we stay home. So we have seen four different cases of applying “and” to two different bool values and their results. Actually, these are the only four cases you can have for two bool variables. And here is what we have found: when using “and” with two bool values, the result is only True if both values are True. Otherwise, the result is False. If there is anything I want you to remember from this small example, it is this one. 

* Ok, next the “or” operator. Remember the second rule, we go out if either it’s weekend or it’s a holiday. So let’s define another two variables: “weekend” and “holiday”. Assign value True to both variables, meaning it is weekend and it is a holiday. Now, the rest of the code is going to be very similar to the previous “and” example, so let’s just copy that and paste it here. Of course, we need to change the operator here to “or”, and replace these two variables with “weekend” and “holiday”. And the rest stays the same. So what do you think the result is going to be? Yeah, I think we can go out. Let’s run this, and yes, variable “go_out” has value True and it prints “we can go out”. Now, let’s play the same game of changing the values of those two variables. First, we change “weekend” to False, meaning it’s not a weekend, but we leave “holiday” to True still, meaning it is a holiday. What do you think this time? Go out or not? Let’s find out. Yes, we can still go out? Why? Well, remember, we can go out if it is a weekend or it is a holiday. Now, it is not a weekend, but it is a holiday. So of course, we can go out! Again, what if I swap the two values, so, it is a weekend, but not a holiday? Yeah, I think we can still go out! Let’s confirm that. Yep! As expected! Note that this is different from the “and” operator. In that case, if one sub-condition is False, the entire condition is False, whereas for “or”, if only one sub-condition is False then the entire condition is still True. So when the will the entire condition becomes False? Well, what if it is not a weekend and not a holiday, so both variables are False. Do you still think we can go out? No, right? Let’s confirm that. Yep, this time, the value of variable “go_out” is False and we have to stay home. Again, we have seen four different cases of applying “or” to two different bool values and their results. And here is what we have found: when using “or” with two bool values, the result is True if at least one value is True. Otherwise, the result is False. If there is anything I want you to remember from this small example, it is this one. 

* Right, finally, the “not” operator. Let’s first think about when you normally use the word “not”. It’s often used when you want to say the opposite of something, right? So if I have a sentence like “this is correct”, and adding “not” to it becomes “this is not correct”, which means the opposite of correct, wrong. So third rule says, we go out if it is NOT raining. This means the weather could be cloudy or sunny, as long as it is not raining. So this time, let’s define a single variable “raining” and assign True to it, meaning it is raining. Again we just copy the rest of the code from previous example and paste it here. This time we are going to use the “not” operator. Now, unlike “and” or “or” operators, which need two bool values, the “not” operator is only applied to one bool value. So we can write <not raining> and assign the result to “go_out”. This also not difficult to understand, if “raining” is True, then NOT “raining” gives you the opposite of True, which is False; if “raining” is False, then this gives you the opposite of False, which is True. Now, “raining” is True at the moment, so do you think we can go out? Of course not. Let’s confirm this. Now, as you can see, the value of “go_out”, after applying the “not” operator to variable “raining”, is False. Because this is False, so we take the “else” branch and print out “We have to stay home”. Now, what if I change the value of “raining” to False. We can go out this time, right? Again, let’s confirm that. So this time, the value of “go_out” is True, after applying the “not” operator to variable “raining”. So we take the “if” branch this time and it prints out “We can go out!” Pretty cool, huh? So this “not” operator just turns whatever is True to False and whatever is False to True. It’s probably the simplest operator of all three.

* Before we finish our discussion, one thing I want to mention is that, I created this “go_out” variable for each example here because it just makes it clear what the value of the entire condition is after applying one of the three logical operators. But in real program, this is often unnecessary and we normal don’t create such variable. Instead, we tend to write the entire condition in the “if” statement directly. And we will be doing this in the future.  |
| Input guess - single character | * Now, with a much better understanding of logical operators, it’s time to get back to our program. As we have discussed before, the first case for the guess is a single character. To check if this is the case, its length must be one AND it can also be found inside the secret word. Earlier, we have already had these two sub-condition written down in the “if” statement, but was getting a SyntaxError. Now, we understand why. This is because, to create a more complex condition from sub-conditions, we need to use one of the three logical operators. So which one should we use here? Yes, the “and” operator. Because this is only a single character if its length is one AND it is in the secret word. So the solution is pretty obvious: all we need to do is just add the operator “and” between these two sub-conditions. Now the squiggly line is gone, Python is happy again. 

* To check if this works, let’s replace the “pass” statement with a print that prints “Guess a single character in secret word”. Run the program. The secret word is “plane”, so I’m gonna type in letter “a”, which is in the “plane”. There you go, it prints “Guess a single character in secret word” and then enter the next loop iteration asking for more guesses. On the other hand, if I type in a letter that is no in the secret word, for example “x”, then it does not prints the message. Why do you think so? Yes, because then the letter is not in the secret word, this second sub-condition is going to be False, right? Because the result of the “find” method is -1. And because we know that when two sub-conditions are ANDed together, the final result is going to be False if either of them is False. Since the entire “if” condition is False, the code inside is not going to be run. Now, what if I type in a multi-letter word, for example, “abcde”? What do you think this time? Yes, with this guess, the first sub-condition is clearly False, because the length is obviously not one. Furthermore, the second sub-condition is also False, because string “abcde” is clearly not in the word “plane”. So if both sub-conditions are False, then surely the entire condition is also False. So again, the print is not going to be run. Cool, looks like our code works!

* Now, we need to think about what to do if this is indeed a single letter in the secret word. In the demonstration, we have seen that, in such case, the letters in the answer that match the guess are revealed. So they actually turn into that letter instead of being hidden as a star. This is what we are going to do next.  

* So how are we going to do it? Any idea? Ok, we want to go through each letter of the secret word one by one, each time checking if the letter is the same as the guess. If it is, now here is the important bit, we need to change a star in the answer to the guessed letter. But which star? Well, remember, the answer has the same length as the secret word, right? So if the match happens for a letter at index i in the secret word, we want to change the star also at index i in answer to the guessed letter. So for example, for the word “plane”, if the guessed letter is “n”, since “n” is in “plane” at index 3, so we want to change the star at index 3 in ”answer” to “n”. After this, the answer list is going to become “***n*”. All good? 

* Now, we have already learnt how to go through all characters of a string in lesson Secret Message. Can anyone remind us all how to do it? Yes, we use the “for” loop. So “for”, then the loop variable, which I’m gonna call it “character”, then the keyword “in”, and finally the source of values for “character”, which is just the “secret_word”, and colon. Now, this is the loop header for iterating all characters of a string. Next, inside the loop, we want to check if the current character is the same as the guessed letter, so that we can update the “answer” list. This is simple, we just need an “if” statement, and the condition we want to check is whether “character” is equal to “guess”. If so, it’s time to update “answer” inside the “if” statement. Earlier in the lesson, we have already seen how to change an item in a list: all we need to do is use an index to locate the item you want to change and then assign a new value to it. So the list here is “answer”, and to get the item to replace, we need to index it, this means adding a pair of square brackets. For the index, let’s leave it for now and I will come back to it later. Then we just assign a new value to this. So, what is the new value? Well, it’s the guessed letter. So we assign variable “guess” to it.

* Now, it’s time think about the index? What should that be and how can we get it? Well, remember the “plane” example? If the guessed letter is “n”, it’s at index 3 in “plane” right? And we want to change the star also at index 3 in the answer to letter “n”. This means the index we used for “answer” here is the same as the index of that letter in the secret word. And all we need to do is just to find that index. So given a character and a word, how can you find its index? Simple, actually, we did that already in the “if” condition, right? The “find” method, right here. When call on a string with a character, it returns that character’s index in the string. So inside the square brackets here, where an index is needed, we can just call “find” method on the secret word and pass “character” to it. This is like asking for the index of letter “n” in word “plane”, in which case, 3 is returned. And we use 3 as index to get the fourth star in the “answer” list, and change it to letter “n”. Right, pretty cool but does it work? Let’s find out!

* Test. Run the code, this time the secret word is “pizza”. So let me type in letter “i”, which is the second letter. And hit return. Now see, the second star in the “answer” list is also changed to “i”. Awesome! So how about letter “z”, which occurs twice in the word. Hit return, and….Ouch! We have a bug here! The word “pizza” has letter “z” in two places, the third and fourth character. However, in the updated “answer”, we only see the third star being changed to “z”, but not the fourth one. This does not look right! So what is going on here? Can anyone be a detective and tell me what is the culprit? 

* Ok, let’s trace through the code together. After we typed in letter “z”, it satisfies this “if” condition here, and we run the ‘for’ loop. The first two letters of “pizza” are “p” and “i”, none of which is equal to the guessed letter “z”, so this “if” statement in the loop is not run. Now, the third letter is indeed “z” and equal to the guessed letter, so we are going to update the answer list. Which star are we going to change? Well, it depends on what this “find” method returns here: It searches the word “pizza” looking for letter “z”. Did it find the letter? Yes! And where is it? It is the third letter at index 2. So 2 is the index we use here for the answer list, and as a result, the third star at index 2 is changed to letter “z”. Cool, so far so good, right? Now, the ‘for’ loop moves onto the next character in the secret word, which is also letter “z”. Now, the same code repeats all over again: is “character” equal to “guess”, yes, they are letter “z”, so which star should we update in the answer list? well depends on what the “find” method returns here? Can it find “z” in “pizza”? Sure! But, which “z”? There are two “z”s in the word “pizza”, and previously we have seen that index of the first “z” is returned, which is 2. But which one this time? You might want to say: well, of course this time it is going to be the second “z” letter at index 3, right? Are you sure? Does the “find” method tells you that? Ok, all of you look pretty confused at the moment. So let’s bring up the web page for the “find” method and see what it says. Ok, it says, “The find() methods finds the first occurrence of the specified value.” Do you see the word FIRST here? What does that mean? Yes, it means if there are more than one occurrences of the letter you are looking for, “find” always returns the index of the first occurrence. For example, the word “pizza” has two letters “z”, one at index 2 and one at index 3. Now if you try to find “z” using the “find” method, it always returns index 2, doesn’t matter how many times you call it, because this is the first occurrence of “z” in the word. So putting our detective hat back on, the second time we see letter “z” in “pizza”, the “find” method still returns index 2. As a result, we change the third item in the “answer” list again to “z”. Essentially, we are assigning “z” to it twice, but never change its fourth item. That’s why, after guessing the letter “z”, you only see one showing up in the “answer”. So what is the solution then? Well there are ways to get around it, but they are unnecessarily complex and  there is actually a much simpler way. 

* Now, in lesson Secret Message, I have actually shown you two different approaches to go through each character of a string, the one we used here is actually the second approach. Does anyone still remember the first approach? Yes, we can have the ‘for’ to go through the index range of the word instead. So rather than having a character as the loop variable that gets assigned each letter of the secret word, we have an integer as the loop variable that gets assigned each index of the secret word. So, without deleting the current “for” loop, let’s create another one below so that we can compare both of them. This time, the loop variable is going to be called “index” and its values are coming from the range of all valid indices of the secret word. So we call the “range” function and pass the length of the secret word as argument. And this is it, this is the loop header. So you might be wondering, what is it good for then? Well, bear with me as we will get there very soon! In the body of the ‘for’ loop, we still need to first check if the current character of the secret word is the same as “guess”. But this time, we need to use the index to get the current letter, the rest of the “if” condition remains the same. Now, take a look at this bit here in the first “for” loop, where we call ‘find’ on the secret word to get an index for the “answer” list. That’s quite complicated. Now, in the range based ‘for’ loop, since we already have the index in the loop variable, we can just use that to index the “answer” list, and then assign “guess” to it. Cool. This time, since the loop variable always increases one by one, we will never index the same item twice, and therefore never assign the “guess” twice to the same item in “answer” list. Hopefully this should fix our bug! Before we test it, let’s remove the first ‘for’ loop as it is no longer needed.

* Test. Ok, let’s test the code. But here is a small problem: previously we found a bug when the secret word is “pizza”, right? This is because it has two identical letters. But we have no control of which secret word is going to show up each time we run the program. Remember, the secret is picked random from a list. So to test our code here, we want the secret word to be “pizza” and nothing else. So we are going to comment out “choice” here and assign “pizza” to variable “secret_word” temporarily, just for testing. Right, let’s run it, type in letter “z”, and hit return. And there you go, both letters are revealed in the answer. Perfect! The bug has been fixed. Now once this is done, remember to uncomment out the “choice” and delete the next line.

* Before, we continue on, there is one thing I want to point out. If you take a look at this “if” statement here, you can see that have a ‘for’ loop inside. And inside that ‘for’ loop, we have another ‘if’ statement. So in Python, you are free to mix and match the statements such as “if” and “for” loop. They can be nested inside each other, and you can go as deep as you can. So if you really want, you can have 10 ‘if’ statement, one inside another, so 10 levels deep. But of course, code like this is not very common and it’s usually considered bad practice. Again, just because you can do it, does not mean you should do it. But sometimes, knowing that you can make nested statements is very important, as we can see here. |
| Input guess - entire word | * Ok, now we can handle a guess that is a single letter. As I said, we are at a junction with three paths: we have already taken the first one and figured out what it looks like. Time for the second path! Remember what that one is? Yes, it is the case when the “guess” is a whole word that matches the secret word. This is needed because as more and more letters are revealed in the answer, we starting to get a better idea about what the final word is, so at some point, might just decide to not continue letter by letter, but instead spelling out the entire word in one go. So let’s see how to write the code for it.

* First, how can turn a junction with more than two paths into Python code? Yes, we use the “if…elif…else” statement. We already have the “if” statement, now it’s time for the “elif” statement. Type in “elif”, make sure it has the same indentation as this “if” statement here. An “elif” statement also needs a condition. Let’s think about what the condition should be. Fortunately, this is actually simpler than the condition of “if” statement. We only want to check if the “guess” is an entire word that is the same as the secret word. So it’s just checking if two string are equal to each other, right? We have done this so many times, I can even write it with my eyes closed: <guess == secret_word>, and don’t forget the colon. That is it! 

* Now, what should we do if this condition is True, meaning the user has guessed the secret word correctly? Well, we want to congratulate the user for his/her accomplishment, right? So let’s print a message such as “You won! The secret word was: pizza”. We are going to practice using the f-string again! So first call function “print”. To pass an f-string, start it with letter “f” and then a pair of empty brackets. Now, type the message, “You won! The secret word was: ”, now, here is where f-string shines, we need the actual secret word here, so a pair of curly brackets, then add the variable “secret_word” inside. This is it, this is the message we print to user if he/she wins the game. Let’s test this!

* Test. OK, this time, the word is “teeth”, so let me guess letter “h” first, yep, the last star of answer is changed to “h”. Then let me guess letter “t”, aha, we have “t * * th” now. Ok, I think at the point, I know that the word is: it’s teeth! So let me type the entire word, teeth. OK, it prints a message “You won! The secret word was teeth!” That’s great! But what is not so great is that the program just continues and ask us for the next guess. But we have just won the game! It should be done, no more guesses! So why is this happening?

* Yes, it’s because of this game loop! Remember, it is a ‘while’ loop with a always True condition, meaning it is just going to run again and again, like a forever loop. So how is it going to end then? It must end somehow, right? For example, here, when the user gets the word correctly, the game loop should end, right? Yes, absolutely! Unlike some loops which we know how many times to iterate, such as going through a list, with a game loop, it’s often the code inside, or the game logic, that decides when the loop or the game should end. But how? How can we jump out of the game loop when the user has won? Well, well, well, this should not be new to you! Anyone? Yes, in the last lesson, when there are no more students to pick from, we end the ‘while’ loop using the “break” statement. And so, why not use that again here? If the user has won, we can just break out of this game loop. So let’s add “break” after the print. Now test it again!

* Test. Ok, this time the secret word is “pizza”, I will just save us some time and type in “pizza” directly, so I will win game after my first attempt! There you go! We saw the same congratulation message, followed by the “End of game” message. This just shows the “break” statement ends the loop immediately, and the program continues with whatever code that is after the game loop, which is just printing “End of game”! 
It did not ask us for more inputs! Cool! Bug fixed! |
| Input guess - failed attempt | * OK, so we have finished the code for the twos cases where the user is correct in one way or another: they could either guess a single letter correctly or an entire word correctly. Now are there any more cases that can be considered correct? I don’t think so, I think these two are the only ones. So everything else, doesn’t matter what the user types in, are classified as incorrect. So they will all go to the third path at the junction. In terms of code, it is an “else” statement. So let’s add that. Type in “else”, again, make sure it has the same indentation as the “if” statement and the “elif” statement. 

* So what should we do when the user fails the current attempt? Well, first we want to print a message to let him/her know that the guess was wrong. This is easy, just print “Oops! You guessed it wrong! Try again!” Then, very important, remember we have the  “attempts_left” variable that keeps track of how many more chances the user has got left? Every time the user takes a wrong guess, he/she loses one chance, meaning we have to decrease “attmepts_left” by one. So we substract one from “attempts_left” and assign the result back to “attempts_left”. Like increasing variable’s value by some number, we can simplify this by just using <attempts_left -= 1>. This has the same meaning, decrease the value in “attempts_left” and assign the result back to the same variable. Ok, let test this!

* Test. This time I’m gonna make wrong guesses on purpose. So the word is “shirt”. To make things simple, I’m just gonna guess letter “x” each time, which is not in the secret word at all. So “x”, ok, I got it wrong and 8 attempts left. “x” again, 7 attempts left, and so on: 6, 5, 4, 3, 2, 1… and finally 0 attempts left. But here is the problem: We have 0 attempts left, meaning no more chances. Essentially, we lose and the game should end. But look what happened? The program still ask us for more guesses. This is clearly wrong. So this problem is actually very similar to what happened with the winning case in the “elif” statement: the loop is not sopped when it should be. 

* By now, we should already know what the solution is, right? Yes, breaking out of the loop using the “break” statement. So let’s add that after changing the “attempts_left” variable. Do you think this would fix the bug? Maybe, because that’s what we did for the winning case, right? So, let’s find out! 

* Test. Ok, this time the word is “plane”. I’m gonna guess “x” again. Wowowow, what is happening? I only guessed it wrong once, but the game ends! Even though it still encourages me to try again! What is going on here? 

* To understand why, let get back to the code. We I made a wrong guess the first time, the “else” statement is run, we already know that. Now it prints a message and reduces “attempts_left”. by one Then what does it do? Yes, it runs “break” and jumps out of the loop! So, just after one failed attempt, the game loop is stopped and the whole game ends! So, what should we do? Well, the problem here is that, in the “else” statement, we do not even look at how many more chances the user has got left, as long as one guess is wrong, we end the loop. What we should really do instead is, before breaking out from the game loop, check if “attempts_left” has actually becomes 0. If so, the user has run out of all chances, and this is when it’s time to end the game! So, the fix is pretty simple, we just need to add another “if” statement here, and we check if “attempts_left” is equal to 0. And we only break is this is True, meaning the “break” statement is now going to be moved inside the “if” statement. Furthermore, just like when the user wins the game, we also want to print a message such as “You lost! The secret word was XYZ”. This almost the same as the winning message, so I will just copy that line and paste it here before we break and end the game. I just need to change the word form “won” to “lost”. That’s it! Let’s test this.

* Test. The word is “shirt” this time, again, I’m gonna take the wrong guess 9 times in a row, until we have only one chance left. Now see what happens if I get it wrong again! Hooray! It prints the losing message, breaks out of the loop and the game ends. But there is a slight problem here. Notice that before the games and after I have made the final wrong guess, it still prints out the message “Oops! You guessed it wrong! Try again!”. Now, this is not a huge problem, but it is still a bit strange that the program asks you to try and again and then immediately stops the game because you lose. How can we fix this? 

* Let’s think about it, when should the program asks the user to try again? Yes, when he/she still have more chances left. If there is not more attempts, then there is no point in saying that, right? But is our code doing that? Let’s find out. The print for that message is here, this is very similar to the problem we have with the “break” statement before, it just prints the retry message without even looking at whether there are more attempts left. Instead, it should only print this if there are still attempts left. When do we know there are still attempts left? Yes, when “attempts_left” variable is not 0. Ok, here is the thing, we are checking if “attempts_left” is 0 here in the “if” statement. What if this condition is False? Well, it’s False when “attempts_left” is not 0. And what do we want to do in that case? Yes, we print the retry message! So the fix is pretty simple then: we just need to add an “else” statement here, and then move this print function call inside. So it is only printed when there are still attempts left. Let’s see if this works!

* Test. Ok, the word is “plane” and again I keep making wrong guesses. Now, we have one more chance left, and… Yes! The program just prints the losing message. But this time, there is no more retry message! Perfect!  |
| Reading words from file |  * Ok, so the game is pretty much done now: we can make guesses, a single letter at a time or the entire word if we are ambitious. And if we make a wrong guess, we lose one chance. The goal is to guess the correct secret word before our chances run out and preferably, using the least number of attempts. Pretty cool game!

* But before we call it a day, there is one more important thing I want to teach you guys. So far in all the programs we have written, the data we used are either coming from user input in a prompt or directly created inside the program itself. For example, in Math Genius, we take in both numbers from user; in Pick Your Team, we created all the students as a global list variable. Now, there is nothing wrong with that, and in fact, these are the two most common ways to get data. But there are also problems. If the data is coming from user input and assuming that it’s not going to change each time, then the user has to type in the same thing again and again each time the program is run. That will be very inconvenient. If the data is inside the code, then each time we want to update the data, we have to open up the program and change the code there. For example, here, if I want to add more secret words, then I have to open the script file and add the new words to list “words”. Now, it’s ok in this case, we can just go in and make that change. But quite often, the person who writes the program is not the same as the the person whos uses it. And whoever writes the code might not want anyone to change it for various reasons. So in this case, we are the person who creates this word game, but if we give it to a friend to play with it, we don’t want them to mess around with the code, because this might cause all sorts of trouble. If they can’t change the code themselves, then what should they do if they want to make the game more interesting, such as adding more words or make the words longer? Well, since they can change it directly in the code, the best thing they can do is to ask us to change it for them. Now, it’s ok for us to do this favor if it is just one or two friends. Yeah, sure. But what if your game becomes super popular and there are thousands or even tens of thousands of people who love to play with it and have their own secret words? What if they all come to you for that favor? I don’t think you would have the time to do it at all! So there should be a different way for a program to get its data from. 

* Now, let’s step away from Python for now and think about the Microsoft Word program. Has everybody used that program before? Yes, we all use that at some point to write something, a story, an article or just for fun. Now, say you want to write an article with Words, you start from the beginning and make some pretty good progress. After several hours, you are halfway through and start to feel a bit tired. You decide to call it a day and continue with the rest tomorrow. Now, what do you with this half-done article? Well, if you just close the program now, you lose all your hard work, right? So tomorrow you have to start all over again, what a waste of time! And if you cannot finish it tomorrow either, you have lose the work again and start from the beginning one more time the day after tomorrow! Imagine how frustrating this can be! This is just like asking the user to type in the same data again and again. Fortunately, this is most likely not going to happen, because Word gives you the option to save your work before quitting the program. The saved work is then going to be a file store in your computer somewhere. The next day when you want to continue working on it, just open the file in Word again, you still have the first half of the article from yesterday, and can just continue working on the rest. Also, we, as the users of Microsoft Word, can change our article in whichever way we want, save it to file and open it from file any number of times, without ever needing to ask Microsoft to change the Word program for us. 

* So this is essentially the third important way for a program to get its data from: files. Files are just data stored on your computer, such as our article. To use it, you need to “read” it from the file. “Read” here simply means opening the file and retrieving its content. When your program is done with the data, you often want to save it back to the file on the computer again for later use. Opposite to “reading” from a file, we often call this “writing” to a file. 

* Ok, back to Python. So to let the user of our game have total freedom of what secret words they want to have without ever needing to change the code itself, we want to have the list of words in an file instead. If you take a look at this lesson’s folder, you would see a third file called “words.txt”. Unlike our Python file with a “py” extension, this file has a “txt” extension, short for “text”. So it’s just a simple text file. Open it and you will see a list of secret words. Each word is in a separate line and there are also no quotes around them. 

* Ok, our task next is to read all the words from this file into our program. Imagine trying to take something out of a box that is all sealed up, what do you do first? Yes, you first open the box. Same with a file, if you need the data inside, you first open it. But how? Well, Python have you covered: there is a built-in function called “open” to open a file. Here is a web page for this function, if you take a look at the example, first thing you notice is that two string arguments are needed. So the first one kind of obvious, looks like it is just the name of the file you want to open. The second one looks a bit strange, in the example, it’s just a single letter “r”. What does that mean? Now, if you scroll down the page and take a look at the Parameters section, it tells what are the parameters and what each one is for. So here you can see that the first parameter is called “file”, and it is used to pass the name of the file to be opened, simple. The second on is called “mode”, and it basically means what do you want to open the file for. As you can see, there are a few different options here: we letter “r” means we want to read from the file. Of course, there are other options to append, write and create a file. We are not going to need those for this lesson so just ignore them for now. One final thing to notice from this example is that, the “open” function actually returns a value. Now, this value is not a number or a string or a bool. It’s a file object. Now, you don’t have to worry too much about what a file object is, because it is beyond the scope of this lesson, actually it is even beyond the scope of this entire basic Python course. Just remember to store that return file object in a variable, because we are going to need this when actually trying to read from the open file. 

* OK, back to our code. First at the top of the program, let’s first open the file “words.txt”. So calling function “open”, pass the file name as the first argument (TODO: here we actually need to pass the path to the file in VS Code. But since this lesson is supposed to be taught with Replit, we need to figure out how the pass the path there), and because we just want to read the file, pass string “r” as the second argument. And assign the return value to a variable called “file”. Ok, the file open, now what to do next. Yes, just like we can take out the stuff in a box once it is open, we can start reading the data from a file once it is open. But how? Well, remember I said that the return value from “open” function is a file object. Well, there is a web page for all the methods you can call on a file object. Similar to all the functions you can call on a string. And the page is here. Now, see if you can find the method we need. Yes, it’s the ‘read’ methods! Its description makes it very clear what this method does: it returns the file content. Also, if you take a look at the page for this method, you will see that it does not take any arguments. So we can just call it on the file object with a pair of empty brackets. Then assign the return file content into a variable called “content”. Now let’s see if the content contains the list of secret words by printing it out. Let’s run the program.

* Test. Cool, now we can see all the words from the file being printed. Looks like variable “content” now does contain the content of our file. But here is a problem, this content is now just a big string with 5 lines, each line contains a single word. But what we actually need is 5 individual word strings so that we can store them in a list. So how can we split this big string with 5 lines into 5 individual words? Well, is this an operation on a string? Yes, of course! So where do you think we can find the solution? Yes, the string method page! Let’s open that up! Now, can you find a method that might be useful here? Any findings? Yes, there is a method called “splitlines” and see that its description says? “Splits the string at line breaks and returns a list" Ok, looks like it is going to split a string with multiple lines and turn them into a list! Let’s try that! Call ‘splitlines’ on the “content” variable and because the method also takes no arguments, so just a pair of empty brackets. Now the result should be a list with each item being a single line in the content. And because each single line here is just a word, so this result should be a list of words! Let’s assign that to a variable called “lines” and print it out. Ok, if everything goes according to plan, we should see a list of 5 words being printed on the screen. Let’s see if this is the case!

* Test. Run the program and there you go! We have a list of five words! And this list is exactly the same as our original word list! In other words, we now have a way to get all the secret words from an external file! And the good thing about this is, everything we want to add a new word, change an existing word, or remove a word, there is no need to change the Python code at all. We just need to change the “words.txt” file and the code will just read whatever its content is after the change. For example, if I now add a new word “apple” at the end, and run the code again. Now, see? The list “lines” now has 6 items with the last one being “apple”. And if I remove the word “plane” from the file, and run the program again, the list has 5 items again, and “plane” is gone. How cool is that! Now the user who plays our game can have whatever words they want by just changing the words file! Pretty cool! |
| Cleanup | * So before we can finally finish today’s lesson, let’s just clean up the code a little bit. 

* First, we do not need to print either the file content or the lines list. So let’s delete both. Next, the list “lines” now contains the words read from file and they are the same as those words in the “words” list. So we no longer need the “words” list in the code. Let’s delete that also. But now we need to change the name of “lines” back to “words” because the rest of the program still needs the “words” variable. The only difference is that words are now coming from a file instead. 

* Finally, there are two more prints that we want to get rid of. They are just there because it makes easier for us to understand what the code does when developing the game. But since now everything is done and shown to work, they are not necessary anymore. First is this one that prints the secret word at the beginning. When you challenge someone with the game, the last thing you want them to know, especially at the beginning of the game, is the secret word! So let’s remove that. And the second one is this last print here. It was added earlier just to show when a game loop is stopped. So it is also unnecessary now and can be removed. Cool!

* Now, everything is ready, it’s time to challenge your friends with the game to see who is the word master! |
|  |  |

### Exercise

- Can you go back to the code of previous lessons and see if you can use f-string there?
- Make the game more difficult by having longer words
- Can you make the better, maybe easier to understand by using user-defined functions?
-