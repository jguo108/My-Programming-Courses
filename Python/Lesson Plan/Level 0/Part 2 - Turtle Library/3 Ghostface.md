# 3 Ghostface

### Reference

### Code

### Key Points

- Turtle Module
    - Use gif images to create animation (add shapes and use them later on)
    - Use ‘ontimer’ to for event based programming
    - Draw half circle
    - Penup and fill together to draw shapes without border
- New modules
    - “time” module and “sleep” method
- Programming concepts
    - File paths
    - Use variables whenever possible
    - Event-based programming
    - Loops with even-based programming

| Steps | Notes |
| --- | --- |
| Introduction | * OK, welcome back to another Turtle Lesson, let’s keep the fun going! In the last lesson, we have learnt the basics about turtle module. We used to it to draw all sorts of different shapes, and we used those shapes to create an amazing piece of art that worth millions of dollars! That’s crazy!

* But we can make things even more exciting! Once you can draw pictures, you are start to make animations. An animation is just a sequence of pictures played one after the other very quickly. For example, like this. To the human eyes, it looks as if the character becomes alive! And this is way more interesting that a bunch of shapes that can’t move. 

* So, in today’s lesson, we are going to learnt about how to create animation using Turtle! More specifically, we are going to draw a cute little ghost like this one here and have it make all sorts of faces! We are going to apply what we have learnt in the last lesson about shapes to draw the main body of ghost. And then, I’m going to show you how to use a sequence of images to create the face animation here. There is going to be so much fun. I can’t wait and let’s begin! |
|  | * In turtle, when you want to draw a image more complex than just the basic shapes, it’s often a good idea to first figure out what are the components of the image. Doesn’t matter how complex the image might seem, it is still made up of basic shapes. If we can find out those basics shapes, then we can use them to compose the final image. So let’s first look at the Ghost image. 

* Don’t worry too much about the ghost’s face, because we are not going to use turtle to draw it. Instead, we have a sequence of images that we are going to use to animate the face. Let’s just focus on the head and body right now. Can can one tell me what basic shapes you have seen here? Yes, very good. So looks like the head here is a a half circle filled with some of white color; the body here is a square or a rectangle filled with the same color as the head. These two are easy to figure out. Then how about this wavy bit at the bottom? How do you think that is created? Yes, they are just 5 half circles, but this time, filled with color that is the same as the background, right? Cool, so we have broken this relative complex ghost into roughly three main parts: the half-circle head, the rectangle body, and the wavy bottom with 5 half-circles. Cool! Since we already know how to draw all these basic shapes, we can create the ghost step by step. Let’s do it! |
| Setting up window and pen | * First thing first, because we are going to use the turtle module, so always remember to import it at the beginning. Now, what do we need next? Where is the ghost gonna be shown? Yes, in a window! Let’s create one! Still remember how to do that? Yes, <window = turtle.Sreen()>. We call the special “Screen” function in the turtle module and it returns a Screen object for us that we store in a “window” variable. This will be the same for pretty much all our turtle ptojects. Next, what are we going to use to draw the ghost? Yes, a turtle, or a pen. Still remember how to do that? Yes, <pen = turtle.Turtle()>. Again, we call the special “Turtle” function in the turtle module and it returns a Turtle object for us that we store in a “pen” variable. Again, if you want to create a pen to draw anything, you would always need this line of code. Let’s test the code.

* Test. Aha, we have seen the window flash off the screen again! Still remember how to fix this? Yes, we need to call the “mainloop” method on “window” at the end. Run the code again and yes, the window stays open on the screen. So far, everything exactly the same as that in the last lesson. As we are going to see, the similarity will continue.

* Once we have a window and a pen, what do we do next? Yes, we set them all up! In the last lesson, we created two functions to setup them up. We are going to the same here. First, create a function called “setup_window”, what are the three most basic things we need to set for a window? Yes, title, size and color. Let’s do it one by one. We set the title by calling “title” method on the window and pass string “Ghost Face” to it. Next for the window size, I want this one to be a bit bigger, say 900 x 900. Also, remember we used variables to store the width and height in last lesson? This because these two values are needed to computer other values in the code, to make sure those values get updated automatically when the window size changes, it’s better to use variables. Although we are not sure if this will be the same case here, but using variables is the right thing to do in most cases. So let’s create “window_width” and “window_height” and assign 900 to both. Then in function “setup_windows”, we call “setup” method on the window and pass both variables as arguments. Finally, we need to pick a color for the background. Let’s open up the color web page, I want to pick a dark background color, and “gray10” looks good, so let’s call method “bgcolor” on the window and pass color string “gtay30” as argument. Finally, don’t forget to call “setup_window”. Let’s run the code.

* Test. OK, we have the right title, the size looks correct, and the background color looks good! Nice, a good start!

* Next, let’s create another function “setup_pen”. Let’s first take a look at how we set up a pen in the last lesson. First, we change the shape to “turtle”. We did that just because I want to show you the different shapes a turtle can have, such as arrow, square, and a turtle. But most of the time, what shape our pen has does not matter that much. So I will not change it here. Next one, we called “color” method to change the pen color. This is important, because it determines the color of everything drawn with that pen. So we need to set it here. What color do we need here? Well, we want to use the pen the draw the ghost, which has some sort white color. I found this color called “ivory”, which is white with a tint of yellow, so it’s not pure white. I personally think this looks better, so let’s set our pen with this. In the previous lesson, we also set the pen speed to as fast as possible by calling method “speed” and passed 0 to it. Here, we need this eventually because we don’t want to waste time watching the turtle slowly drawing everything. But as we are coding, it’s sometime better to slow down the turtle and be able to see the drawing process. So I will not set the speed to 0 here, for now. Finally, we also set the color mode to 255 because we were using RGB color at some point. I’m not so sure whether we need that in this lesson, I will also leave it. OK, the “setup_pen” method is a bit simpler in this lesson, we only set its color. Finally, let’s call it after “setup_window”. Let’s test it.

* Test. Ok, not a huge difference, we can only see that the pen, with an arrow shape, changes its color to “ivory”. 

* Ok, so the window and the pen are all setup. Note that, even though the code are not exactly the same as those in the previous lesson, but the pattern is pretty clear: first import the turtle, module, then create a window and a pen, keep the window open using “mainloop” method, finally create two functions to setup the window and the pen. In all our future lessons, we will be see similar pattern, and to save time in those lessons, I will just copy and paste the code here and only make change where it’s needed, for example, a different window size. 

* Ok, looks like it’s time to start drawing!  |
| Setting up code skeleton | * Ok, in all our previous projects, we often start writing code without thinking too much about how it should be organized better. Once we have a lot code, we start to think to ourselves, “Hmm, this is messy, let’s clean it up!”. So we create functions for this and that. For code that looks repeated, we create a function to reduce duplication etc etc. So it looks as if making your code better organized your is always an afterthought. Well, this is true to some extent. Because your code only gets messy or becomes repetitive when it grows big enough. So, this is true, I’m not gonna argue with that. But other times, you can envision what the code is about to do and organize it better from the very beginning. 

* For example, drawing a ghost, as we have identified at earlier, involves three main steps: draw the head, draw the body and draw the face. If the steps are so clear from the very start, there is no reason why we should not organize our code around that. This means, we can create three functions: “draw_head”, “draw_body” and “draw_face” even without knowing exactly how to do to draw them. So let’s do it!

* First, after “setup_pen”, let’s create a new function “draw_head” without any parameters. This is the one we are going to use to draw the ghost head. Of course, we have not figured out the details of how to draw a head now, so just leave the function body empty. But Python is not happy with that, because it’s always expecting some code in a function. What can we do here? Yes, we can use the “pass” statement as  a placeholder to tell Python “I will add code here later”. And we have a happy Python again! We can do the same for the remaining two steps: create two functions “draw_body” and “draw_face”. Make their body contain just the “pass” statement for now. 

* Now, we can call these three functions after calling “setup_pen” to draw the ghost. Well, of course, they are not going to do anything right now, we are just setting up the skeleton. Of course, we can take it a step further: all three function calls here together actually does just one thing, that is to draw a ghost. So we can create one more function called “draw_ghost” without any parameters, and then move these three functions calls inside “draw_ghost”. And finally, call “draw_ghost” after setting up the window and the pen. Ok, let’s run the code again.

* Test. Yep, no change at all.   |
| Draw head | * OK, the code skeleton is all setup, it’s time now to fill in the flesh! To draw the ghost successfully, we first need to figure out the exact locations of each part. Let’s start with the head.

*Let’s draw an x axis and a y axis for our window. This helps us the figure out where we should start to draw the head. The turtle should start somewhere here, in the upper right quadrant and draw a half circle counter-clockwise. So what is the exact coordinates of this starting point? Well, it depends on how wide and how high we want the head to be. Suppose we want to the head to be 400 pixels wide and 100 pixels high. It’s height is measured from the x axis to the point, which also equals to the y coordinate of the point. Because we want the ghost to center in the middle, the point’s x coordinate is the head’s width divided by 2, so 200. There you go, we have the location of this starting point at x 200 and y 100. We can move the pen before drawing the head. 

* Let’s define a few more variables. First, create a variable called “head_width” and assign 400 to it. Next, create an other variable called “head_height” and assign 100 to it. Now, let’s fill in the details for function “draw_head”. First, move the pen to the starting point for drawing the head. We already know how to that: just call method “goto” on the “pen” variable. For the x coordinate, we know that it’s just half of the head width, so we pass “head_width/2” as the first argument. For the y coordinate, it’s just the height of the head, so let’s pass “head_height” as the second argument. Cool. Let’s test this and see if the pen goes to the correct position.

* Test. Right, we can see that the pen did move to the right place. But there is a small problem: as it moved, it also drew a straight line behind. We don’t want that, right? What should we do? Yes, we lift the pen up by calling “penup” on the pen before moving it. Let’s test it again. Yep, this time, it moved without drawing anything. Perfect!

* Ok, what should we do next? Yeah, we should draw the head. So the head is half a circle. Ok, we do not know how to draw a half circle. But we do know how to draw a full circle, right? So let’s do that first. This is as simple as calling “circle” method on the pen variable and pass its radius. What is its radius? Yeah, it’s just half of the head width. So let’s pass “head_width/2” as the argument. Let’s run the code and see what it draws.

* Test. Ok, all right, it seems the pen moves the starting position and then moved in a circle. But there are a couple of issues. The most obvious one is that we don’t see the circle at all! We only saw the pen moved in a circle but none was actually drawn? What is going on here? Well, remember, we lifted the pen up before moving the pen to its starting position, right? Did we put it back down afterwards? No! So if the pen is not down, then how can anything be drawn? So the fix the simple, just call “pendown” before drawing the circle. Right, let’s test it again! 

* Test. Ok, we can see the circle now. That’s some progress. But the second problem is that this is just the outline of a circle, no color has been filled. How do we fill a shape with color? Yes, “begin_fill” and “end_fill” methods. Let’s call them before and after drawing the circle. Test again.

* Test. Right, there you go, we now have a big white circle! So the third problem is that this circle seems to be at the wrong place. We want it to be centered in the window, divided evenly by the y axis. So what went wrong here? When a pen draws a circle, it always goes counter-clockwise, starting from the direction it points to. What does that mean? Well, remember, all turtles point to the right by default when the program starts, right? Now, when such a turtle draws a circle, because it’s pointing right initial, it would go like that. And this is exactly what we have seen here. So to draw a circle like this, where it is centered in the middle, what change do you think we should make? Yes, we should just make the turtle point straight up at this starting point. Then when it goes counter-clockwise, the circle is going to be like this, which is exactly where we want it to be! So how do we turn a turtle from pointing right to pointing up?  Well, we have learn three different methods to turn a turtle, “setheading”, “left” and “right”. Here, both “setheading” and “left” would work. So I will just call “left” on the pen and pass 90 degrees to make it point straight up before drawing the circle. Let’s test this again! Now, as you can see, before the pen drew the circle, it changed its direction to point straight up. The the final circle is exactly where we want it to be. Cool!

* Ok, we have the circle now, it’s at the right position and has the right color. There is just a small problem: we actually want a half-circle rather than a fill-circle. How can we draw a half-circle then? Well, when we learnt the circle method in the previous lesson, there is one thing I did not tell you, that is the “circle” method can actually accept a second parameter apart from the its radius. This parameter tells the method how much of a circle to draw. And this is expressed using degrees. For example, a full circle has 360 degrees, right? So what if we pass the second argument 360 to the “circle” method here? Let’s find out!

* Test. Ok, it is exactly the same as before, we see a full white circle drawn at the same position. This is because it was already drawing a full circle before, so passing 360 does make any difference. Now, how many degrees does a half-circle has? Well, if it is half of a full circle, then its degree must be half of 360, which is 180, right? So, what do you think is gonna happen if I pass 180 to the “circle” method instead? Yes, it’s gonna draw a half circle! Am I sure, let’s run the code and find out! Aha, there you go, we have a half circle! Awesome! In fact, with this second parameter, you can draw a quarter of a circle by passing 90 degrees, of any fraction of a circle with the correct degrees! How cool is that!

* So there you go, we have finished drawing the first part of our ghost - the head! Time to move on to the body! |
| Draw body | * Before drawing the body, I want you to pay attention to where the pen is and what direction it is pointing after drawing the head: it’s on the other side of the circle and pointing straight down. So this is where we are going to start to draw the body. 

* The body is just a rectangle. The length of one side is already known, it’s the same as the head width. We just need to figure out the height. Actually, you can choose any height, to make the ghost higher or shorter, totally up to you. For me, I think a height of 400 looks good. So let’s create another variable call “body_height” and assign 400 to it. Because this height is the same as the head width, it is essentially a square!

* Now, we can finally start drawing: starting from where the pen is right now, move it forward  400 steps, turn left, move forward 400 steps, turn left again, move forward 400 steps, turn left one more time, move forward 400 steps. Simple huh? So let’s add the code to function “draw_body”.  Delete the “pass” statement. First, call “forward” on the pen and pass “body_height” as argument. Then turn left by calling “left” and pass 90 degrees as argument to face right. Next move forward again and pass “head_width” as argument this time. Then turn left 90 degrees again to face straight up. Now before we carry one, let’s think about the remaining steps to the draw the body: we move forward with “body_height” again, turn left 90 degrees, move forward “head_width” and finally turn left 90 degrees to face straight down. We are just repeating what is already here. Instead of copying and pasting these code here to do it all over again, we can use a “for” loop. So, “for”, we don’t need the loop variable here, so just use underscore, then “in”, because we want to repeat twice, so “range(2)”. Then move these four lines of code inside this loop by indenting them properly. Right, this should draw the body! Let’s test it!

* Test. Ok, aha, looks like we have made the same mistake again! We forgot to fill the color in! Let’s fix that. We call “begin_fill” before the loop and “end_fill” after the loop. Let’s try again. Very cool, now it is starting to look like a ghost!

* But to complete the body, we still need to draw the wavy bottom! First let’s see what this is made up of. It looks like 5 equal size half circles side by side. If we can move the pen to the lower right corner of the body and then start drawing the half circles one after the other, from left to right, then we should be able to create this wavy bottom here right? Sounds reasonable. But to draw a half circle we also need to know its radius. What you think the radius should be? Or how can we find the radius? Well, we need to do some simple maths here: we already know that the width of the body is the same as the width of the head, which is 400, so the diameter of each of the half circle is 400/5, which equals to 80. And the radius is half of the diameter, that is 80/2, which is 40. So the radius is 40 for each of the half circle! Ok, we can starting drawing again!

* Let’s first move the pen to the lower right corner of the body. Right now, the pen is at the upper left corner, facing down. We can use the “goto” method, but need to do some math first to work out the coordinates of the lower right corner. I will leave this as a after class exercise for you. Here, I will just move the pen forward, the number of step is equal to “body_height”, then turn left, move forward again, this time the number of steps is equal to “head_width”. Then the pen is at the lower right corner. Of course, it is still facing right at the moment, this is similar to the case when drawing the ghost head, we need to make the pen face straight up first before drawing the half circles. Otherwise, they will all end up in the wrong place. So as a final step, we make the pen turn left. Ok, all sounds good? Let’s code this. 

* After drawing the body, let’s call “forward” on pen and pass “body_height” as argument. Then turn left 90 degrees, then move forward “head_width” number of steps. Then make a final left turn to get ready. Let’s test the code!

* Test. Ok, cool, everything works as expected. The pen is now at the lower right corner, facing straight up. We are ready to draw the bottom!

* Let’s draw the first half circle. This should be easy for you now, just call “circle” on pen and pass the radius, which is 40 based on our previous calculation, and the degree is 180. Also, as I have made this mistake so many times, I can now remember to put “begin_fill” and “end_fill” before and after drawing anything. Let’s run the code!

* Test. Ok, the pen seems to move and draw the half circle. But after that, we cannot see it anymore. Even worse, no half circle has been drawn at all! What is going on? Anyone? Yes, brilliant! So what color is our pen at the moment? It’s “ivory” right? Because we have not changed it since it’s been set at the very beginning of the program. So what do you think the color is for this new half circle? Yes, “ivory”. Now, here is the interesting bit: what is the color of the body? It’s also “ivory” the same color as the new half circle. So if you draw a shape on top of another bigger shape, do you think you would be able to see it? No, right? It needs to have a different color to be seen! So, in order to see this half circle, we need to change the pen’s color first! And what color do you think we should use? Any color other than “ivory”? Because we just want to make it different? Let’s try, let’s call the “color” method and pass “red” to it. Let’s run the code!

* Test. Right, the good news is that we do see a half circle now, so our drawing code is correct. But the bad news is that this red color looks super weird. To make it look as if we have actually cut a half circle out of the body, what color do you think we should really use? Yes, we should use the same color a the be background! What is the color of the background? Yes, it’s a very dark gray called “gray10”. So let’s pass that as argument instead. Test it again, and there you go, this time it looks much better! But if you take a look closely, there still seem to be something strange: there is a white line here that separates the half circle from the background. Ideally, we want them to blend with each other completely without any separation. So where does this white line come from and how can we remove it?

* Well, let’s answer the first question: where does the line come from? Well, remember, every time you draw a shape, the pen first draws the outline and then fills the shape with color right? So this line is actually part of the outline of the ghost body, because we draw a square first, right? Ok, now we know where it came from, so how to get rid of it? Well, what if we don’t draw the outline at all, would that solve our problem? Maybe. So here is a trick, we have seen that when drawing a shape with the pen up, nothing gets drawn, right? But that is only the case when we draw a shape without filling in any color. What if we do fill it with color ? For example, before drawing the square for the ghost body, let’s call “penup”. 

* Test. Run the code. Now, as you can see, when the pen is drawing the body, we only see it moving without drawing any line, because, well, the pen is up. But watch what happened after the outline has been drawn, it still fills the square with “ivory” color. So at the end, we still have a white square body. What is the difference now? Well, it is very clear after this little dark half circle is drawn: do you still see that white line underneath? No, it is gone! Why? Well, because we did not draw the outline of the square body! So our problem is magically solved! Isn’t that amazing! So this is something you should know and it can become useful at some point: if you don’t want a shape filled with color to have an outline, you can lift the pen up before drawing and filling it. Pretty nice trick!

* OK, so before, we move on to draw the other four half circles, there are a few small issues I want to address. First, we use radius 40 for the half circle because this is calculated from the “head_width”. But think about it, what if “head_width” changes? Does the radius of the half circle need to be changed as well? Sure! Once again, we have the situation of needing to update a value when something else it depends on changes. What is the best thing to do in this case? Yes, instead of using a fixed value 40 here, we compute it using “head_width” and we already know who to do that! Because we are going to draw 5 half circles, we first divide “head_width” by 5 to get the diameter. Then the radius is just half of that, so divide it again by 2. Let’s test this again!

* Test. Yes, everything still works as before, good!

* To see what the second issue is, let’s first change the background color to, maybe a lighter gray, say “gray50”. Let’s run the code.

* Test. Ok, the background is much lighter now. But wait, the half circle is still dark gray, and this no longer looks right, because we always want the color of the half circle to be the same as the background color. So what went wrong? Yes, because we forgot to change the pen color before drawing the half circle. So if we also change it to “gray50” and run the code again. Now, you can see, everything looks fine again. This is good but it exposes one problem with our code, whenever we change the background color, it is very likely that we would forget to change the color of the half circle. In that case, the ghost is not gong to look right. So what should we do? Yes, let’s create a variable for the background color! So I’m gonna create one called “background_color” and assign “gray50” to it. Now, when setting the background color in “setup_window” function, let’s pass variable “background_color” instead. Similarly, before drawing the half circle, we also pass variable “background_color” to the “color” method. Now let’s run it again.

* Test. Ok, when the background color is “gray50”, everything looks fine. Now, if I want to change the color to “gray10”, all I need to do is just to go to the top, and change the value here to “gray10”. And the window and half circle will automatically use this new color without being changed at all. Let’s test it again. Yep, the background becomes much darker again and things still look perfect! So, hopefully, this just shows you how important and useful a variable is. Especially when you want to use the same value in many different places, it’s always a good idea to create a variable for this value and use the variable instead in those places. This makes sure, when you choose a new value, all those places get updated automatically, you would not miss a single one!

* Finally, I want you to pay attention to what direction the pen is facing now. Yes, it’s facing straight down. Now, it I want to draw the next half circle to the left of the current one, do you think it would work if this is the direction to start with? Excellent! The answer is No! Where would the half circle be? Yes, it would just be underneath the current one, because it is going to draw like this. So, what should we do if we want to draw another to the left? Yes, let’s first make a 180 degree turn for the pen so that it faces straight up. How to do a 180-degree turn. Well, we could just call “left” or “right” method, doesn’t matter, and pass 180 degrees as argument. Let’s test this!

* Test. Now, as you can see, after drawing the first half circle, the pen made a 180-degree turn, to face straight up, ready for drawing the next one!

* Ok, so to draw the remaining 4 half circles, we can copy and paste these two lines of code 4 times. But you are a much more experience programmer now and should know a better way than this. Right? Yes, we can use a “for” loop to repeatedly drawing a half circle for a total of 5 times for us. So, after “begin_fill”, let’s add a “for” loop, loop variable is not needed again, so underscore, “in” and “rang(5)”. Now, just indent these two lines of code to move them inside the loop body. Let’s test it!

* Test. Now when the pen finished drawing the body, it then started to draw 5 consecutive half circles. And there you go, this is exactly what we want! Pretty nice and it is starting to look even more like a ghost now!

* Ok, before we move on to create the ghost face, let’s change one more time. As our drawing becomes more and more complex, it also takes longer and longer the watch the entire drawing process. This is useful when we want to check if the pen is moving the way we want. But since the code has already been shown to work perfectly, it’s time to make things faster and save some time. We have learnt in the previous lesson that you can change the speed of a turtle to as fast as possible by passing number 0 to its method “speed”. So let’s do that when setting up the pen. 

* Test. Now if we run it again, wow, see that, the picture was done in less than one second. This is so cool!

(TODO: do we need to show how to hide the turtle. Because it is not visible even we don’t hide it!) |
| Add a single face | * Ok, the head and the body are there, it’s time to make the face!

* For the face, we are going to do something different, instead of using the pen to draw it bit by bit, we are going to use an existing image for it. This will also show you how a turtle can be used other than just a pen. 

* First of all, if you go to this lesson’s folder, you will see a folder called “Resources”, open that up and you would see another folder inside called “Faces”. Keep opening it and you would see 43 images inside, each having a different face, numbered from 1 to 43. Ok, these are all the images we are going to use to create a face animation. But right now, we will see how to use a single image just to add a face to our ghost. 

* However, before that, I would like to talk about what turtles can be used for in Python. So far, in this and the last lessons, we have been creating turtle as pen to draw lines and shapes in the window. This is enough if all you want to do is just creating images and graphics that don’t move. But the turtle module is much more powerful than that! In fact, people have been using turtle for animations and even games! Yes, you hear me right, this simple looking thing can be used to create games! Can you believe that? Of course, we can’t create games, or at least those relatively complex ones, by just drawing lines and shapes. This leads to the second use of a turtle, as a Sprite! A very familiar word right? Yes, we have been playing and coding with sprites all the time in Scratch. What is a sprite? Yes, it is just an actor on the stage that you can control: you can move it, you can change its costumes, you can have it make some noise, etc etc. And this is the basic building block for any games. After all, a game is just a bunch of sprites interacting with each other, right? So, in the turtle module, a turtle can be used as a sprite too! Meaning you can control it the same way you did for sprites in Scratch! And once you know how to do that, you would become ready to build more complex animations and games! And that’s what we are going to do in the rest of this lesson and the rest of this course. We will be learning how to build and control a sprite in turtle so that we can create more interesting and complex games later on. So let’s begin right here, right now!

* Previously, we created a “pen” turtle to draw the head and the body. For the face, as I mentioned earlier, we are not going to draw it. Instead, we are going to create it as a Sprite. So, we need a new turtle. Let’s create one called “face” after the pen. Now, when we setup the skeleton for our code, we created a function call “draw_face”, right? But as we now know that a face is not actually drawn with a pen, but created as a sprite, I don’t think this function name is appropriate anymore. So, let’s rename it to “create_face”. Of course, we also need to change the call to “draw_face” and “draw_ghost” to “create_face”. Let’s run the code the and see what it looks like now.

* Test. Ok, after the head and body were drawn, we see a new turtle showing up in the center of the window. This is our new “face” turtle.

* Right, time to look at how to create a face. Previously, we have seen that we can choose a number of shapes for a turtle, such as “arrow” or “turtle” by calling the “shape” method. For example, I can call “shape” on the “face” variable and pass “turtle” to it. Run the code, our face has the shape of a “turtle”! But the limitation of this is that there are only six shapes you can choose from. What if I want my face turtle to actually look like a face? Well, remember, our face turtle is not a pen anymore, it is a sprite! In scratch, what do you do to give a sprite some look? Yes, you use costumes! Costumes are just images to give your sprite different looks. So instead of passing shapes such as “turtle” or “arrow”, we can pass an image to the “shape” method and our turtle would then look like that image. Earlier, I have shown you all the face images for this lesson, and we will be using those for our face turtle. The question now becomes how do we specify an image for the “shape” method? In Scratch, this is pretty simple, you just use the “switch costume to” block and select the costume name from the dropdown list. In Python, since it is a text-based programming language, things are usually slightly more complex, but not too complex. Here is how you do it: delete the “turtle” string, then pass the “path” to the image you want to use as argument instead. So what is a Path? 

* First, find and open the folder for this lesson on your computer. All done? Now you should see a “main.py” file and a folder called “Resources”, right? Ok, starting from here, what would you do if I ask you to find an image called “1.gif”. You would probably go: “Aha, I know where it is! Open the ‘Resources’ folder, then open the ‘Faces’ folder and there you go, the 1.gif image file is right there!” Excellent! Now, think about how you got here, starting inside this lesson’s folder, you first go to “Resources” folder, then “Faces” folder and finally locate the file. It’s a sequence of folders, one after the other, and ends with the file you are looking for, right? So this sequence is like a Path that leads all the way to what you are looking for! As long as you know the path for a file, an image or anything else, you can just following the path to get it. Here, each of our face image is an image file, right? Now, if we can pass the path an image file to the “shape” method here, do you think it’s gonna find it? Of course! The method would find that file like what you have just done, following the path until the image is found! Cool! Now we know what a path is, but how do we pass that as an argument? In Python, a path is often specified as a string. So let’s pass a pair of double quotes first. Now, a path string is nothing but a sequence of folders to follow, all separated by the “/” symbol. So what is the first folder we opened to find the image? Yes, the “Resources” folder, so let’s add that into our string. What is the next folder? Yes, “Faces”. So let’s separate it from “Resources” by add a “/” then “Faces”. Now once we are in the “Faces” folder, did we find the final image file? Yes, it’s called “1.gif”. So add this file name last in the path string, again separates it from “Faces” using a “/”. If you’re trying to locate a file, the path string always ends with the name of that file. That’s it, that’s how you create a path string and use it as argument to tell “shape” where to find a file. Shall we run this an see what happen?

* Test. Aha, we have got an error! It is an TurtleGraphicsError, and it says “There is no shape named blah blah blah” and the “blah blah blah” is our path string. Ok, previously, we passed one of the six shape names to the “shape” method to change the turtle’s look. But here, we are passing a path string instead. This could not be more different than a shape name, right! So turtle is complaining, “ere, this is not one of those six shapes I know of, so I’m gonna throw up!”. So, are we doing this all wrong by passing a path string to “shape” method?  Well, time to bring out Scratch again! Now, let’s say we create a sprite of our own. Unlike those sprites that come with Scratch, our own sprite does not have any costumes to start with. So if you have an image and want to use it for this sprite, what do you need to do first? Yes, you need to upload it to the sprite’s costume list and only after that can you start switching the sprite’s costume to it. This makes total sense, because how would Scratch know about this costume if it has not even been uploaded yet.  

* Now, coming back to our code, can you start to see why this error occurred? Yes, excellent! Calling “shape” method is like the “switch costume to” block, it changes the sprites costume. But as we have just discussed, you need to upload the costume before you can change to it. Have we uploaded our face costume here? No. If the costume is not uploaded and you try to switch to it, what’s gonna happen? Yes, you get an error, as we did here!  So the solution is pretty clear, we need to upload “1.gif” first. Now, here is one difference between Scratch and Turtle: in Scratch, each sprite has its own list of costumes. But in turtle, the entire window has all the costumes of all the turtles or sprites. What this means is that to upload costume “1.gif”, we are not uploading it using the “face” turtle, but using the “window” object. Here is what to do: before calling the “shape” method, we call the “addshape” method on the “window” object to upload an image. How do you specify the image? Yes, we use the path string again. So the argument is the same as the one passed to “shape”. Cool, that’s it, that’s how you upload a image as a costume. You always need to do this before it can be used by any turtle. Let’s see if this solves our problem!

* Test. Run the code again, and, there you go! Our ghost has a face now! It’s looks so cute! And since we have so many images for the face, let’s try a different one, say “11.gif”. I think this is an angry face. Yep, it is! Nice! OK, let’s change it back to “1.gif”.

* Right there is just a small problem I would like to solve: I think the face is now a bit too low, I would like to move it a little bit higher. Again, you can do it in different ways, using methods such as “goto” or “forward”. Here, I would like to move it maybe 70 pixels higher. Since the face turtle starts at x 0 and y 0, I just need to make it go to y 70 along the y axis and the x coordinate stays at 0. So, let’s define a new variable called “face_height” and set it to 70, then in function “create_face”, we call “goto” on “face”. Pass 0 as the first argument for the x coordinate, because we don’t want to move the face along the x axis. The pass “face_height” as the second argument for the y coordinate, to make the face move up 70 pixels. OK, Let’s test this!

* Test. Now, after the head and body is drawn, we see the ghost face showing up and then quickly move up into place. Pretty cool! Of course, if you are really picky, you might notice that there seems to be straight line being drawn and the face moved up to slowly. If this bothers you, before calling “goto”, we can just call “speed” and pass 0 to make the face turtle move as fast as possible and also call “penup” so that it does not draw a line as it moves. Let’s test this again, and yep, the two little issues are gone! Nice!  |
| Face animation - adding all image files | * OK, our ghost has a head, a body and a face now. But apart from using external images for the turtle’s look, it is not fundamentally different from our painting in the last lesson: they are still just both drawings with a bunch of still shapes and images. What we want to do, starting from this lesson, is to make our turtles move! This includes making them change costumes and go around in the window. These two are the most important components for creating any interesting animations and games! In this lesson, we will first see how to change the costumes of a turtle to make it become alive!

*  But first, let’s try to understand how an animation is created. Take a look at this video. Something like this is probably the most basic form of animation that anyone can create: you have a flipbook, and the character drawn on each piece of paper is slightly different from the previous one. Then once you flip through it very quickly, it is as if the character becomes alive and starts to move. So each piece of paper is often called a frame, and an animation is just a sequence of frames played very quickly one after the other. In the real world, a fame can be a piece of paper with some drawings; whereas in the digital world, such as in a Python program, it could be an image file. 

* Now, I can explain why we have so many image files for the face. Take a look at the first few ones: image one is just a normal face without any expression. The second one starts to look a bit little like a smiling face, right? In the third one, the mouth starts to open and a smile is starting to become a laugh. And the fourth one, the mouth is opened up even wider and it definitely looks like a laugh now. As you can see, when moving from costume to costume, we are starting to see the face changing from no expression to a big laugh. And this is an animation, with a sequence of images showing one after the other! Of course, we are no gonna click through all the images by hand to animate the face! It’s boring, but more importantly, we are not gonna be quick enough to go from image to image. One of most important things about creating animation is that you have to switch images quickly enough. Let’s leave this difficult task to our Python program!

* Now, to create full the animation, we need all 43 image files as costumes. So what is the first thing we need to do here? Yes, we need to add all of them to the window! If you forget to do that, then you won’t be able to use those images as costumes later on. So we already called “addshape” once to add the first image file. We just need to add the rest 42. Now you could just call “addshape” for another 42 times, but, we know this is silly, and we have better way to to that right? Yes, we can use a “for” loop! So “for”, do we need a loop variable here? I’m not sure, let’s just use the underscore for now. Then “in”, and “range(43)” because we have 43 image files. Next, let’s move the function call “addshape” into the loop body. Ok, are we done? Yes, excellent! We are adding only the first image again and again for 43 times! Dose anyone see that? We use the same file path for every loop iteration! Instead, we want to add a different image file each time! So what should we do? Do we know any value that would keep increasing by one as the loop iterates? Yes, we do know one, it’s the loop variable! So it turns out that we do need to loop variable after all. So let’s replace the underscore with a variable! You can name it anything you want, I would just call it “i”. Now, the path we pass to “addshape” needs to be updated as “i” changes. When “i” is one, we add image “1.gif” and when “i” becomes 2, we add image “2.gif”. So how can we make the path string changes as the value of the loop variable changes? Yes, we can use an f-string for the path. So add letter “f” before the string. Now, instead of always having “1.gif” in the string, let’s replace the number with our loop variable “i”. But of course, “i” needs to be in a pair of curly brackets. Right, are we all done here? Not sure? Let’s run the code and see if it would yell at us.

* Test. Ouch! It did yell at us. What does the error say? “Couldn’t open the path blah blah” and finally the file name “0.gif”. What “0.gif”, we thought the files start at “1.gif”! What is going on here? Ok, time to recall one important fact about the “range” function. When you call it and pass, say number 5, what do you think the range of values that get returned? Is it 1, 2, 3, 4 and 5 or something else? Yes, billiant! It returns 0, 1, 2, 3, and 4 instead. So the first number of the range is always 0 and not 1. Now, back our loop, we have “range(43)”, what do you think the range values are going to be? Yes, it starts from 0 rather 1, and then 1, 2, 3 and all the way to 42 and not 43! So think about the first loop iteration, what would be the value of “i”? Yes, 0. So when use number 0 in the path string, what is the final path we get? Yes, it is going to try to find an image file named ”0.gif”. Do we have that file? No! So will Python yell at us? Sure! And that’s exactly what it complains in the error message: “no such file”! So what can we do? So if the values of “i” goes from 0 to 42, then adding 1 to it makes it go from 1 to 43. And this is the range we actually need. Let’s run the code again! This time, Python is happy! So we have successfully added all 43 face costumes! Awesome!

* Before we move on, I want make a small again. We use number 43 as range here. But if later on, we add more face images, such as 44.gif, 45.gif. We have to come back here to change this number. So once again, it’s always better to use a variable instead. So let me create another variable called “num_of_face_costumes”, and assign 43 to it. Then in the loop here, replace 43 with “num_of_face_costumes”. Now, whenever we add more image files, we just need to remember to change the variable value here and don’t need to worry about the rest of the code. By now, you should notice that whenever I have actual numbers in my code, I like to turn it into a variable if I think this number might change in the future. If the change does happen, I just need to change the variable value instead of search through the entire program to make changes in a million places. So you should also get yourself into the habit of doing that. If course, that does not mean I would replace every number with a variable. For example, the number 0 here when setting the turtle’s speed. The reason I don’t do it here is because I want to turtle to finish whatever it is doing as fast as possible, and this intention is not likely to be changed in the future. In such case, it is OK to leave it as a number. As you become more and more experienced, you would get a better sense of whether to use an variable or not in difference situations.  |
| Face animation - animate face | * Ok, so we have all the face costumes ready to create some animation! Let’s first create another function called “animate_face” and add a “pass” statement in the function body for now. Then call “animate_face” after the ghost has been drawn. 

* Now, it’s time to think about how to animate the face using all these costumes. As we already know, an animation is created when all images are played one by one quickly. So, if we can get the face turtle to switch to a new costume one after the other, then we should be able to animate it, right? Think about how you normal animate a sprite in Scratch: you would have a loop and then run the “next costume” block in that loop to go from one costume to the next, right? So, sounds like we also need a loop in the “animate_face” function! Let’s create a “for” loop with a variable “i” that goes through all images. This time use the new “num_of_face_costumes” as argument to the “range” function, which is the same as passing number 43. Once again, it shows why creating this variable is a good idea: if more images are added later on, we only need to update the value when the variable is initially created, and no other changes are required, including this “for” loop. In the loop body, we just need to call the “shape” method on the face turtle and pass it the path to the current image. What is this path? Well, it is exactly the same as the path string we passed to “addshape” method in function “create_face”. So let’s just copy that and paste it here. Right, as the loop runs, the face turtle is going to switch to one costume after another. Let test this out!

* Test. Wow, our ghost is now making all sorts of funny faces! It has come alive! How cool is that! 

* But there is a small issue: the face is changing too quickly! Ideally, we want it to be a bit slower to make the animation a bit more realistic. Let’s go back to Scratch again. When animate a sprite like this, we often have a similar problem: the costumes are changing too quickly and we can’t see the animation! What did we do to solve that problem? Yes, we use a “wait” block to slow down each iteration of the loop by making the sprite wait for a bit before switching to each new costume. This is inspiring: what if we can also wait for a bit after calling the “shape” method? Would that make the face change a little bit slower? Let’s try! In Python, there is also a way to make the program “wait”, in other words, to pause it for however long you want. The method is called “sleep”. This is like putting the program to sleep mode so that it stop doing anything. This is not a built-in function. It is in a module called “time”. So let’s import it first by going to the top of the file, and typing in “import time”. There are a ton of methods in the “time” module, but for this lesson, we are only interested in its “sleep” method. After calling “shape” in the loop, we call the “sleep” method by doing “time.sleep”. This function accepts only one parameter which is the amount of time you want to sleep for. It is measured in seconds, so if I pass number 1, it waits or sleeps for one second before running the next loop iteration. OK, let’s try this out!

* Test. Right, this time it is slow enough that we do see each and every face nice and clear! Sleep works! But it probably works a little bit too well, the animation is a bit too slow now! I think sleeping for 1 second every iteration is probably too much. Let’s make the sleep shorter by passing 0.1 seconds instead, that is one tenth of a second. Test again, ok, it’s better, but I still think it can be made faster and smoother. Let’s make it even quicker by passing 0.05 seconds, that is one twentieth of a second. Test again, yeah, this time it looks perfect! Smooth!

* Now, before we move on, I would like address one issue in our code. As we can see, we use the same 43 path strings in both “create_face” and “animate_face” functions. They are exactly the same. In fact, we actually copied the string from “create_face” and paste it in “animate_face”. Again, what if the path string changes for some reason? For example, if I rename the folder from “Faces” to “GhostFaces”? Then we have to remember to change the path strings in both places. And whenever you need to make changes in more than once place because of some other changes, you can introduce unexpected errors. For example, if I only rememeber to update the path string with the new folder name in “create_face” function but forget to do it in the “animate_face” function, then when you animate the face, turtle is going to complain that the shapes cannot be found. We have already seen similar problem a couple of times, and the solution is always to create a variable for the value and then use that variable where ever it is needed. A very recent example would be the “num_of_face_costumes” variable. So here, same idea, let’s use variable for the paths. 

* But things are slightly different here, we have a total of 43 path strings instead of a single value. So how can we store them? Yes, when you have more than one value to store together, List is your friend. Let’s create a list variable called “face_costumes” and assign it an empty list to start with. Now inside the “for” loop in “create_face”, we are not only going to add the costume to the window, but also to the “face_costumes” list. After calling “addshape”, we call the “append” methods on the “face_costumes” list and pass it the same path string. Here we have two path strings that are exactly the same, to save some typing, we can create a local variable inside the loop, called “path”, assign the f-string to “path” and then just pass “path” to both “addshape” and “append”. 

* So what do we gain by doing all of these? Well, now, in the “animate_face” function, we no longer need to type in the same path string again. Instead, we can get it from the “face_costumes” list! All we need to do is just use the loop variable “i” as index to get the path string for each face costume! And what if we change the folder name from “Faces” to “GhostFaces”? Well, this time there is only one place you need to change, here, in the “create_face” function, and you don’t have to worry about updating the “animate_face” function ever again! Let run the code and see if everything still works!

* Test. Yep, still works as before. Perfect!

* Ok, the face animation only plays once, from the first costume all the way to the end. After that, it stays at the last costume and there is no more animation. Now think of a game you love most and any character or object in the game, what kind of animation does it have? For example, this is an online version of the classic [Super Mario Game](https://supermario-game.com/). Now pay attention to these question mark blocks in the game: they go bright and dark, and then bright again and dark again. Thisanimation just repeats forever. You don’t want the blocks to go bright or dark and then stay there, right? So quite often, an animation needs to be played again and again forever, probably only stops when the game ends. So what can we do to make our face animation repeat forever? Take a look Scratch again, what did we use to run “next costume” again and again? Yes, we use a “forever” loop block! And what does a forever loop looks like in Python? Yes! The “while True” loop, right? Ok, to make the animation goes on forever, we just need to change the “for” loop to the forever “while True” loop!

* Right, let me start from a new line in “animate_face”. Type in “while True:”, the loop header for a forever loop. Then, let me first copy the code in the “for” loop and paste it here. After that, we can delete the “for” loop. Do you think this is gonna work? Let’s to find out! 

* Test. Ouch, we have an error! It says “’i’ is not defined” and points out this line here. Aha, yes, “i” was a loop variable of the “for” loop. But since the “for” loop is gone now, “i” is no longer a valid variable because it cannot exist without a “for” [loop.](http://loop.So) If we can’t use “i”, then how can we index the “face_costumes” list? Well, if the “while” loop does not come with a loop variable, we can create one ourselves! As we know, a loop variable is nothing special, it’s just a variable that goes from an initial value to a final value within some range. So what if we create a variable “i”, assign an initial value 0 and increase it by one in the loop? Does this look like a loop variable to you? Yes, it looks like a loop variable: starting from 0 and incrementing by one during each loop iteration. What else is missing? Aha, the end value! But do we need one here? No! The whole point of having a forever loop is that it never finishes. If there is an end value, then this is not a forever loop anymore! Ok, let’s run this and see what happens!

* Test. OK, the ghost is making each face expression one by one, and, boom!!! Just as we are expecting the animation to repeat again, we hit another error! It says “list index out of range” and the line that caused the issue is still this one! The “IndexError” shouldn;t be new to you. Can anyone remind us what that means? Very good, it happens when you use an index that is not in the valid index range of a list. For our “face_costumes” list, the valid index range is from 0 all the way to 42. If you use an index that is greater than 42, then you would have trouble. So, did we use an index greater than 42 here? Well, let’s find out! We create a loop variable “i” and increment it during each loop iteration. In the first iteration, it’s 0 and we use it to index list “face_costumes” to get the first costume, right? Then, after adding one, it becomes 1 for the next iteration, used to get the second costume from the list. OK? So far so good? Now, this continues. At the 43rd iteration, what is the value of “i”? Yes, 42! Because “i” starts at 0. Now using 42 to index the list gives us the last costume, right? Ok, now watch, “i” is incremented once more to become 43. Does our loop stop at this point? No, because it is a forever loop. So it continues into the next iteration, when “i” is 43. What would happen if you use 43 to index a list with only 43 items? Aha, see? That’s how we ran into error, number 43 is not a valid index for our list! The maximum index we can have is 42.

* Now the problem is clear, the next question is: what should we do? Because this is a forever loop and variable “i” is incremented each time, it will eventually grow to 43 and there is nothing we can do to stop that. But what we can do is, once “i” becomes 43, meaning the index has passed the last item in the list, we could reset it back to 0, essentially going back to the first list item. How can we do it? Simple, we just need an “if” statement in the “while” loop to check if “i” is equal to “num_of_face_costumes”, and if it is, we reset “i” to 0. That’s it! That’s all you need to go back to the front of the costume list and start the animation all over again! Let’s test this!

* Test. Wow, look at that! This time, the ghost just keeps doing the same face animation again and again forever. It only stops when we close the window and exist the program. Awesome! |
| Event-based programming with “ontimer” | * OK, so we have drawn a pretty cute ghost and it can make all kinds of funny faces. The code looks good and everything seems to be working. So maybe it’s time to call it a day? Well, well, well, you should know me pretty well by now, whenever I say “call it a day”, it almost always means “wait, there is one more thing!” Yes, I do have one more thing for you and this is going to be pretty crazy! So a bit of warning first, what you are about to see next is probably going to the be most difficult thing you would ever learn in this entire course. But trust me, knowing this would make you a real pro coder! And as always, I’m here to guide you through all this, so don’t panic, hold on tight and let’s get right in!

* First, let’s see what is the biggest hidden problem with our code at the moment. We use a forever loop to animate the face, right? Ok, let’s say later on, we add two arms to the ghost and want to animate that as well, such as waving. We would probably add another function called “animate_arms” and call it after “animate_face”. Of course, we don’t really have any arms here so let’s just print “Animating arms!” inside function “animate_arms”. Now, you would think that the ghost is going to to animate its face and arms at the same time right? Even though we don’t really have arms and there is no code to actually animate them here, we should at least see message “Animating arms!” when the program runs, right? Ok, let’s see if this is the case! 

* Test. OK, the ghost is making all sorts of funny faces, but we never see that message being printed in the console! Why? Does anyone know why? Yes, brilliant! This is because a forever loop is run inside the “animate_face” function and a forever loop never finishes, which means the call to “animate_face” never completes. As a result, the call to “animate_arms” after it never gets a chance to run! We can prove this by commenting out the “animate_face” function call temporarily and run the code again. Now, see? Because there is no longer a forever loop standing in the way, the message “Animating arms!” is printed after the ghost has been drawn.

* So we have a dilemma here, it seems that we can only animate one thing at a time. Hmmm… think about any games you have seen or played before, there must be a lot of animations going on at the same time. For example, each character has its own animation or animations. How boring would a game be if there is only one thing that can be animated each time! Take a look at the [Super Mario Game](https://supermario-game.com/) again, the mushroom enemy has at least two animations, its feet are moving and it also goes left and right.

* Fortunately, there is a solution. This is crazy thing I mentioned earlier: it is a programming technique called “event-based programming”. Ok, I know, I know, this makes no sense to you at all! But don’t worry, because if you are like me, a sleephead,  have probably been doing this every morning! Here is what happens: Before going to bed every night, I would set up an alarm clock on my phone to wake me up at 6:00 am the next morning. OK, then I have a good night sleep. And actually, the sleep was so good that when the alarm goes off at 6:00, I wake up, grab my phone, reset it to 6:10, then fall back into sleep again. Ten minutes goes by really quick and the alarm goes off again at 6:10. I wake up, grab my phone, reset it to 6:20, then fall back into sleep again. Another ten minutes goes by and the alarm goes off again at 6:20. I wake up, grab my phone, reset it to 6:30, then fall back into sleep again. OK, I’m don’t want to bore you by repeating this again and again. And eventually, after the alarm goes off for 5 or 6 time, I finally wake up and get off bed. Does this sound like you? If it does, you know what I’m talking about. Right, what does all of this have to do with the fancy “event-based programming” thing? 

* Now, an event means something that happens. An alarm that goes off is an event. And what I do depends on whether this event happens or not: before the alarm goes off, I’m sleeping; after it goes off, I wake up, grab my phone and reset it to a later time. In other words, my behavior is based on the event or you can say I’m “event-based”. If you apply the same idea in programming, then you have “event-based programming”! Simple as that! You have some code what is only run when some event happens. We will see later on how to do that in Python turtle.

* Now, if an event is a recurring event, meaning it happens again and again, such as the alarm, and each time it happens, the same actions are taken, such as waking up, grabbing the phone and resetting the alarm, then this is essentially a loop! A loop is just about repeating the same actions again and again, right? So, in Python turtle, event-based programming can be used to create loops as well! 

* Now, I know what you are thinking: “I already know how to do loops in Python using either “for” loop or “while” loop, and they work perfectly, so why bother with this “event-based programming” thing?” Well, first of all, learning something new is always exciting. But more importantly, does the “for” loop or “while” really work perfectly? Still remember the dilemma we are in? Yes, when you have a forever loop, no code after it can be run. As a result, we are limited to just one animation at a time. Is the “event-based programming” gonna solve this problem? Now, going back to waking up in the morning again: using a forever loop is like stopping everybody when you are still in the wake up and fall back into sleep cycle. So your mum can’t make breakfast, your dad can’t go to work, your cat can’t play with the balls, the whole world stops, only to wait for you to get off your bed! That’s crazy, that is not how the world works, right? Same with code, how can one forever loop stops every other code from executing! In contrast, using “event-based programming” is like everyone in your home can still carry on with their everyday life, doesn’t matter whether you are still in bed or not. So that nobody would get mad at you and want kick you off the bed! With “event-based” programming, our ghost can have both its face and arms animated at the same time! Let’s see how this is done in code.

* First, we need to figure out two things: what is the event and what should the code do when this event happens. For the face animation, the event is just “change face costume” and when that happens, all we need to do is switch to the costume to the next one for the face turtle. Once we know what to do, the next step is to package the code to handle the event into a function. This is also often called “event-handling” code, or “event-handler”. So let’s create a function called “switch_face_costume” to handle the event. No need for any parameters. Since this function is handle the event by switching to a new face costume, let’s call “shape” method on the face turtle in the function body. Now, to index the “face_costumes” list, let’s create a variable “i” again in the function and assign 0 to it initially. Then we can use “i” to index the “face_costumes” list and pass the result as argument to the “shape” method. And finally, let’s increase “i” by one for the next costume. 

* Ok, we have the code to handle this event. But how do we make that event happen? Ok, here is a new function you can call on the Screen object or the “window” variable: “ontimer”. This function makes an event happen at a future time, this is also often called “schedule an event”. Let’s see how this is used. First comment out function call “animate_face” and replace it with <window.ontimer()>. This is like setting up the alarm the night before. When doing this, I need to know two things: when should the alarm go off and what I need to do when it goes off. These two things are pass as argument to “ontimer” when scheduling an event. The first argument is what to do when an event happens, it is the code that handles the event. Do we already have that? Yes, the “switch_face_costume” function. So all you need to do is just pass that function name to “ontimer” as the first argument. The second argument is at what time should that event happen. Unlike the alarm clock, we are not setting an actual time here, instead, we pass the amount of time the program should sleep for before the event happens. Now, unlike the “sleep” we have seen earlier, where we pass the number of seconds to sleep as argument, time passing to “ontimer” is measured in milliseconds. One milliseconds it one thousandth of a second. So one second is equal to 1000 milliseconds. If I pass 1000 as the second argument, then the code would not run function “switch_face_costume” immediately, instead, it would wait or sleep for 1000 milliseconds or 1 second, and then run it when the event happens. For example, if I go to bed at 10 o’clock at night and plan to wake up at 6, I would set up the alarm to go off in 8 hours. Then I just go to sleep. Now, if you don’t want to wait at all, you can just pass 0 millisecond to “ontimer” so that the “switch_face_costume” function is going to run right away. This is the same as calling “switch_face_costume” directly. Let’s do that instead. Run the code and see what it is like now.

* Test. Ok, so after the entire ghost is drawn, we do see the “Animating arms!” message. This is good! But this is expected, because we are not calling “animate_face” with a forever loop now. What did we call instead? Yes, we are calling our new “switch_face_costume” function. But the bad news is that the face animation is gone, our ghost is just having the same face throughout. Why? Well, if you look into the “switch_face_costume” function, we just use 0 as index to get the first costume from the “face_costumes” list and set the shape of the face turtle with that. So of course, the costumes are not changing. 

* Did we break everything with the fancy event-based programming? Well, think about it, when the alarm first goes off in the morning, I wake up, grab the phone and what did I do? Yes, I reset the alarm to go off later again! This is the most important piece when you use event-based programming to do something repeatedly: you need set up the event again whenever it happens, so that it will happen again later on. So “switch_face_costume” is run when the event happens, and after doing what we need to do to handle this event, that is changing the face turtle’s costume, we need to set the event up again at end. How do we set up an event? Yes, use the “ontimer” method. So let’s call it again inside the function. So what do we want to do when the event happens again? Yes, we want to change the face turtle’s costume to a new one. And how do we do that? Yes, we use the “switch_face_costume” function. So once again, we pass “switch_face_costume” as the first argument to “ontimer”. Now for the second argument, how long do we want to wait to switch to a new costume? Well in the forever loop here, we waited for 0.05 seconds, right, so let’s wait for the same amount here. But of course, we cannot pass 0.05 as the second argument, because, remember, it is milliseconds. So how many milliseconds equal to 0.05 seconds? Well, 1 second is 1000 milliseconds, so to get how many milliseconds 0.05 seconds contains, we just need to multiply 0.05 by 1000 to get 50 milliseconds. Let’s pass 50 as the second argument. This is now just like me setting the alarm to go off again in 10 minutes. With the “ontimer” method being called, “switch_face_costume” is going to be run again after 50 milliseconds, when it switches the face costume to a new one. Then at the end, it is going to call “ontimer” again to run “switch_face_costume” again after another 50 milliseconds. This just keeps going on and on forever, we have created a forever loop using events! How cool is that! Now, let’s test the code.

* Test. Ok, nothing seems to have changed. We still see the “Animating arms!” message in the console, that’s good, but the ghost face is still the same through out, without any changes! What went wrong? Didn’t we schedule an event to run “switch_face_costume” to switch to a new costume every 50 milliseconds? Why is the face not changing?

* Well, if you think that it is switching to a new costume every time the “switch_face_costume” function is run, think twice! Now, what is the most important bit that makes the costume to be different each time? Yes, the index variable “i” here. So we set it to 0, use it to index the “face_costumes” list, and then increment it by one at the end. Question for you, what will the value of “i” be the next time “switch_face_costume” is run? You must think it is going to be 1, right? Because it was 0 and then we added one to it. Unfortunately, the answer is still 0! Why? Well, do you still remember the difference between local and global variables? Yes, global variables are defined outside of any scopes and local variables are defined in local scope such as inside a function. So “i” is a clearly local variables here. Now one thing about local variables is that it is always assigned an initial value every time the function runs. For example, “i” is always assigned number 0 every time “switch_face_costume” is run. So it always starts with 0, doesn’t matter how many times you run the function, changes to this local variable is not accumulated. This means, every time “switch_face_costume” is run when the event happens, “i” is always 0 and using that to index the “face_costumes” list always gives you the first costume. And this is the reason why the ghost face is not changing.

* So, what is the solution then? Well, the opposite of local variable is global variable. Global variable always get its initial value assigned only once in the global scope when it is created. Then afterwards, you can increment it, decrement it or even change it to a completely different value, any change you want. But those changes are going to stay, simply running a function again is not going to reset the value. So, the solution is to delete this line here, which makes variable “i” a local variable inside the function, and define it in the global scope like all these variables here, and assign 0 to it. That should solve our problem. Let’s try!

* Test. Ok, and ouch, we have an “UnboundLocalError” here, it says “local variable “i” referenced before assignment”. OK, here is the question for you, what does this mean? We have actually come across this same error in the first part of this course. Can anyone still recall that? Yes, this is because we are updating the value of a global variable “i” now, and whenever you want to change the value of a global variable in a local scope, you need to make it clear here that this is a global variable. How can we do that? Yes, we use the “global” keyword, followed by the global variable “i” to tell the function that whenever you see a variable “i”, it is a global one. Cool, let’s try this again!

* Test. Aha, our ghost is starting to make faces again! And more importantly, we have also seen the message “Animating arms!” while animating the face, so we are able to do both at the same time! Errr, but wait, we have an Index error again! But this time, we already know what went wrong: we cannot just have variable “i” keeping increasing. Once it gets to 43, we need to reset it back to 0, right? So all we need to do is just add an “if” statement at the beginning of function “switch_face_costume” to check if it is equal to “num_of_face_costumes”, and if so, we reset it back to 0. Now, let’s test it again. Yes, this time, the ghost can again play the face animation again and again, and we are still seeing this message. Perfect! |
|  |  |
|  |  |

### Exercise

- Can you use “goto” method for the pen to move from its ending position after drawing the body to the starting position for drawing the wavy bottom.
- Can you use the “modulo” operator to solve the problem of costume index cycling?
- Finish the animation for jellyfish for the next lesson