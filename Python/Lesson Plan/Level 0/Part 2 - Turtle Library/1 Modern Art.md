# 1 Modern Art

### Reference

[Modern Art | Web-browser, Python | Coding projects for kids and teens (raspberrypi.org)](https://projects.raspberrypi.org/en/projects/modern-art)

### Code

https://replit.com/@chairmanguo/5-Modern-Art

### Key Points

- Turtle Module
    - Setting up screen and keep it running (’mainloop’)
    - Creating turtles
    - Coordinate system and direction
    - Moving turtle on the screen to draw things: square, rectangle, circle and star
    - Star geometry
    - Misc turtle functions’
- Loops
    - Placeholder for “for” loop variable
- Programing Concepts
    - Use functions to decompose program into logical parts and steps
    - RGB colors
- Turtle module
    - import module
    - window setup: “title”, “setup”, “bgcolor”
    - how to find most commonly used colors for turtle
    - keep window open: “mainloop”
    - turtle setup: “shape”, “color”
    - coordinate system and direction
    - turtle movement: “forward”, “backward”, ”left”, “right”, “setheading”
    - filling color: “begin_fill” and “end_fill”
    - “goto”
    - “penup” and “pendown”
    - “colormode”
    - “speed”
    - “hideturtle”
    

| Steps | Note |
| --- | --- |
| Introduction | * Ok, welcome back! First of all, congratulations all of you for finishing the first part of this course! That’s not an easy task! So well done! In the first Part, we get to know a lot about Python: variables, operators, conditions, loops, functions etc. They are all the cornerstones for Python upon which everything else is built. Doesn’t matter how big or complex your program become in the futures, it’s all just these basic concepts arranged in a certain way. Keep practicing them and you will eventually become a thoughtful and creative coder! Hopefully you enjoyed the first part as much as I do!

* Now, today, we are officially going to start the second leg of our Python journey! In the first part, all the applications and games we built are “text-based”, meaning you see the output as text printed out in the console, and you interact with the programs by typing text into the console also. Now, it is simple and this is how people interact with computers when they were first invented. But as technologies improved, we began to see more and more graphical interfaces instead. For example, when you use the Windows operating system, you use the mouse to drag and drop files and folders on a screen, right? Another example would be your favorite game, I’m pretty sure it must be full of amazing graphics, sounds and animations. Graphical interface now becomes the preferred way people use to interact with any program, at least for most of us. Python is no exception either: you can use it to write programs that are more visually appealing, such as graphical applications, animations and games. And as with everything in Python, this is pretty simple and straightforward, at least once you know how to do it.  What better way to learn that than creating some very interesting graphics, animations and games! And this is what we are going to do in the second part of the course. We will be learning a super fun and popular tool called “Turtle” to do that! This second part builds on top of everything we have learnt in the first part of the course. Under the hood, everything is still the same basic concepts, variables, loops, functions etc, but once they are brought together, coupled with the power of “Turtle”, we can create some of the most amazing games!

* In this very first lesson, we will get to know “Turtle”, understand how to use it to draw simple shapes and what a typical Turtle program looks like. We will paint some modern art of different shapes such as squares, circles and stars, with different colors. That’s looks pretty cool huh? A good understanding of the basics paves the way to build more complex animations and games further down the road! There are a lot cool stuffs ahead, so I can’t wait, let’s begin! |
| Setting up | * Before we start learning Turtle, I want to point out that from this lesson on, we are going to leave the online Python editor Replit and start using VS Code. This is because, turtle is all about computer graphics, and unfortunately drawing graphics over the internet can sometimes be very slow. Just think of a time when you play an online game and things are not very responsive, that must be a very frustrating experience, right? So to make our learning as smooth and frustration free as possible, we want to create all the turtle project in this second part of the course using VS Code. This is a locally installed editor that runs on your computer completely. So things are as fast and responsive as they can be. In the very first lesson of this course, I’ve covered all the basics of how to install VS Code locally on your computer and how to use its basic functions. If you feel like needing to refresh your mind, feel free to go back and  watch the recording of that lesson. Here, I would just assume that bot you and your computer have everything ready.

* Also, since we are going to work on our own computers from this lesson on, you need to download all the resource files for the second part of the course. Hopefully you have all done that before this lesson. Once you unzip the downloaded file, there is a folder called “Introduction to Python (Part 2)”. Open, and you would see five subfolders inside, each for one project that we are going to build. The first one is called “Modern Art”, which contains a python file that we are going to work on in today’s lesson. To open this folder, go to VS Code, in the menu up top, select “File” and then “Open Folder”. Now, in the left panel of your VS Code, you should see the project folder and there is “main.py” file inside. This is the program file that we will be working on. |
| Window setup | * Ok, before we starting learning “Turtle” in Python, let’s refresh our mind about Scratch. So in Scratch, where do all the action take place? Yes, everything happens on the stage: It’s basically a window where you can see all your drawings, the sprites and how everything interactive with each other, right? Now, how do you draw on a stage? Yes, this an extension called “Pen” that you can add to your project. There are a number of blocks there to help you draw, for example, putting the pen down, changing the pen’s color and size, etc. With those blocks, you can easily draw many different shapes on the stage. OK, the reason I’m bringing up Scratch and its “Pen” extension here is not because I want to give you lesson on that again, but rather, I want to show you how similar the concepts in “Turtle” are compared to those in Scratch later in the lesson. So please keep this mind as we continue!

* OK, back to Python. Now, Python itself does not come with the capability to draw things. So what should Python when it itself does not know how to do something? Yes, we find external tools and help somewhere else! And how does Python do that? Well, in lesson “Pick Your Team”, we have seen an example of that, right? Still remember? Yes, we needed to generate some random numbers to pick student at random. But Python does not come with a function or functions to do that? What did we do? Yes, we use an external tool call “random” and this comes in what’s called a “module”. Just as a refresher, a module is a collection of useful functions to do certain task. For example, to deal with random numbers. So what kind of task do we have here? Yes, we want to draw simple shapes in a window. That’s what we want to do. Is there a module for that? Of course! In fact, this module is the one we have been talking about all the time since the beginning of this lesson, it’s the “Turtle” module.

* So “turtle” is a module, and what is the first thing we need to do in order to use a module? Yes, we need to import it! So let’s do that. Remember the different ways we can import a module? Yes, the first one is just <import turtle>. And what is the downside? Yes, if we do this, we need to type in the name of the module and a dot before calling each method in it. So example, if there is a method called “penup”, then we have to do <turtle.penup()>. If you call a lot of “turtle” methods, then there will be a lot more typing. So what is the solution for that? Yes, we can also do <from turtle import *>. This imports everything in the module directly, so you can just call <penup()> without adding the module name at front. Ok, at the point you might think that the second approach is better. Yes, in a way it is. But, in the course, whenever we use the “turtle” module, I will import it using the first approach. Yes, that does mean I need the <turtle.> in front of each turtle method call, but I think as we are learning, maybe it’s better to make it clear that a method is coming from the “turtle” module and not somewhere else. And adding <turtle.> in front of each turtle method serves this purpose. Of course, after you have been using turtle for a long time and are familiar with most of its methods, then, sure, you can use the second import method to save some typing. 

* Ok, “turtle” is now available for us to use! Unlike the “random” module, “turtle” is a very big one, it has a ton of methods. In fact, the official Python website has a dedicated section about “turtle” and it can be found [here](https://docs.python.org/3/library/turtle.html). You can read it through if you want but that is probably going to be a bit boring. I still think the best way to learn anything in programing, or in fact anything in life, is to learn by working on real projects. And that’s what we are going to do in this lesson and the rest of this course. We will be building animations and games that are more and more advanced, to explore the real beauty and power of “turtle”. 

* Right, once the “turtle” module is imported, you might think it’s time to start drawing. But not so soon! Think about it, what do you need before you can draw? Yes, a piece of paper! Like in Scratch, we need to have a stage first where all the drawings and sprites show up. The only difference is: with Scratch, the stage is given and you do not need to do anything, whereas with “turtle”, we need to create that stage ourselves first. How do we do it? Well, the “turtle” module has all the methods to help! 

* So, first, we need to create a stage, or in the “turtle”’s term, a “Screen”. We can do this by calling the “Screen” method in the “turtle” module, like <turtle.Screen()>. Well, to be honest, “Screen” here is actually not a method but the name of a “class”. But to understand that concept, we need to know about object-oriented programing and that is a huge topic on its own. So we will not dive into that here or in this entire course. Actually, I have another Advanced Python course where we will cover this topic and more. For those of you who are interested, you are more than welcome to join that course. Here, you can just think of it as a special method that often starts with a capital letter. What it does is, well, to create and return a screen. By the way, when it is a value returned from such special method, we often called it an “object”. So here the “Screen” methods returns a “screen object”. Again this concepts ties to object-oriented programming which will only be covered in a more advanced course. Here, just knowing that it’s an object is enough. Let’s save this returned object in a variable. Here, different people choose different names for it, some call it “screen”, some call it “window”. Personally, I prefer “window” as you will see why later. So that’s the name I will use here. OK, we have a screen or window now, let’s run the code and see what it is like.

* Test. Run, and… well, if you pay close attention to your monitor, you would see something that appeared and then disappeared very quickly. Didn’t see it, let me try again! Run and see that? So what is that? Well, what do we have in the code right now? Yes, a widow! So what do you think that it? Yes, it’s our window. But having a window just flashed off is not very useful, is it? Instead, we want the window to stay until we decide to close it. How can we do that? Well, like things such as strings, list or dictionary, a screen object also has a lot of methods that you can call to do various things. And one of those methods keeps the window stay open on the screen. It is called “mainloop” and let’s call it on the “window” variable. Let’s test the code again. 

* Test. Run and now we can finally see the window. You can minimize it or maximize it. And this time, you get to decide when to close it by clicking the cross button in the upper right corner. So it is just like any window we have seen in an operating system and this is why I prefer to store the “screen object” in a variable called “window”. So this “mainloop” method is like a game loop we have seen before, once it is called, the program just keeps running a forever ‘while’ loop again and again. It only breaks out when the close button on the screen is clicked. This is clearer if I add a “print” after calling “mainloop”. Now if I run the code again, you won’t see “End of program” printed in the Console. If I close the window, then you see the message and program ends. Cool!

* Ok, if we look at the window again, there are a few things I want to change. First, the title bar here says “Python Turtle Graphics”. I want to have a more custom title here, such as “Modern Art”. For that, we would call another Screen method called “title” to change it. This method accepts a parameter which is just the title you want to change to. So here, I will pass string “Modern Art”.

* Test. Now, run the code again. As you can see, this time the title has been change to “Modern Art”. Pretty cool!

* Next, I also want to change the size of the window. We know in Scratch, the size of the stage is 480-pixel wide the 360-pixel high. There is no easy way to make it either larger or smaller. Fortunately, with “turtle”, you are free to change the window to any size you like. For example, I think it is a bit to big right now. I want to set it to a square that is 600 pixels by 600 pixels. And the way you do it is by calling the “setup” method on the window. This method accepts two parameters, the first one is the width of the window and the second one is its height, both in pixels. So let’s pass 600 and 600. 

* Test. Now, if we run the code again, the window becomes a much smaller square. Perfect!

* One final thing I want to do to the window is to change the background color here. Right now, it’s just white. I want to change it to a grayish color. As you might have already guessed, we need to call another Screen method here. This time, the method is “bgcolor”, where “bg” stands for “background”. This method accepts one parameter: the background color you want to change to. Now, in turtle, there are a huge number of colors you can choose from. There are different ways to specify the exact color you want, one of the simplest way is to just type in the name of the color, for example, if we want to change the background color to red, I can just pass string “red” as argument to method “bgcolor”. 

* Test. Now, if you run it again, see? The background color has been changed to red. 

* But of course, we don’t want red here, I want to have a dark grey. So how do I know the name of that color, is it just called “dark gray”? [Here is a very useful web page for you find out some of the most common colors to use](https://cs111.wellesley.edu/labs/lab02/colors). Each color is labeled with its corresponding name. To find a gray, we can go to page 2 and here you will find different shades of gray, from dark gray to light gray. Here, I think “gray30” looks about right. Back to the code, let’s change the color from “red” to “gray30”. 

* Test. Now, run the code again and there you go, we have “gray30” as our background color. Nice!

* Ok, so our window is pretty much all setup. We changed its title, size and background color. In fact, doesn’t matter how complex the code become in future lessons, there are pretty much all we need for a window. So before we move on, I want to make a few changes to better organize the code. This might not seem important right now, but as we add more and more code, it will definitely make a huge difference. Looking at all three method calls, each one is setting up one part of the window, right? So let’s define a new function called “setup_window”. We don’t need any parameters. Then just move the three function calls inside this function and make sure they are indented properly. Now after creating the window, let’s just call “setup_window” instead.

* Test. Ok, let’s run the code again after all these changes. Yes, the window still looks the same. Cool! |
| Turtle pen setup | * Ok, we have a window now, and it’s time to start drawing. In Scratch, we would use the blocks in the Pen extension to do that. In Python, we would use a “Turtle” to do that. Well, the name of the module “turtle” actually comes from this. Now think of a turtle as a sprite in Scratch, but unlike an ordinary sprite, the turtle has the magical power to draw lines in the window. So as it moves, it leaves a trace behind, and this trace becomes the line it draws. In essence, a turtle is just a fancy name for a pen in Python. Ok, if this all sounds too vague, let’s look at some actual code.

* First of all, we need to create a turtle, this is like creating a sprite in Scratch. Previously, we call the “Screen” method in the “turtle” module to create a screen object as the window. For a turtle, we call another special method “Turtle” in the “turtle”. Note that it also has its first letter in upper case, meaning it is actually not a method but a class name. Again, we don’t want to go into the details of object-oriented programming, so just treat it as a method that can return a turtle object. We also need to create a variable to store the return value. Now, some people would just name this variable “turtle”, because, after all, it’s a turtle object. But since here we are mainly gonna use this turtle object as a pen to draw on the window, so I personally like to name the variable “pen”. Ok, let’s run the code and see what happens now.

* Test. Right, now did you see the difference? Yes, we have a small arrow in the center of the window, pointing towards the right hand side. This is our turtle. But you might say: well, that looks nothing like a turtle to me! It’s just an arrow! Well, just like you can change what the window looks like, you can change what a turtle looks like too! Yes, right now it looks an arrow, but that does not mean we cannot change it. The way you change it is by calling the “shape” method on the turtle object, so <pen.shape()>, now, this method accepts one parameter, which is the shape. Of course, you cannot pass any shape you want. You can only choose one from the following: “arrow”, “turtle”, “circle”, “square”, “triangle”, “classic”. So believe it or not, the arrow we are seeing right now is not shape “arrow” but “classic”. If you want the turtle to actually look like a turtle, we can pass string “turtle” to the “shape” method. 

* Test. Let’s run the code again and there you go, we can see a turtle now! So all these shapes are like the costume of a sprite, and you get to choose one you like. For the other shapes, I don’t have the time to show them all in class, so try them on your own if you are curious. 

* If you are not happy with the turtle’s black color, just like calling the “bgcolor” method for a window to change its background color, you can also change the turtle’s color by calling its “color” method. Now, this one also accepts one parameter called “color”. We can go back to our turtle color web page to find a color we like. For this one, I’m gonna choose the “DarkOrange” color here. So pass that as a string to the “color” method. 

* Test. Now, if we run the code again, our turtle become orange. Pretty Cool!

* Ok, there are actually more things you can change or set for a turtle, but these two are enough for now. Just like creating a function for setting up the window, we also want to create a function for setting up the turtle, or the pen. So let’s create another function called “setup_pen”, again no parameters. Then move these two function call inside, and indent them properly. Finally, just call “setup_pen” after “setup_window”.

* Test. Ok, let’s run the code again and everything stays the same. Perfect! |
| Coordinate system | * OK, we have the window, we have the pen, and we can finally start drawing! But before that, we need to first understand something very important: the coordinate system. For those of you who have learnt Scratch before, this shouldn’t be new to you. In fact, the coordinate system in turtle is almost the same as that in Scratch. But since this is the first programming course for some of you, so I will introduce the coordinate system again here. 

* First, think of the window as a 600 by 600 pixel square. Now, imagine having two straight lines cutting through it, one goes from left to right, called the “x axis”, and one goes from bottom to top, called the “y axis”. Their intersection point is called the “center”, because this point is of equal distances to the top and bottom of the square, and it also of equal distances to the left and right of the square. In other words, the x axis cuts the square into two equal halves, top and bottom. The y axis also cuts the square into two equal halves, left and right. Each point in this square has what we call an “x coordinate” and a “y coordinate”, these two coordinates together determines where a point is in the square. For the center, its coordinate is (0,0), meaning its x coordinate is 0 and its y coordinate is also 0. Now, when we move right from the center along the x axis, the x coordinate increases from 0 all the way until it reaches the right side of the square. Remember, the width of our window is 600 pixels, and since we move half of the that width, the x coordinate at the right side of the square is 300. Now, if we move in the left from the center, the x coordinate decrease from 0 all the way until it reaches the left side of the square. Again, we move half of the width, which is 300, but in the opposite direction, so the x coordinates becomes negative, it goes from 0 to -1, to -2, and all the way to -300 when at the left side of the square. Similarly, we can also go up or down from the center along the y axis. This time, it’s the y coordinate that changes. If we go up, y coordinate increases from 0, all the way until we reach the top side of the square. Again, because the total height of the square is 600, and we have moved half of that, so the y coordinate at the top side is 300. Now, if we move down from the center, the y coordinates becomes negative and decreases from 0 until we reach the bottom side, where the y coordinate is -300. 

* As you can see, for our window, the x coordinates go from -300 to 300, and the y coordinates also go from -300 to 300. And for any point in the square, we can find its x coordinate by checking where it is on the x axis, and its y coordinate by checking where it is on the y axis. These two coordinates together determine where this point is in the square or window.  |
| Move turtle forward | * Ok, with a fairly good understanding of the coordinate system, we can finally get the turtle to move and draw some basic lines. First of all, as we have already seen, when the program starts, the turtle is always placed at the center of the window at (0,0) and goes from there.

* After setting up the pen, we can call method “forward” on the “pen” variable to move the turtle forward. It needs just one argument, the number of steps to move. Let me pass in 50 and test this.

* Test. As you can see, since the turtle is facing right, when asking it to move forward, it moves to the right 50 steps. Also, as it moves, it leaves a trace behind, and this becomes the line it draws. This line has the same color as the turtle. 

* Now, we know that the x coordinate of the window’s right side is 300, so if we move the turtle forward 400 steps, what do you think is going to happen? Let’s find out!

* Test. Yep, we can see the turtle keep moving forward until it is completely off the window. It is still there at x coordinate 400, it’s just that we cannot see it anymore. Again we have see a line being drawn all the way to the right side of the window.

 * Now, what if I pass -50 to “forward” instead? Yes, everytime you see a negative number, always thing about something opposite. In this case, it is the opposite direction. So instead of moving right, the turtle should move left this time. Let’s confirm it.

* Test. Yep, the turtle is like a reversing car, it’s head is still pointing to the right, but it moves backward 50 steps, leaving a straight line in front. Cool!

* Of course, another way to move the turtle backward is to just call the “backward” method. But this time, make sure you pass 50 instead of -50, otherwise, the turtle is going to move forward instead. 

* Test. Same as before, the turtle moves backward 50 steps. |
| Direction theory | * OK, so our turtle can move forward and backward. But just having this is not very useful, we can only draw straight lines along the x axis. To draw more complex lines or even shapes, we need to be able to turn the turtle and make it move in directions other than just left and right. 

* To understand how direction works in turtle, let’s imagine a circle with the turtle at its center. Initially, the turtle faces right. But since it can turn and point in any directions other than just left or right, we need a more precise way to specify each direction, this is called “Degrees”. Some of you might already know that a full circle is 360 degrees, right? When the turtle initially points to the right, its degree is 0. Now, as it starts to turn anti-clockwise, its degree increases from 0 to 1, 2 and so on and so forth. When it points straight up,  its degree becomes 90. If it keep turning, the degree increases once again, from 90, to 91, 92 and so on and so forth. When it points to the left, its degree becomes 180. So a 180-degree turn makes the turtle points to a completely opposite direction. Now, if it keeps turning, its degree increases again, from 180 to 181, 182 until it points straight down, when the degree becomes 270. Finally, it keeps increasing from 270 to 271, 272, until back, pointing to the right again, at which point the degree is 360. So it completes a full 360-degree circle. Another interesting thing you can see is that pointing to 0 degree is the same as pointing 360 degree. This is not hard to understand: imagine two persons facing the same direction, one does not move and one turns a full 360-degree circle, eventually, both face the same direction again. So in turns of the direction, 0 degree is the same as 360 degrees.

* OK, for those of you who have learnt Scratch before, all these should sound pretty familiar. In Scratch, we can also change the direction a sprite points to. But there is some slight differences: in Scratch, the up direction is 0 degree instead. Starting from there and turning clockwise, the degree increases and reaches 90 degree when pointing to the right. If we keep turning, it reaches 180 degree when pointing straight down. And then 270 degree when pointing left, and finally back to the starting up direction when the degree increases to 360. This is important to keep in mind, especially when you go back and forth between Scratch and Turtle, things can get messed up if you are not careful enough. |
| “setheading” method | * OK, let’s see how we can change the direction of our turtle. One of the easiest way is to call the “setheading” method on the turtle. This method accepts only one argument, the degree you want the turtle to point to. For example, if I want to turtle to point straight up, I can do <pen.setheading(90)>. 

* Test. Run the code, and there you go, the turtle now points straight up. 

* We can make it point to the left by changing the argument to 180. 

* Test. Run it again and it now points to the left.

* To point straight down, just change the degree argument to 270.

* Test. And now it points straight down.

* Finally, what if we change the degree to 360? Yes, it should still point to the right. Let’s check.

* Test. Yep, no change at all, still points to the right. 

* I don’t know if you noticed something interesting when we turned the turtle 270 degree. From the animation, it seems that, rather than turning anti-clockwise three quarters of the circle, it actually turned clock-wise one quarter of the circle, or 90 degrees, to arrived at the same position. What actually happened is that, when you pass a degree that is greater than 180, the turtle actually turns clockwise with a negative degree. The negative degree is the difference between the degree you pass to “setheading” and 360. So if we call “setheading” with 270, it actually turned into a call to “setheading” with an argument that is difference between 270 and 360, which is -90. So if pass a negative degree, the turtle turns clockwise.

* With this “setheading” method, we are not limited to just these four directions. We can point in any direction, for example I can pass “45” to “setheading”, and it now points to the northeast. Or 135, which makes it point to northwest. So you can pass any degree to “setheading” and it will point the turtle to the direction with that degree. Now, if we call “forward” again with a distance of 50, and run the code, the turtle now moves in the northwest direction for 50 steps and drew an diagonal line. Pretty cool.  |
| “left” and “right” method | * OK, so “setheading” is useful when you want to point the turtle to an exact direction. This is like the “set direction” block in Scratch. But sometimes, we just want to turn the turtle from its current direction a number of degrees left or right. In such case, there are two methods that are more useful than “setheading”: the “left” and “right” methods. Let’s see how to use them!

* They are pretty simple. For example, our turtle initially points to the right, right? Now, if I want it to point straight up, previously, I used the “setheading” method and passed 90 degree to it. An alternative is to call the “left” method and also pass 90 degree to it. This turns the turtle left 90 degrees from its current direction, and makes it point straight up also. Now, from this direction, if we can call method “right” and pass 90 degrees to it, what do you think is going to happen? Yes, the turtle is going to turn right 90 degrees and get back to its starting direction. So this is it, this is how you use the “left” and “right” methods. Of course, you can pass a larger or a smaller degree to make the turtle turn more or less. Super easy! 

* Ok, with just these simple methods to move and turn a turtle, we can now start to draw more complex shapes.  |
| Draw Square outline | * Let’s draw a square first for our modern art painting because this is probably the easiest one to draw. First, before writing any code, think of yourself as a turtle in the window. How would you move to draw a square? Anyone wants to be turtle and tell us how to do it? Ok, very good. Let’s say the length of the side of our square is 100. So here is how a turtle would draw it: the turtle faces right at the beginning, then it moves forward 100 steps to draw one side. Next, it turns left 90 degree, to face straight up. Move forward again 100 steps to draw the second side. Then turns left 90 degrees again, to face left. Move forward again 100 steps to draw the third side. Finally, turn left 90 degrees one more time to face straight down and move 100 steps again the draw the final side. Once this is done, the turtle also goes back to its starting position, although facing a difference direction now. If we want to make it face right again, we can just make it turn left 90 degree for a final time. With all four side drawn, we should now have a square.

* Ok, so this is all just theory in our head, so let’s turn it into code and see if it works as expected. First call “forward” and pass 100 to move the turtle 100 steps. Then turn left by calling “left” and pass 90 degrees. This should draw the first side of the square. Then we just move the turtle forward 100 steps again by calling “forward” and turn left by calling “left” once the second side is drawn. We the just continue with these steps two more times of the finish drawing the entire square. Let’s run it.

* Test. Cool, as you you can see, the turtle moved one side at a time as we have planned and drew a square at the end. Nice!

* Now, if we look at the code again, it is pretty clear that the same two steps repeat for a total of four times: move forward and turn left. Instead of writing them for four times, we can have a loop that runs four iterations, each iteration moves the turtle forward and then turn left. Since we know the total iterations required, which loop do you think is best suited here? Yes, the “for” loop! So, “for” then the loop variable, I’m just gonna call it “i” and then “in”. To iterate four times, we call “range” here and pass number “4” as argument. Then inside the loop, we move the turtle forward 100 steps and then turn left. Now let’s delete all the previous code. 

* Test. Run the program again and we can see the same square being drawn. So the “for” loop version works as before. Perfect!

* Now, there is just a small thing I want to change. Previously when we have a “for” loop, the loop body uses the loop variable in one way or the other, either as a character for a string or as an index for a list. But here, the loop variable “i” is no where to be found in the loop body. It is not needed and is simply there to make sure no component of a “for” loop is missing. Although there is nothing wrong with doing this, if a loop variable is not needed, we can just use an “_” as a placeholder for it. This not only saves us from having to come up with a loop variable name, but also makes it very clear that a loop variable is not needed by the loop at all.  |
| Fill square color | * Ok, now we have a square. But to be more precise, we have the outline of a square. What we eventually want, if you still remember from the demonstration at the beginning of this lesson, are squares filled with different colors. So, let’s first see how to fill a single square with color. 

* Every time you want to fill a shape with some color in turtle, you need to call a pair of turtle methods: “begin_fill” and “end_fill”. “begin_fill” always come before you start drawing the shape and “end_fill” always come after you have finishing drawing the shape. They always come in pair, you can’t fill color with just one and not the other. So here, where did we draw the square? Yes, the “for” loop. So where do you think we should call “begin_fill”? Yes, before the “for” loop, when we have not started drawing yet. And where do you think we should call “end_fill”? Yes, after the “for” loop, when we have finishing drawing. Let’s test this out!

* Test. Now, the turtle first draws the outline of the square as before. But once this is done, it fills the square with orange color! Pretty nice huh?

* Now, the color that’s been used to fill in the square is the same as the turtle itself. Remember, we set the turtle’s color to orange using method “color”, right? So what if we want to fill the square with a different color? Simple, just call method “color” with a different color! For example, if I want the square to be pink, I can call “color” before “begin_fill” and pass the “LightPink” to it. You can find this color name in that color web page I showed you earlier. Let’s run the code again.

* Test. Now, you can see the turtle becomes pink and the square it drew is also pink. Cool! |
| Draw 10 squares | * Ok, in the showcase, we have seen that each shape, including the square is drawn multiple times in the window. Here we only have one, so we need more! Let’s say we want to draw 10 squares in total, how can we do it? Simple, we already have the code to draw a single square, so running that 10 times if going to draw 10 squares right? Sounds like another perfect case for a “for” loop!

* But before that, let’s take a look at the code we have here. What do you think it does? Yes, it draws a square, including picking a color, draw the outline and fill the outline with the color picked. Again, this is a perfect time to make our code better organized. We can create another function call “draw_square”, no need for any parameter, and then just move all the code here inside this new function. Then we can just call “draw_square” here. Now after this change, take a look at the whole program, we have three functions defined at the beginning, then create the “window” and “pen” variables. Now the program actually starts, but since our code is so well organized, we can immediately see all the main task it performs: setting up the window, setting up the pen and finally drawing a square. We can clearly understand the flow of the entire program and its tasks without being buried in the details of how to setup a window, how to set up a pen or how to draw a square. If you are really interested in the details, you can always go straight to the corresponding functions to see how it is done. Hopefully, this once again proves to you why it is important to always organize your code around functions as much as you can. Ok, let’s run the code again to check if it still works.

* Test. Yes, we see a pink square, everything still works as before!

* Right, it’s time to move the “draw_square” function call inside another “for” loop to draw 10 squares! This is pretty easy, “for”, again, we don’t need a loop variable, so just “_”, then “in”, and because we want to run 10 times, so call “range” and pass 10. Finally, indent “draw_square” to move it inside the loop. Now, let’s run it!

* Test. Ok, the loop seems to work, our turtle is now going round and round for 10 times, drawing 10 squares in total. But there is a problem: since all 10 squares are drawn at the same position, they overlap with each other. At the end, we can still just see one square, even though 10 have actually been drawn. 

* So the solution is just to draw each square at a different position in the window. Now, we all know that a turtle starts at the center of the window. What if, after drawing each square, we move it to a different location before drawing the next one? Then we should have 10 squares, each at a different location. So the question is: how do we move a turtle to a new location? When learning of the turtle’s coordinate system, we know that each point or location in the window is determined by a pair of numbers: the x coordinate and the y coordinate. For the example, the center have both coordinates 0. And, guess what, there is a turtle method called “goto” that can move a turtle to any position in the window when passed a pair of coordinates. To how see this work, let’s first comment out this “for” loop temporarily. Then call method “goto” on the “pen” variable to move the turtle to, say, position (150, 200). For that, we pass the x coordinate 150 as the first argument to “goto” and y coordinate 200 as the second argument. Now, this should move the turtle somewhere here in the window. Let’s check!

* Test. Run the code and yes, it did go to the position we expect. But there is a problem, like method “forward” and “backward”, the turtle leaves a trace behind from its initial position to the new position. So remember, a turtle is like a pen, when you move it, it always leave a trace behind unless…Unless what? Unless you tell it not to draw anything while it moves. So how? Once again, we can find some similarities from Scratch. With the Scratch pen extension, when you don’t want the pen to draw anything on the stage, what do you do? Yes, you use the “pen up” block, this is like lifting the pen above the paper so that they do not touch each other anymore. Then when you move the pen, nothing will be drawn. And what if you want to draw again? Simple, you just use the “pen down” block to put the pen back down. Things are very similar in turtle: if you don’t want a turtle to draw anything or leave a trace behind when it moves, you call method “penup” before it moves; and when it has completed its move, you can call “pendown” again to put the pen back down. Let’s test this again!

* Test. Now, the turtle moves to its new position without leaving any trace behind. Perfect!

* OK, now we know how the “goto” method works, let’s first uncomment the “for” loop and delete these test code here. Then, in the “draw_square” function, we first need to move the pen to a new position. Of course, if we move all 10 squares to the same new position, they will still end up overlapping at the new position again, we have not solved our problem. Instead, we need to move each square to a different location. What is the first thing that comes to you mind now? Yes, random numbers! If we can generate random numbers for the x and y coordinates for each square, then they can all be moved to different positions. Let’s do that! To use random numbers, what we need to do first? Yes, we need to import the “random” module. Since the only method we need from this module is “randint” to generate random integers, let’s do <from random import randint>. After this, we can use it now. 

* In “draw_square”, let’s first create two random integers for x and y coordinates. Since our window goes from -300 to 300 in both the horizontal and vertical direction, let’s first use range -300 to 300 for randint. So let’s do <x = randint(-300, 300)> and <y = randint(-300, 300)>. Ok, once we have the random x and y coordinates, we can move the pen to this random position by doing <pen.goto(x,y)>. Also, very important, we need to lift the pen up before calling “goto” and put the pen down after calling “goto”. Right, let’s test it!

* Test. Ok, we can see the turtle is now moving across the window and drew 10 squares, all at different locations. So, our code works! Nice!

* Now, before we move on, I want to once again better organize our code and make things easier to understand. This time, I will focus on the “draw_square” function. It is getting much bigger now and let’s try to go through it to see what are the main tasks it performs: it first move the pen to a random position, then choose a color for the square and finally draw the square. So it’s at least doing three things. But look what we have here now, all the code is just squeezed together without any separation between them. We can do better: we can create a separate function to choose and move the pen to a random position. So let’s define a new function called “pick_position” without any parameters.  Then let’s move all the code from here to “pendown” into this new function and replace them with a call to “pick_position()” instead. Now see? Isn’t that a lot better and clearer? Now, that is the second task? Well, it’s picking a color! How about also creating a function for is? Let’s define “pick_color”, move this single line over here and replace it with a call to “pick_color”. Ok, I know you might be thinking, picking color is just one line of code, is it really worthwhile to create a separate function for it? Well, first of all, a function usually has a pretty meaningful name to tell you for what it does, for example “pick_color”. As you go through the code in “draw_sqaure” and come across “pick_color”, you can immediately tell that this is picking a color for the pen. See how clear the code becomes? Secondly, as we will see later on, picking color is actually more complex than this single line here. Even if you don’t think it is necessary to create a function now, it will make more sense later on. Then we can just leave the rest unchanged, it is the actual code that draws and fills a square.  |
| Decomposition | * So here I want to talk about functions. We have been using functions since the first part of the course. And we know it’s a useful tool to package a bunch of code together so that they can be used later one. And one benefit of of doing this is that the same function can be called again and again, without us needing to write the same code multiple times. This reduces code duplication, and generally leads to less code. In programming, less code is better code. Now, we also begin to see the second main benefit of a function, even if it does not reduces any code duplication, creating functions can break a large piece of code into groups of smaller chunks. Each individual chunk is small enough to manage and understand more easily. Since the large piece of code is now made up of smaller chunks, it is also becomes easier to understand. 

* Think about coming up with a plan for your day. For the first few things to do in the morning, you might put down items like: open my eye, stretch in bed, stand up, go to bathroom, take out tooth brush and tooth paste, squeeze some tooth paste on to my toothbrush, then move the tooth brush left and right, up and down in my mouth, spit in to the sink, and rinse your mouth. Now If you take this to your mum and show her you plan, I’m pretty sure she would get a bit confused, at least the beginning. It will only become clear to her if she really spend time going through each item and finally figure out, aha, you just wake up and brush your teeth, right? Yes, you have only been doing two things: wake up and brush your teeth. The first three items, open my eye, stretch in bed and stand up is just waking up, right? And the rest 6 steps is just brush your teeth! What if I just put down these two items instead? Then your mum would have a much easier time to understand your plan. If she really wants to know exactly how you brush your teeth, maybe this the first time you brush your teeth on your own, she can then ask for all the detailed steps. If she’s not interested in the details, maybe you have already done this many times, then just knowing you do plan to brush your teeth in morning is good enough for her. 

* Does this all sound very similar to our code? In fact, this is something people often do in programming. It is called “decomposition”: we decompose something huge into smaller and more manageable pieces and package them into individual functions. This always make your code clearer to read and easier to understand. So we should keeping do this as much as we can when writing code. |
| “window_width” and “window_height” variables | * Right, back to the code. So our turtle can now draw 10 square at different locations. First I want to fix a small issue. Right now, some of the squares are right at the border of the window, and in fact part of them are even outside the window. This is because the range for x and y coordinates go from edge to edge. So if the turtle happens to start near the edge, that square it draws is going to be outside of the window. To solve this problem, we could limit where the turtle can go. For example, we could create a border that is 100 pixels width along each side so that the turtle can only go to locations inside this smaller window. In this case, even if it draws a square at the border of this smaller window, the final shape is still going to be inside the main window. To create this smaller inner square, we just need to change the ranges for method “randint”: instead of going from -300 to 300, we shrink it to -200 to 200 instead. Let’s test the code again!

* Test. Now, we can see that all 10 squares are inside the main window. Perfect!

* OK, currently, the main window size is 600 by 600, we set it in function “setup_window”. Now, what if we want to change it to 800 by 800. Well, that’s easy, we just change the two arguments here to 800 and 800. But are there anywhere else we need to change? Yes, the border we have just set in “pick_position”. Remember, we want the border to be 100 pixels wide. But if the range is still -200 to 200 when the window has changed to 800 by 800, what do you think width of the border is now? Yes, the border becomes 200 wide. What if we want it to stay 100 pixels wide? Yes, we need to change both ranges to -300 to 300. Now, think about this, everytime we change the window size, we need to remember going into “pick_position” and change the ranges to make sure the border stay at 100. It might not seem that much of a deal here, because you would say, hey, how often do you change the window size? Not a lot, right? And even if you change the window size, it’s not that much work to just update the ranges here. So what’s problem then? Well, yes, you don’t change a window size and yes, changing the two ranges here is not a big deal. But what if you do have something that changes very often? And what if a huge number of things depends on that? Meaning once that something is changed, everything else needs to be updated? Do you still think it’s not a big deal anymore? And I’m not just making this up to scare you, in fact, situation like this are very common in code, especially when the program becomes larger and more complex.

* So we need something better, we want the border to be automatically updated when the window size is changed. How can we do that? Well, the reason border needs to updated is because its value depends on the window size, in other words, we compute the range here based on the value of the size. So with a window size of 600 by 600, how did we come up with a range from -200 to 200? Let’s just look at the axis for now. Its range is from -300 to 300, right? Where does the number 300 comes from, well because the center point divides it evenly into two halves, 300 wide each, so the maximum x coordinate can get is 600 divided by 2, which is equal to 300 and the minimum x coordinate can get is the negative of 600 divided by 2, which is equal to -300. And since we want to border to be 100 wide, the left side of the smaller window is at -300 + 100, which is equal to -200, and the right side of it is at 300 - 100, which is equal to 200. As you can see, the final range depends on what size you choose for the window. Let’s see if you can use the same method to come up with the range when the window size is 800 by 800.

* OK, to be able to update the range automatically when window size is updated, we can’t just use fixed numbers here, because, well, they are fixed and cannot be changed or updated. Instead, we want its value to depend on the window size. But how?  Well, the solution is to create variables for the window width and window height. Let me show you. First, let’s create two global variables “window_width” and “windo_height”. Assign 600 to both. Next, we can replace these two numbers in the “setup” call to “window_width” and “window_height”. So far, we do not seem to be gaining anything. Actually, it looks we have made things worse by adding more code, such as these two variables here. But watch, now go to “pick_position” method, here instead of using fixed numbers -200 and 200 for the range, we can compute them using variables “window_width” and “window_height”. Take the x coordinate as example, as we have shown earlier, the minimum of the range should be the negative of “window_width” divided by 2 plus 100. So let type that in. And the maximum of the range should be “window_width” divided by 2 minus 100. Now if you replace “window_width” with 600 and do the math, you will see that the range is still -200 to 200. Cool. Now, for the y coordinate, it is going to be very similar, we just need to replace variable “window_width” by variable “window_height”. Ok, let test the code first to make sure we have not introduce any bugs. 

* Test. OK, looks ok, all squares drawn by the turtle are still inside the main window. Nice!

* Now, you might think this makes the code more complicated and hard to understand. You are right to certain extent, but the benefit we gain is that, now if we change the size of the main window, for example to 800, there is no need to change the range any more. It will just be updated automatically. That’s a huge time saver!

* Test. let’s run the code again. As you can see, some squares drawn are still very close to the border of the main window but are still inside it. Looks like the border is still 100 pixels wide. Nice!

* To summarize, when a lot of values in your program depend on some common values, meaning you can do some math do get those values from the common values, it is often a good idea to store those common values in variables and then use the variables to work out those values.     |
| Set random color using RGB | * Ok, let’s what other things we can improve here. First thing I notice is that all squares are of the same Pink color. The result is a bit plain and boring. We want the painting to be as colorful as possible, meaning each square should have a different color! This means, when picking a color for the pen, we need to choose a different one each time, instead of just “LightPink”. 

* We have seen a lot of colors you can choose from for a pen or a turtle in this web page. One approach would be to add all those colors in a list and then randomly choose one from the list each time. That’s totally fine, you just need to spend the time to add all those color names in a list. In fact, I made that as an after-class exercise for you. But here, I would like to introduce another even better approach, there is no need to create a huge list with a ton of color names. All you need is a little bit understanding of how color works in computer.

* Now, if you are using a Windows computer, search for “Paint” in the Windows search bar and open the “Paint” application. This is a built-in app that comes with Windows tp draw stuffs. Now, this is not a class about how to use the “Paint” application, but I want to use it to show you how color works. Once the app is open, at the top, you will see a button called “Edit Color”. Click that and a small window should pop up. This is the color palette where you create color of your own. Now, apart from the basic color on the left, you can click the area on the right here to select any color you want. Now, I want you pay attention to these three textboxes here down below, that says R for red, G for green and B for blue. Each time I click a different their number changes, right? For example, if I choose a yellowish color, the values are 177, 231 and 154. If I then click another blueish color, the numbers becomes, XXX, XXX and XXX. So each color has a unique set of RGB values. Now, there is a slider on the right, if I drag it down all the way to the bottom the color becomes pure black, and what do the RGB values become? Yes, they become all 0s. Now, if I drag the slider up instead all the way to the top, the color becomes pure white, and what do the RGB values become this time? Yes, they all become 255. So the range of each RGB value is from 0 to 255. You can set it to any number in between. In fact, all the colors we can ever get comes from mixing of these three colors. Because of this, they are often called “Primary Colors”. 

* So how can we get a random color? Yes, you pick a random value between 0 and 255 for red, a random value between 0 and 255 for green and a random value between 0 and 255 for blue. Then those three random RGB value is going to give you a random color! Simple! And the good news is that, turtle also supports setting pen color using RGB values other than color names. Awesome! Let’s get back to the code and see how this can be done!

* Since we are going to change the way a color is picked for our pen, let’s focus on the “pick_color” method. We no longer want to always set the color to “LightPink”, so let’s delete this line of code. Next, we want to generate random values for red, green and blue. So create a random number in the range 0 and 255 by calling the “randint” method, then assign its return value to a variable called “red”. Next do the same for another variable called “green” and finally do it again for variable “blue”. Now we have three randomly generated RGB values. Time to use them to set a random color for our pen! All we need to do is call method “color” on pen again and pass the three values as arguments. If we run the code now, it gives us an error that says “bad color sequence”. Well, the reason we are having this error is because to use RGB values to set colors, we need to set the color mode first so that turtle knows RGB values are now being used. This is done by calling function “colormode” in the turtle module. Now the question is, where should we call this function. If we call it inside the “pick_color” method, then we are setting the mode each time a color is picked. But is this really necessary? Do we need to tell turtle again and again that we are using RGB values? No! We only need to tell it once! If we only want to tell it once, where do you think we should call it? Yes, I think function “setup_pen” is probably a good place for it. So, at the end of the function, let do “turtle”, dot and then “colormode”. We pass number “255” as the only argument for the function. Now, I don’t want to go into details of this function and why passing 255. You just need to memorize it: if RGB values are used, always call this function with argument 255 beforehand. Cool. Let’s run the code again.

* Test. Wow, did you see that, this time, each square has a different color! it looks so much more interesting! And the colors are totally random, if we run the program again, the colors will be completely different! Nice! |
| Random sizes and directions | * Ok, we have made some really good progress, this is looking more and more like our final painting! But the squares are still a bit too uniform and are lack of variations. They all have the same size and face the same direction. We can make the painting even more interesting by having different sizes and direction for the squares. So let’s work on that next!

* Let’s first pick a random size for each square! In function “draw_square”, we always move the turtle forward 100 steps. That’s why all squares have size 100. To add some randomness, let’s first create a variable “side_length” and assign it a random value from 10 to 150 before the “for” loop. Then instead of passing 100 to “forward”, we pass “side_length” to it. 

* Test. Now, if we run the code again, see, all squares are now of different sizes, some are really big and some are tiny. This looks so much more interesting! 

* To add even more fun, we can make the square all face different directions. So they will be tilted to the left or right. How do we make them tilted? Think about it, right now, the pen or the turtle is always facing right when it draws a square. As a result, all squares a also facing the same direction. But what if we make the pen face a random direction before it starts to draw a square? Would that make all the squares face different directions too? Let’s find out! we already know how to change the direction a turtle faces, right? Yes, we can use the “setheading” method. Since we use a function to pick the color for the pen, let’s create another function to pick the direction of the pen also. I will name it “pick_direction” with no parameters. Inside this function, we just need to call “setheading” on the pen variable, and for the degree argument, let’s pass a random number that is between 0 and 360, because a full circle has 360 degrees. Then we just call “pick_direction” after “pick_color” in function “draw_square”. That’s it! Let run the program again!

* Test. Wow, look at that! Each square not only has a different color, but also tilted differently! Some to the right and some to the left. Our painting is becoming so vibrant and interesting! What a piece of art! Looks absolutely fantastic! |
| Change turtle speed | * OK, before we move on, I would like to address a small issues. Right now, we can see the turtle drawing each square, one after the other. This is useful when we first learn turtle and want to see how the turtle responds to each method call, such moving forward and turning left. But there is problem: this is very slow. Imagine sitting there and watch the turtle draw 100 squares, that’s going to be a very long time. Most of times, we don’t really care about the drawing process, we are only interested in the final product. In other words, we want to the turtle to draw as quickly as possible.  

* Fortunately, there is a method to change the speed of a turtle, and it is called “speed”. You can call this method on a turtle to make it move faster or slower. First of all, where in our code do you think we should call this method? This is going to be part of the setup for our pen or turtle, so calling it in function “setup_pen” seems to be appropriate. So after calling “color”, let’s call “speed” on “pen”.  Now you can pass an integer on a scale from 0 to 10 as argument to this function to represent the turtle’s speed. The bigger the number, the faster the turtle. So 10 is the fastest. Let’s try that.

* Test. Now you can see the turtle moves a lot faster than before!

* What if I change the argument to 1. Let’s try!

* Test. Now as you can see, the turtle goes really slow! 

* Ok, when I say the bigger the number, the faster the turtle, I actually lied to you a little bit. If that were true, the number 0 will be the slowest, right? Let’s try 0 and see what happen! 

* Test. Wow, this is super fast, even faster than speed 10. So number 0 actually has a special meaning: it tells the turtle to move as fast as possible. This is usually the fastest option, faster than speed 10. If you just want things to be done as quickly as possible, pass 0 to method “speed”. |
| Circle | * OK, everything is looking good. To make our painting even more attractive, I would like to add even more shapes: circle, rectangle, triangle, stars etc. Of course, we don’t have the time to add all of them here in the class. I will leave some of them as after-class exercises for you. Here, I would just like to add one more shape, a circle. Similar to drawing squares, I would also like to draw 10 circles, each with its own color and size. Of course, with a circle, the direction does not really matter.

* Right, after this “for” loop that draws 10 square, I would like to add another “for” loop to draw 10 circles. So “for”, underscore, “in”, “range(10)”. In the loop body, we would like to call a function “draw_circle”. Of course, this function does not exist yet, so let’s define it!

* After function “draw_square”, let’s create another function “draw_circle”, again, without any parameters. Right, what do we need to do in the function body? Let’s remind ourselves how we drew a square. First, pick a random location to draw it. Do we need to do that for a circle? Of course! Do we know how to do it? Yes, it’s all in function “pick_position”! So this time things are a lot easier, we just need to call “pick_position” and this should find a new random location for this circle. Easy! Now see the benefit of using functions? Yes, if this is something you do again and again, you can avoid writing the same code by just calling a function to do it! And what did we do next for drawing a square? Yes, we pick a random color for it! Do we need to do that for a circle? Of course! Do we know how to do it? Yes, it’s all in function “pick_color”! We just need to call this function again and job done! When drawing a square, we also pick a direction, but as I said before, direction does not matter for circles, so we can skip this step. Next, we chose the side length for the square at random. So a circle, what do you think determines its size? Yes, the radius, so let’s create a variable “radius” and assign it a random value in the range from 10 to 100. 

* Now, we finally come to actually drawing the circle. When drawing a square we use a loop to move and turn the turtle repeatedly. With a circle, things are surprising easy. There is actually a method named “circle” that you can call on a turtle object. Then you just pass the radius of the circle and this draws one for you! Isn’t that simple? Even simpler than drawing a square! Let’s test this out!

* Test. Wow, after drawing 10 square, it continues to draw 10 circles! But there is a small issue, we only have the outline of all the circles, they are not filled with any color! Well, this is easy to fix, we just forgot to call the “begin_fill” method before drawing the circle and the “end_fill” method after drawing the circle. Let’s add both. Try again! Yes!!!! We have both shapes, the squares and the circles! Looks amazing! What a piece of art! I think I can sell that for millions of dollar at the auction!  |
| create_art function | * Ok, before we call it a day, I want to make our code better organized for one last time. Right now, we have two “for” loop, each drawing one type of shapes. And as we add more type, there will be more “for” loops here. So I would like to create another function and put all “for” loops inside. This function is called “create_art” without any parameters. Then move both “for” loops here, make sure they are indented properly. Then in the global scope, after calling “setup_pen”, we just call “create_art” to draw all the shapes. Now, what the entire program does is very clear to us: it first sets up the window, then sets up the pen, and finally create our amazing art. Three simple steps!

* Test. Now let’s run the code for a final time to check everything still works. Yep, everything still works. Perfect! |
|  |  |

### Exercise

- Draw half-circle, triangles, rectangles and stars
- Use a list of color names to randomly select one for each shape
-