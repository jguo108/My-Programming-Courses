# 6 Virus War

### Reference

### Code

### Key Points

- Turtle Module
    - Combine everything we have learnt before
    

| Steps | Notes |
| --- | --- |
| Outline | * Copy code from “Space Dodge”
* Change costumes to cells and viruses
* Change movement control of player
* Fire bullet (fire from player, collision detection with enemy)
* Add sound (fire and explosion)
* Add sound when game ends
* Add explosion effect
* Add different kinds of viruses
* Add different points for different kinds of viruses |
| Introduction | * OK, everybody, welcome back! So we have come a long way in our Python turtle journey. In the last lesson, we have completed a game “Space Dodge” where you can control a player to dodge some dangerous aliens. The goal is to stay alive for as long as possible. Ok, this is a fun game and we take pride in the amazing work. But we are not going to stop here, games can be made even more fun and exciting if our player can also actively fight back! In a lot of the classic games, such as the “Space Invader”, you can fire missiles from your spaceship to kill the invaders, and score points as a result of that. Now, the game is more even, we are not just something to be hunted, but also hunters ourselves!  

* Ok, to set the background for today’s lesson, let’s turn to biology for a minute. We all know that there are tens of thousands of virus trying to infect the heathy cells in our body at all times. One way to not get sick is to actively defend ourselves by kill those evil virus as soon as they enter our body. Inspired by this, we are going to create a game called “Virus War” in this lesson. 

* Let’s see how it is played. In the game, you, as a healthy cell in the human body, is going to keep looking for and destroying new intruders. You have bullets as your weapon to shoot at the virus, kill them and score points. It starts with just a few virus, but, as we know, one of the reasons why viruses are so hard to deal with is because they can reproduce themselves, meaning their number can grow and grow if they are not killed fast enough. So you really need to work hard! Also, watch out for where the viruses are, because as soon as the cell gets into contact with any one of them, it is infected and dies, game over. As any of our games, you can play this with your friends or families to see who can score the highest points by kill the most viruses!

* So let’s get started! |
| Turn “Space Dodge” to “Virus Dodge” | * Now, let’s first take a look at the game again and compare it with “Space Dodge”. There is the player, which is a cell this time, that we can move around in the window. But it seems that the movement is a bit different: instead of just being able to move up, down, left and right, the cell can move in a lot more different directions. Also, we can make the cell move faster or slower as we wish. This can sometimes be useful to dodge the viruses. Then it’s the viruses. They are just like the aliens in “Space Dodge” that wonder around in the window and bounce back once hitting an edge. Also, viruses can reproduce themselves, so new ones keep showing up as we play. Of course, one major difference is that we now have more than one type of viruses. Then there is the score. In “Space Dodge”, the score increases as time goes by. But here, it increase each time we shoot and kill one virus. Also notice that, the points you score are different for different types of viruses, some worth more points that the others. Of course, one of the biggest differences between the two games is that our player can now fire bullets at the viruses to kill them. 

* Right, based on all these observations between the two games, we can see that they are similar in many places, but there are also differences. So I’m going to cheat a little bit here: instead of building everything from scratch, I’m just gonna copy the code from “Space Dodge” to start with. Now, if you open the folder for this lesson in VS Code, you would see a “main.py” file and a “Resources” folder, just like any of our previous lessons. The “main.py” file is currently empty. Now, unlike before when I would start typing in code line by line, here, let’s steal the code from “Space Dodge”. Open the “main.py” file of “Space Dodge”. Copy all the code, go back to the “main.py” file here and paste it in.

* Ok, although I used the words “cheating” and “stealing” for what I have just done, it is actually nothing wrong to reuse code from a previous project as the foundation for a new one, especially when they are similar in many ways. In fact, this often how we build more and more complex projects or games: you just create new features on top of existing ones! Furthermore, since we have done those basic steps, such as setting up window, switching costumes, moving sprites etc a few times, I don’t want to keep spending time going over the same stuffs again and again. It is going to be a bit dull and it’s not helping you to learn new things. OK, we have some code the start with. Let’s try to run it. I know it is not going to work, but the errors should give us some idea what need to be changed.

* Test. Ok, we are getting an error as expected. It says “Resouces/Enemy/1.gif” cannot be found. OK, that makes sense, because this path was used in the “Space Dodge” game to find image files for the enemy’s costumes. But since we are in a new “Virus War” lesson folder, there is no reason to expect it to still work. Ok, to fix this let’s take a look what the folder structure looks like in this lesson. As we have already see, it also has a “Resources” sub-folder, so nothing wrong with this part. Then, open this folder, and, aha, there is where the problem came from. In “Space Dodge”, we have all the image files in the “Resources” folder as “1.gif”, “2.gif”, “3.gif” and so on and so forth. But here, we are seeing seven subfolders instead: “Virus1”, “Virus2” and all the way to “Virus7”. Why do we have all these subfolders? Well, remember in the game demonstration? We have different types of viruses, they have different colors and shapes. So each subfolder here contains all the costumes for one type of virus. For example, if we open “Virus1”, you can see there are 19 images inside. Open “1.gif”, it’s a blue and kidney shaped virus. All these costume images together would create an animation where the virus shrinks to a smaller size and then grows back to the original size again. So this is “Virus1”, and if you open “Virus2”, we can see a different type of virus what looks like a sun. And again, there are 19 images used to create the same animation. If you are interested, you can open the other 5 folders and see what they look like. 

* So, back to the error. Now, we can clearly see what went wrong, the original path was expecting the image files to be directly inside the “Enemy” folder. But here, the actual image files are inside the seven virus folders. So, let’s change the path to “Resource/Enemy/Virus1”. So we get all the costumes from the first type of virus. Of course, this is going to make all our enemies look the same. But it’s ok for now. Later on, we will see how to add different types of viruses. Ok, let’s run the code again!

* Test. Right, we are getting another error! This time, it’s complaining that image “20.gif” is not found! And the error comes from this line, where we add each costume to the window. Well, yes, sure, we only have 19 images in the “Virus1” folder. So of course there is no “20.gif”. But the real question is, why is our code try to get an image that does not exist? Well, in “Space Dodge”, how many costumes do we have for the aliens? Yes, 31 images. So, the code adds image from 1 all the way to 31. But as we have seen, we only have 19 images here, but the “for” loop here still goes from 0 to 30. Why? Because we pass “num_of_enemy_costumes”, which has value 31, to the “range” function. So since we have fewer number of images, the value for “num_of_enemy_costumes” needs to the changed as well. Let’s go to the top of the file and finds where this variable is defined, and change its initial value to 19. Cool. Let’s test the code again!

* Test. Wow, it works, we have no more errors! And the game has been changed from “Space Dodge” to “Virus Dodge”! We now have a green cell as our player and three blue kidney shaped viruses as enemies. The logic of the game stays the same, we can move the cell up, down, left, or right. And as soon as we hit one of the viruses, the game ends. Also, the background has been changed to the dark blueish one. In case you want to know where the costume for the player and the background come from, take a look at the “Resources” folder again, and you would see the same two sub-folders, “Player” and “Background”. In “Player”, there is a file called “player.gif”, which is just a green cell. In “Backgorund”, there is a file called “background.gif”, which is the new background image. Unlike the enemy, we have not changed any of the previous code that access these images. Why? Well, if you take a look into functions “setup_window” and “setup_player”, you can see that the paths to both images are still the same in this case. So there no need to change anything and the code still works fine. 

* Ok, so just after a few quick changes, we have successfully made “Space Dodge” into “Virus Dodge”! That’s a good start! But of course, this lesson is about a new game called “Virus Wars” and not “Virus Dodge”! Now it is time to get into the real new and cool stuffs! |
| Update up, down, left and right arrow keys | * OK, the first thing we want do is to change how the player is controlled. Previously, we used the four arrow keys to make the player face up, down, left or right, so that I can go in that direction. Now, this is ok for a simple doge game. But when you want to become a hunter yourself and go after the viruses, we need to the player to be more agile. This means it needs to be able to go in directions other than those four. Furthermore, instead of always moving at a constant speed, we want it to be able to speedup or slowdown. The good news is that, we are still going to use the same four arrow keys for all of these. It is just that what the key event handlers do in each case will be different. Let’s take a look at them one by one.

* Ok, let’s go to the “bind_keys” function where we bind all the arrow keys. First, the left and right arrow keys. Right now, they are bound to the “left” and “right” functions. What do those functions do? Yes, they make the sprites points to the left or right using the “setheadinng” method. As I said before, we want the player to be able to point to more directions than just those four. So when the left arrow key is pressed, instead of always pointing to 180 degrees, we want the player to turn some number of degrees to the left from where it is pointing now. So, for example, let’s make it turn left 15 degrees by calling the “left” method and pass 15 as argument. So if the player was point to 0, which is right, then pressing the left arrow key once is going to make it point to 15 degrees, so it is going to travel in that direction. And if I press the left arrow key again, it’s going to turn left again, from 15 degrees to 30 degrees and then travel in that new direction. Pressing the left arrow key is going to turn the player left 15 degrees each time. As you can see, the player can now point to more directions than before. In fact, if you divide 360 degrees, which is a full circle, by 15, you get 24, meaning the player can now point to 24 different directions, comparing to only 4 previously. Of course, just turn left is not enough, we need to be able to turn right as well. This is simple, we just call “right” method on the player in the “right” function. OK, since the “left” and “right” event handlers are not point the player exactly to the left or right now, we also want to change their names. I think “turn_left” and “turn_right” are probably more suitable here. Of course, once you do that, do not forget to update the functions names when binding the keys. Ok, let’s test this.

* Test. Now, as you can see, if I keep pressing the left arrow key again and again, the player gradually turns to the left and the same for the right arrow key, which makes the player gradually turn to the right. Pretty cool! But right now, if I press the up or down arrow keys, the player still goes straight up or straight down immediately. With the new ability to turn left or right gradually, we don’t really need the “up” and “down” event handlers anymore. If the player starts facing right, then you can just press the left arrow key 6 times to make it face straight up and the right arrow key 6 times to make it face straight down. OK, just because we don’t need the “up” and “down” event handlers does not mean we don’t need to handle the up and down arrow key presses! Rather, we want pressing the up arrow key to speed up the player and pressing the down arrow key to slow it down. OK, for these, we can rename the “up” and “down” functions to “speedup” and “slowdown”. Of course, we are not changing the directions in both function. In “speedup”, we want to make the player move faster. How? Well, what controls how fast the player moves? The “player_speed” variable, right? It starts at 2. So to make the player move faster, we can just increase the value of “player_speed” by, say one. Of course, since we are changing the value of a global variable in a function, we need to add the global declaration for “player_speed” at the beginning of the function. Similarly, in “slowdown”, we first add the global declaration, and then decrease the value of “player_speed” by one. Finally, do not forget to bind these two new functions to the up and down arrow keys in “bind_keys”. Ok, let’s test this out!

* Test. Right, now if I press the up arrow key, the player moves faster, and if I press the down arrow, key, it moves slower, and then stops. If I press the down arrow key again, it is going to move backward. Cool. With this, we can make the player go faster to chase the viruses or make it go slow to better dodge them. With the new functionalities we have give to the four arrow keys, you know have a lot more control over how the player moves, this helps a lot when it comes to combat the viruses!   |
| Firing bullet | * Speaking of combatting viruses, we are going to add an attacking mechanism to our player. More specifically, we want be able to fire bullets or missiles, whatever you want to call it, from the player. Whenever a bullet hits an virus, it gets killed and our score increases. Simple as that. Let’s see how this is done.

* First of all, what do you think a bullet is? Yes, it is just another turtle sprite. So, let’s create an other turtle object called “bullet” after the “score” sprite. Now, just like every other sprites, we first want to do some setup for the bullet before it can be used. So let’s create a new function called “setup_bullet” and call it after calling “setup_score”. Now, back to the “setup_bullet” function. First, we do not have any costume images for the bullet. You could find one for yourself if you want to. But here, I would just use a circle for the bullet. So the shape of this turtle should be set to a circle. We can do this by calling the “shape” method on the “bullet” sprite and pass “circle” to it. Ok, next we want to pick a color for the bullet. Now you can pick any color you like. Here, because the cell is green, so I would like to pick a greenish color for it. By checking the color page, I find that “DarkOliveGreen2” looks nice, so let’s use that for the color. Next, we don’t want the bullet to draw anything on the window, so call “penup” and we want it to move as fast as possible, so calling “speed” and pass 0. Let’s test this.

* Test. Ok, we see a greenish circle in the middle of the stage. But I think it’s too big to be a bullet, we need to shrink it down a little bit. To change the size of a turtle, you can use the method “shapesize”. It has two most important parameters: “stretch_wid” and “stretch_len”. “stretch_wid” changes the size of the turtle vertical, that is up and down, and “stretch_len” changes the size horizontally, that is left and right. By default, both are set to 1. Say you just want the width to be half of its original size and the length stays unchanged, then pass 0.5 for “stretch_width” and 1 for “stretch_len”. Let’s see what it looks like now. Ok, it looks as if the circle has been squeezed from both above and below, and now it is more of an oval shape. What if we still want it to be a circle? Well, we just make its length half of its original size by pass 0.5 for “stretch_len” as well. OK, now, the shape becomes a circle again. Ok, we are pass numbers smaller than 1 to both parameter to make the shape smaller, but you can also pass numbers larger than 1 to make the shape bigger. For example, if I pass 5 to both parameters, then the circle becomes really big. Of course, this does not look like a bullet anymore. Even passing 0.5 to both parameters is not making the bullet small enough. Actually, I think 0.3 seems to be the right size. Let’s see. Yep, I think it looks perfect. Finally, when the bullet was first created, we don’t want it to be hidden. It should only show up when it is actually fired from the player. So let’s call “hideturtle” at the end. Ok, the bullet cannot be seen now. But we know it’s there, right at the center of the window.

* Ok, the bullet is ready, the next question is: how do we fire it? To fire a bullet, we can use a key again, for example, the space bar. So, looks like we need some key binding again. Go to the “bind_keys” function, after bind the four arrow keys, let’s bind one more for the space key. Back in lesson “Bouncing Around”, we bind an event handler to the space key to stop the animation. We know that the name of the key is “space”, with a lower case “s”. Then it’s the event handler function to bind to. Let’s create a new function called “fire” and bind the space key to it. We don’t know how to fire the bullet yet, so let’s just print “Space pressed!” in the “fire” function. Let’s test the code.

* Test. Ok, once the game starts, whenever we press the space key, we see message “Space pressed!”. The binding works. We can delete the print in “fire” now.

* Ok, how exactly do we fire a bullet? Let’s think about it. A bullet is fired from the player right? Currently, it is right in the center of the window. So the first step is to move it to where the player is. Let’s call “goto” on the bullet. Since we are going to the player’s position, the two arguments should be the player’s x and y coordinates. And we already know how to get the turtle’s x and y coordinates, right? For the x coordinate, we call “xcor” method and for y coordinate, we call “ycor” method. Ok, once the bullet is at the player’s position, what should we do next? Well, remember it is hidden now. So before it is fired, we need to make it visible again. This can be done by calling the “showturtle” method on the bullet. Ok, let’s test what we have now.

* Test. OK, if I press the space key, well, we do see the bullet showing up at the player’s position. But since the player keeps moving, while the bullet is not, it is left behind, until we press the space key again, at which point it goes to player’s current position again. Not bad.  

* Ok, the next problem we need to solve is how to make the bullet move! Well, let me ask you this first, how do we make the player and enemies move? Yes, we call “move_player” and “move_enemies” each iteration of the game loop to move them forward a number of steps each time. Since the bullet is nothing but another sprite, we can move it in a similar way. First, let’s create a new function called “move_bullet”. And the function is pretty simple, just call “forward” on the bullet sprite. Of course, we need to pass a number for how many steps to move forward. Just like we have speed variables for player and enemies, let’s define a new variable called “bullet_speed”. Because we want to bullet to travel fast, let’s assign 5 to it. Then back to “move_bullet”, let’s pass “bullet_speed” as argument to “forward”. Finally, to actually move the bullet, we need to call “move_bullet” in the game loop. Let’s do it after calling “move_enemies”. OK, let’s give this a test.

* Test. Ok, let me press space. Hmmmm…seems the bullet is not firing at the right direction. For example, when my player is going left, the bullet is firing to the right, exactly the opposite direction. And it doesn’t matter where my player is going, the bullet always seem to be fired to the right. Weird! Can any one explain why? Yes, brilliant! Remember what we did before the bullet is fired? Yes, we move it to where it player is and then show it, right? Then as the game loop runs, the bullet is moved and it gets fired. But when preparing it, did we ever say which direction it should go? No, right? Now, we should all know by now that a turtle sprite faces right by default. If you don’t change that, it will always face right! Since we do not change its direction at all, the bullet is always going to move to the right when fired. So what do you think we should do here? Yes, when preparing the bullet, we should also make it point to the player’s direction. So it will move in the same direction as the player. Ok, in function “fired”, after moving to the player’s position, we also want to point it to the player’s direction. To set a sprite’s direction, we can call the “setheading” method. Which heading? The player’s heading? How do we know the player’s heading? Well, a common practice in any python module is that, if you can set some value, then most likely, there is also a way to get that value back. If not, then how can you know the value you have just set. So same with heading in turtle, it gives you a way to set the heading using “setheading” method, then there must be a way to get the heading back. And this method is called “heading”. So to get the heading of the player, we just need to call “heading” on the player sprite and pass its return value as argument to “setheading”. This entire line now reads “Set the bullet’s heading to the player’s heading!” Exactly what we need! Let’s test this!

* Test. Now, see? When I press the space bar to fire the bullet, it travels in the same direction as the player. Doesn’t matter where the player goes, it’s always the same. Perfect!

* But there seems to be a problem. Notice what happens when I press the space key multiple times. See that? Every time, the bullet goes straight back to the player and fires again, doesn’t matter where it is at the moment. This looks strange, it just feels like there is a string attached to the bullet to keep pulling it back to the player again and again. But if we look at our code closely, this is not difficult to understand. What is the first thing you do when the space key is pressed? Yes, we move the bullet back to where it player is in the “fired” function. That’s the “string” that pulls it back!

* OK, let’s think about what we really want to happen here. First of all, in this game, we only want one bullet to be fired at a time. This means, if one is fired, then pressing the space key should not fire any more. I know that in some games, you can fire multiple bullets at the same time. This is perfectly fine. It’s just a design decision I made for my game. Of course, you can modify the game here to fire multiple bullets. In fact, this will be one of the after class exercises for you! 

* Ok, next, let’s see how we achieve that. Currently, we are kind of firing only one bullet at a time, because when one is fired, if you press the space key again, that one bullet goes back to the player and fires again. There is always just one bullet. That’s good. But what is not good is that the bullet goes back to the player too soon. What do I mean by “too soon”? Well, it’s too soon because the bullet is still moving in the window when we pull it back! When is the right time to move it back to the player and fire again then? Yes, when it is outside of the window! Once that is the case, it has finished firing and can be fired again. Whether we can fire a bullet when pressing the space key totally depends on if the bullet is still “firing”. So what does it mean for a bullet to be “firing”? Well, think about it, if the bullet is still in the window, meaning we can still see it, then clearly we don’t want to fire it again. Because if we do, then it will look like it’s been pulled back to the player. However, if the bullet goes beyond the edges of the window, meaning we cannot see it anymore, then for us it is gone and we can fire it again. Simple as that!

* So just like the game can be in either stopped or non-stopped state, a bullet can also be in one of two states: firing and not firing. We can only fire a bullet if it is in the “not firing” state. For the game state, we defined a variable “stopped” with either True or False value to indicate if the game has stopped or not. Similarly, for the bullet state, we can also define a new variable called “firing” with either True or False value to indicate if the bullet is firing or not. Initially, we assign False to it because the bullet is not fired before the game starts. Now that we have a variable to tell us what state a bullet is in, we can use that information to decide whether to fire the bullet when space key is pressed. Go back to the “fire” function, instead of always get the bullet ready to be fired, we add a check: if the bullet is NOT firing, then we do all of these. Here, we use the “not” logical operator on the “firing” state variable to check if the bullet is not firing. Let’s test this.

* Test. Ok, if I press the space key multiple times, looks like everything stays the same. We still have the same problem, the bullet gets pulled back to the player when it is still firing. What are we missing here? Let’s take a look at the “fire” function again. Initially, “firing” is False, so the if condition is True and we get the bullet ready to be fired. Then what happen when we press the space key again? Well, “firing” is still False and the if condition is still True. Meaning we are getting the bullet ready again. Do you see the problem? Yes, the problem is that, although we have a state variable “firing” and set the initial state to be “not firing”, but when the get the bullet ready to be fired, its state should no longer be “not firing”. It should change to “firing” at this point because it is about to move and leave the player. To change its state, all we need to do is to assign True to it in the if statement. That is once we get the bullet ready, we change it state to “firing”. Of course, always remember to add the global declaration for any variable you want to change in a function. Let’s test this again!

* Test. Ok, we first fire a bullet, and when this bullet is still firing, Iet me press the space key again, this time, no more bullet is fired. Awesome! But there is new problem, when that bullet goes out of the window, it should be ok to fire again, right? But what happen is, no matter how many times I press the space key, no bullet is fired again. Our player becomes a one-trick pony, it has only one bullet to fire and that’s it! This does not sound too good. 

* Let’s analyze our code carefully again. Now, once the bullet is fired, variable “firing” is set to True, right? And this prevents it from being fired again when the bullet is still firing. That’s good. But the problem is, it also stops the bullet from being fired again when the bullet is not firing! When does the bullet goes from “firing” to “not firing”? Yes, when it goes out of the window. That’s when its state should be changed back to “not firing”. But did we do that? No! Once we set “firing” to True, it stays True forever. No wonder why we cannot fire any more! So what should we do? Yes, we should check if the bullet collides with any of the edges of the window, and if so, we change its state back to “not firing”. Now, we have been doing such edge collision check many times, right? For the player and for the enemies. So do so after moving them forward each time. So same for the bullet, we check if it hits the edge, and if so, set “firing” back to False. Since the code for edge collision check is already there, we just copy it from either “move_player” or “move_enemies” and paste it in “move_bullet”. Of course, this time we are checking for the bullet, so change the “player” variable to “bullet”. And the boundary conditions stay the same. When collision happens, we just assign False to “firing”. Again, since we are changing the value of global variable “firing”, let’s add a global declaration for it at the beginning of the function. Let’s test this again.

* Test. Yes, as soon as the bullet collides with the edge, we can then press the space key and fire the bullet again! But before that, pressing the pace key has no effect what so ever! Awesome!

* Ok, before we move on, I would like to make one small change to better organize our code! If you look at the three functions “move_player”, “move_enemies” and “move_bullet”, do you notice something similar? Yes, they all have the same “if” condition to check if a sprite collides with one of the window edges. And to be honest, this condition is quite complex, with four sub-conditions joined by the “or” logical operator. So I think it’s worthwhile to create a separate function just for this condition. I’m gonna call this function “collide_with_edge”. Given a turtle sprite, it is going to check if this sprites collides with any of the window edges. If so, it returns True, otherwise it returns False. So, this function should accept one parameter, the sprite for which we want to check for collision. I’m just gonna call it “sprite”. Then, inside this function, we just return the value of this complex condition. If this condition is True, then it return True, meaning the sprite has collided with on of the edges. Otherwise, it returns False, meaning there is no collision. Of course, we need to change the “player” variable to the parameter “sprite”. Now, once this function is defined, we can replace the if condition in all three functions with a call this one. In “move_player”, we call this function and pass the “player” variable as argument; in “move_enemies”, we call this function and pass the “enemy” variable as argument; and finally in “move_bullet”, we call this function and pass the “bullet” variable as argument. Take at look at this after all the changes, it makes the code so much simpler and clearer! Very nice! Let’s test the code again to make sure everything still works!

* Test. Yep, player and enemies can still bounce back when colliding the with the edges. We can still fire bullet one at a time. Nothing is broken and our changes work nicely! |
| Bullet hits enemies | * So we can fire bullet at the viruses now. There is just a small problem: the bullet causes no harm to the viruses at all! It just passes through the viruses without destroying them! A bullet like this is not very useful and the whole point of having it in the first place is so that we can start fighting back and killing viruses! This has to be fixed!

* For the bullet to actually hit a virus and kill it, we first need to check if it collides with the virus or not. Previously, we have checked collision between the player and the viruses, right? Do you think it is going to be different checking collision between the bullet and the viruses? No, a bullet is just another sprite, so the collision check should be the same, right? Let’s go to the “check_collision” function. Currently, it is going through all the enemies one by one, and check if any one is colliding with the player. Now, with the new bullet sprite, we also need to check if any enemy is colliding with the bullet. 

* So let’s add another “for” loop to go through all the enemies again. This time, inside the loop, we add another if statement to check if the distance between the bullet and the current enemy is less than 20. Ok, what should we do if this condition is True, meaning the bullet hits the enemy? Well, first of all, since the enemy is hit by a bullet, we want it to be killed, right? Ok, what exactly does it mean for an enemy to be killed? Well, if an enemy is killed, then it should not exist anymore right? Ok, where do we currently store all the enemies? Yes, in the “enemies” list. So if an enemy does not exist anymore, we should first remove it from the list, right? Ok, how do we remove an item from a list. Yes, we use the “remove” list method. So let’s call it on the “enemies” list and pass the current enemy to remove. Next, if the enemy is removed, then we should not be able to see it in the window anymore, which means it should be hidden. So let’s call “hideturtle” on the enemy. OK, let’s test this!

* Test. Now, I’m aiming at an enemy and …. fired! Cool, it hits the target and the enemy is gone! But there is a problem, our bullet moves on! Ideally, we want to the bullet to stop moving when it hits an enemy. But how? Let me give you some hint! We know that the bullet can be in one of two states: firing and not not firing, right? So, do you think the bullet should move in the firing or not firing state? Not firing, of course! But before the bullet hits the enemy, which state do you think it is in? Firing, right? So, to stop it when hitting an enemy, what should we do with its state? Yes, we should change it from firing to not firing. This means in this if statement, we should also set firing to False. Now, every importantly, and I myself often make this mistake: when you change the value of a global variable in a function, for example, changing the value of “firing” here, always, always add a global declaration for it at the beginning of the function! We already have a global declaration for the “stopped” variable, let’s just add “firing” after it, do not forget the comma. 

* Test. Let’s test this again! OK, let me the player in place and … fire! Boom, it hit the enemy, but unfortunately, the bullet still moves on! Seems changing the state to “not firing” has not effect at all! Have we done anything wrong? Can you spot the problem? Let me ask you a question, which function moves the bullet? Yes, the “move_bullet” function! Now, let’s take a look at that. Ok, the first line of the of code moves the bullet forward. But do we ever check the bullet’s state before moving it? No, right? So doesn’t matter whether the bullet is firing or not, we always move it forward. Does this sound right to you? No! In fact, we should only move the bullet when its state is “firing”. If it is “not firing”, then there is no need to move it at all! Luckily, the fix the pretty simple, we just need to add an “if” statement to check if the state is “firing”, and we only move the bullet if so. Now, do we need to move the collision check inside the if statement as well? I think so. Because it is only possible that the bullet collides with an edge after it has moved. If it has not moved, then is there no chance that it can ever collide with an edge. So let’s move the collision check inside as well. Let’s test this again! Ok, ready and … fired! Ok, we hit and kill the enemy, the good news is that the bullet stopped moving and stayed at where the enemy was. And it only went back to the player when we fired again. One quick fix is just to hide the bullet when it hits an enemy. SO back in the “check_collision” funciton, after setting the bullet’s “state” to False, we can hide it by calling “hideturtle” method on the “bullet” variable. Let’s test his again. Yes, this time, whenever the bullet hits enemy, it is hidden, the enemy is killed and we can fire again! Nice! But I can tell you that there is still a bug here that can cause some strange behavior. I will not go into the details and I will leave this as an exercise for you to try after class.  |
| Fix score | * OK, now we can fire bullet and kill enemies. But if you take a look at the score text at the upper left corner, it does not look quiet right. Remember, we base our code on the “Space Dodge” game. In that game, the score increases when time goes by. So the longer the player can stay alive in the game, the higher his/her score is. But here, the goal is different, we no long try to stay alive for as long as possible, although that is still very important, we want to kill as many viruses as possible before our healthy cell is infected. So, we want to increase the player’s score for each virus killed. Let’s see how the code should be changed.

* Previously, we set up a repeated timer using the “ontimer” method to increase the score every second. As we have discussed earlier, this is no longer the way to go. Let’s fix that first. Here, we do not need to call “ontimer” with the “update_score” function any more. So let’s delete this line of code. Then go to the “update_score” function, again, no need to call “ontimer” any more, so let’s also delete this line. 

* Ok, previously, this “update_score” function was called every second and that’s how the score is increased. Since we have delete all the “ontimer” function calls, there is no more timers and we get to decide when the score should be increased. When do you think we should update the score? Yes, whenever we killed a virus. Where do we check if our bullet has hit and kill a virus? Yes, inside the “check_collision” function. And to be more exact, inside this if statement here. So, when the bullet collides with an enemy, we should also increase the score by calling the “update_score” function. Let’s test this!

* Test. Now, notice that after the game starts, unlike before, the score stays at zero. Now, I’m gonna start shooting. As soon as I kill a virus, my score is increased by one. And the more I killed, the higher my score is. Perfect! Of course, some game will make the score increased by 10 instead of just one each time. It’s a personal preference and totally update to you. If you want to make that change, just go to the “update_score” function and change the increment from one to 10. Now, whenever I kill a virus, my score is increased by 10. This probably gives you a better sense of achievement!  |
| Add firing sound and killed sound | * So the main features of the game are pretty much all done! You play it yourself, or with your friends and families to have some competition. But I have to say, the game still looks pretty unpolished. Think about any of your favorite game, it is attractive not just because of the way it is played, but also because of all the cool sounds and visual effects. All these together make a good game. Again, for your favorite game, just imagine stripping out all the sounds and effects, would that still look attractive to you? Probably not! So sounds and visual effects also play a very important role in any games. So far, none of our animations or games have any sounds! That’s a shame! Let’s change that! Let’s add some cool sounds to our “Virus War” and make it an even better game! 

* To add and play sounds in a python turtle program, we need some external help because the turtle module does not come with any tools to do that. There are a lot of python module that can handle sounds, here, I picked one called “pygame”. Now, from this name, you can probably tell that this is a module for creating games in Python. If this what you think, then congratulations, you are absolutely spot on! Pygame is a very powerful and probably the most popular module for creating games in Python, way more powerful than turtle. The reason we use turtle in this course is because it is simple and therefore a better tool for beginners to learn about python programming in general and game programming specifically. But to create even more complex and advanced games, you need more powerful module such as Pygame. In fact, if you decide to enroll in my Python course in Game Programming, you are going to learn a lot about Pygame and use it to create many exciting games. But that’s not for today’s lesson, and you might wonder why do we need game module to handle sounds? Well, two reasons: first, Pygame does come with some useful tools to for sounds, and secondly, I just want to give you some taste of this popular game module. 

* Ok, so far, we have been using various modules, such as random, time, turtle etc. To use them, all we did was to import them first. And this is the same with the pygame module, to use it, you need to import it. So, at the top of the file, let’s first import pygame, it’s “P-Y-G-A-M-E”. Ok, let’s run this. 

* Test. Ouch, we have an error! What does it say? “ModuleNotFoundError: No module name ‘pygame’”. Ok, I think the message is pretty self-explanatory: Python cannot find a module named “Pygame”. But why? With module such as “random” and “turtle”, we just import them and they are available for use right away. Why is the pygame module different? Well, when it comes to where modules can be found, there are two types of modules: the first type are the built-in ones that come by Python. You know when you first use Python, you need to install it first, right? And when you do that, it install a bunch of builit-in modules that you can just start using without doing anything, examples are the random, time and turtle modules. The second type are the third-party ones that does not come with the installation. So before you can import and use them in your code, you need to install them separately first. Otherwise, Python is going to complain that it cannot find the modules and gives you this error. The next question is, how can we install a third party module? Well, this is pretty simple in VS Code. All you need to do is select the “Teminal” dropdown menu, click “New Terminal”, then a new terminal or console is going to be open at the bottom. Then you just need to type in the command to install a new module in python. This command is “pip” which stands for “Python Installer Package”, this is the python tool to manage all your third-party modules, such as installing new modules, displaying existing modules and deleting old modules. To install new modules, type in “install” after “pip” Then finally, type in the name of the module you want to install. In this case, we want to install “pygame”, so just type in “pygame”. That’s it. Then hit return, and you are going to see a bunch of outputs, which is basically telling you python is installing pygame. And then after a while, you should see a line which says “Successfully installed pygame” and the numbers after “pygame” is just the version of it. OK, now, pygame is installed, we can start using it! If you now run the code again, the error should be gone and the game starts normally. Cool!

* Ok, next, let’s think about what sounds we want to add to our game. Any idea? Yes, very good. So I think we need at least three sounds: first one is then the player fires a bullet, the second one is when an enemy is killed by the bullet and the last one is when the player is infected and the game ends. Of course, you can think of more cases where a sound is needed. Now, if you take a look at this lesson’s folder, you would see a new one called “Sounds”. Open that and there are three “.mp3” files. “mp3” files are the most popular type of audio files. Click on each one in VS code, and you can play them to hear what they sounds like. Pretty cool huh? Ok, so our task is to use the right tools in Pygame so that we can play these sounds at the right time in our game.

* Still remember how we use the external image files as costumes for sprites? Yes, we first load them one by one into the window, then use them to set shapes for the sprites. For audio files, the logic is similar, we first need to load and store them somewhere in our program, and only then can we play them later on. So let’s first create a new function called “setup_sounds” to add the sound files. Let’s call it after setting the up the bullet. Inside “setup_sounds”, we need to add our audio files one by one. This is done by the “mixer” module inside the “pygame” module. Yes, the “pygame” module has a submodule inside it that is called “mixer”. This might be new to you, because previously, we only see methods and classes inside a module, but you can have submodules inside a module as well. The “mixer” submodule allows you to load, play and control audio files, such as the mp3 files. To access this submodule, just like accessing a method in a module, we first use the parent module “pygame”, then a dot, and the submodule name “mixer”. Now, “mixer” has a method called “init”, which is short for “initialize”, that you must call before using any functions of this submodule. To call it, we just add one more dot after “mixer” and the method name “init”. This method requires no arguments, so just a pair of empty parentheses.  

* Next, we can start loading our audio files in to the game. Now, back in lesson “Modern Art”, when we first learnt about creating a screen/window, I explained that the “Screen” method in the turtle module as being a special method that creates and returns a screen object for you, right? Still remember that? And methods like these often start with a capital letter. The other example being the “Turtle” method in the “turtle” module, which creates and returns a turtle object for us. And we have been using turtle objects as pens or sprites in all previous lessons. Now, in pygame’s submodule “mixer”, there is also a special method called “Sound” that you can use to create a Sound object by loading an audio file. We call it by writing “pygame.mixer.Sound”. Now, this method requires an argument to tell it where to find the audio file. So what do you think the argument should be? Yes, just like an image file, this should be the path to the audio file you want to load. So what is the path to the “fire.mp3” audio file? Yes, it’s “Resources/Sounds/fire.mp3”. Let’s pass this string to the “Sound” method. So what this is going to do is it loads that audio file into our program, create a Sound object for this audio file and returns it. Ok, that’s how you load the sounds. We can do the same for the other two audio files: “killed.mp3” and “gameover.mp3”. Ok, all three audio files have been loaded. But just like the turtle objects, we need to store them somewhere so that we can use them later on. For the turtle sprites, we use variables, for example, “player” and “bullet”. We could also use variables for the Sound objects, maybe “fire_sound”, “killed_sound” and “gameover_sound”. But there is a problem with this approach. In large games, there could be a lot of sounds files, maybe tens, or even hundreds of them. Do you want to create tens or even hundreds of variables? Of course not! But luckily, we know how to store a collection of items in Python, right? What is the first things that comes to you mind? Yes, list! Can we try to use a list to store the three sounds objects here? Of course, let’s give it a go! First, in the global scope, let’s create a new list variable called “sounds” and assign an empty list to it. OK, then back inside the “setup_sounds” function, let’s add the Sound objects returned from “Sound” method one by one. Here, we could create a local variable and call it “sound”, then assign the return value to this local variable. Then append “sound” to the “sounds” list. Then we could do the same for the other two Sound objects. Of course, we could also make this simpler by passing the return value of method “Sound” as argument to the “append” method directly without ever needing a local variable, like this. Theses two ways are the same, but I personally prefer the second one with less typing. Ok, so all three audio files have been loaded into the Sounds objects, and the Sounds object are added to the “sounds” list. Things are all setup and it’s time to play the sounds at the right moment!

* Ok, let’s look at them one by one. First question, when should we play the “fire” sound? Yes, when the bullet is fired! And when is the bullet fired? Yes, when the space key is pressed! So, let’s go to the “fire” function. We fire the bullet in the if statement, so let’s also play the fire sound here as well. But how? Well, we already have the fire Sound object in the “sounds” list, right? If we can get it back somehow, then we should be able to figure out how to play it. Do you still remember which list item is the fire sound object? Yes, the first one! So let’s get it back first by using 0 to index the “sounds” list. Once we have the Sound object, we can just call the “play” method to play it! Simple as that! No argument, just call “play.” OK, let’s test this.

* Test. Now, when the game starts, let me press the space key a couple of times to fire some bullets. Wow, did you hear that? We have the firing sound each time we shot at a virus. So cool! And just by adding this simple sound, the game becomes much more exciting! Do you see the power of sounds in games? Right, let’s play the other two sounds!

* The second one is the killed sound, we should play that whenever an enemy is killed. Question again, when is an enemy killed? Yes, it is killed when a bullet hits it! And when does a bullet hits it? Yes, in the “check_collision” function where there distance between the enemy and the bullet is less than 20. So the killed sound should be played here. This Sound object is the second item in the sounds list, so let’s do <sounds[1].play()> in this if statement. Now let’s test his!

* Test. Ok, ready and fire! Boom!!! We can hear a explosion sounds when a virus is killed by a bullet. Awesome!

* And finally, when should we play the game over sound? Yes, when the game is over! When is game over? Yes, when our healthy cell is infected by a virus and the game loop ends! So in the “game_loop” function, we should play the game over sound after the “while” loop. Since this is the third item in the list, let’s do “sounds[2].play()”. Test it again!

* Test. Let’s try to run into one of the viruses to get infected. The game stops and we hear the game over sound! Nice!

* Ok, all three sounds have been loaded and play at the right moment. This is all good. But there is something I don’t quite like about the code. Currently, we use a list to store all three sounds. Whenever we want to play a sound, we have to remember there that sound is in the list so that we can use the right index. This is ok, for three sounds, but imagine having 100 sounds, and try to remember the list position of each sound! This is going to be crazy! And if you get the position wrong, then you play the wrong sound. There must be a better way than using a list! In part one of this course, we have learnt two useful containers to store a collection of items, one is list and what is the other one? Can anyone remember? Yes, a dictionary! Can anyone remind us what a dictionary is? Yes, it is a collection of key-value pairs. The benefit of a dictionary is that, given a key, you can quickly get the value associated with it. For example, given a person’s name, you can quickly find his/her number in a phonebook; given the title of a book, you can quickly find that book in a library etc etc. Dictionary is everywhere!

* So, do you think we can use dictionary to store the Sound objects? And if so, why is it better than a list? Ok, let’s first figure out what are the values we want to store in this dictionary? Yes, same as the list, we want to store all three Sound objects. Here, I just want to point out that the values of a dictionary can be anything, although we mostly use strings previously. But you can put any type of values: strings, numbers, objects or even lists! With a dictionary, whenever you store a value, you also need to think about what are the keys for those values. Because we are going to use the keys to find the Sound objects later on, the keys should be easy to remember and maybe even tell you something about the value. Any suggestions? Right, we could just use the names of the sound as keys! For example, the fire sound object could have string “fire” as the its key in the dictionary, and similarly for the killed and game over sounds, we could use strings “killed” and “gameover” as their keys. Ok, with both keys and values worked out, let’s see how we can use a sounds dictionary instead.

* First, go to the “sounds” variable, since it is going to be dictionary instead, we assign it with an empty dictionary by using a pair of empty curly brackets. Next, go to “setup_sounds” function. Since “sounds” is a dictionary now, we cannot use the “append” method to add Sound objects any more. Does anyone still remember how we add key-value pairs to a dictionary? Yes, we type in the name of the dictionary, which is “sounds”, followed by a pair of square brackets. In the bracket is the key, for the first sound object, its key is string “fire”. Then we assign the value to this. The value is just the Sound object for the fire, we can copy the “append” method’s argument and paste it here. This is it! We have added a pair with key “fire” and a fire Sound object into the “sounds” dictionary. The other two are similar, we use strings “killed” and “gameover” for their keys and the sound objects can again be copied from the two “append” methods. After this, we can also delete the three “append” method calls. 

* Right, with all three sounds objects in the dictionary now, we have a better way to access them when it’s time to play. First, go to the “fire” function. When playing the “fire” sound, we no longer need to use index 0 to get the sound object. Instead, we can use the key “fire” to get the object from the dictionary “sounds”. Once we have the sound object, playing it is the same as before, just call the “play” method. OK, next, go to the “check_collision” function, again, when playing the killed sound when a virus is killed, there is no need to use index 1 any more. We can simply use string “killed” to get the sound object from the “sounds” dictionary and play it. Finally, go to the end of the game loop, use key ‘gameover’ to get the sound object for game over and play it. That’s it, we have change from using a list to using a dictionary to store all three Sound objects. And the benefits is pretty obvious, instead of using meaningless index numbers to get the Sound objects, we can now use meaningful strings to get them instead. This is way easier to remember, and more importantly, you would have not problem getting a sound object even if you have 100 of them, you just need to remember the name of the sound you want to get. Of course, this will only be a good solution is everything still works as before! So let’s test this out.

* Test. We are going to test all three cases and see if the right sound is player. First, let me press the space key to fire a bullet, and yes, the fire sound is play. Now, let me try to kill a virus with my bullet, and, yes, we the here the explosive killed sound. Awesome! Finally, let me try to run into a virus and yes, the game stops and we hear the game over sound! So all works perfect! Nice! |
| Explosion effect | * OK, with just three simple sounds added, our game has become so much more exciting than before! But you know what, we can make it even better! Currently, when a virus is killed, we hear an explosive sound, that’s good. But the virus just disappears immediately without any visual effect. Think about an explosion, what would you see? Yes, you would see smoke, waves and light, all  within a very short amount of time. That’s what an explosion should look like. So we want to add some cool visual effects to the virus when it is killed and exploded. Of course, it won’t be as fancy as a real explosion. We just want to create some small particles that radiated from the virus and quickly disappear outside of the screen. Let’s see how this can be done.

* First, what do you think a particle should be in our program? Yes, a particle is just another turtle sprite! Of course, one particle is not going to create the effect we want. As you can see, there are a dozen of them, which means we also need a dozen of turtle sprites. And what is the best way to store all of them? Yes, a list or a dictionary. At the moment, I don’t know whether I would use some keys to find the particles, so I would just use a list for now. If it turns out that a dictionary is more appropriate, I can always to go back and change it later on. So let’s define a new variable called “particles” and assign an empty list to it. OK, the next thing thing we need to decide is how many particles do we need. Well, there isn’t a single answer for that, you can have more or less, up to you. Here, I find the explosion effect looks good with 20 particles, so I will create 20 of them. Let’s first define a new variable called “num_of_particles” and assign 20 to it. 

* Ok, next we need to create all the particles, similar to what we did to the first three virus sprites. Let’s define a new function called “setup_particles” and call it after “setup_sounds”. Inside this function, we are going to create the particles one by one. So first, a for loop with “rang(num_of_particles)”. In the loop, we first create a new turtle object and assign it to a local variable called “particle”. This is one particle sprite. Then we need to get it ready for the explosion effect. First, we need to pick a shape for it. To be honest, you can choose any shape, circle, square, triangle, doesn’t really matter, as long as you think it looks good. For me, I personally like circle, so I’m going to set the particle’s shape to “circle” by calling the “shape” method and pass string “circle” as argument. 

* Next, remember when we create the bullet sprite, its size was way too big initially, right? So what did we do to make it smaller? Yes, we call the “shapesize” method and pass two number arguments that represent its stretch width and stretch length, but numbers are smaller than one, meaning we want final shape to be smaller than its original size. For the bullet, we use 0.3 for both and the final size looks good. Here, you of course don’t want to have a huge particle, right? The reason it is called a particle is because, well, it is small. So if we do nothing, the particle will be way to big. And the solution? Yes, we call “shapesize” method on the “particle” variable again. I think a particle should be even smaller than a bullet, so let’s pass 0.1 for both stretch width and stretch length. This should make the particle small enough. If not, we can always come back here and make those numbers even smaller. 

* Next, we need to pick a color for it. Now, because this is a particle from an explosion, I think the color should be close to red, orange or yellow. Again, you are free to choose whatever color you like, maybe even green or blue, totally up to you. Now, here I don’t just want to pick one color for all 20 particles. Instead, I want to have a list of colors to randomly pick from. Now, way way back in lesson “Pick Your Team”, we have learnt a pretty cool way to randomly select an item from a list. Can anyone still recall that? Yes, we can use the “choice” method in the “random” module. So let’s first call the “color” method on the “particle” variable to set its color. Now, for the color argument, instead of passing a single color string, we are going to call the “choice” method of the random module to randomly select a color from a list. Next, we are going to pass the color list as argument to “choice”. For the colors, let’s open the color web page again. Here, I would just pick those that look close to red, orange or yellow. So these are the ones I pick and let’s put that into the color list: “orange”, “red3”, “goldenrod”, “salmon2” and “orchid2”. Again, you don’t have to use these and you are free to choose any colors you like. Right, so this is going to choose a random color or our particle.

* Next, we of course don’t want the particles to draw anything in our window, so let’s call “penup”. And at the beginning when no viruses are killed, we don’t want to see any of the particles, so let’s call “hideturtle”. And finally, let’s add this new particle to our “particles” list. OK, once this “for” loop and the “setup_particles” function completes, we should have 20 particles ready. 

* Next, it’s time to think about when and how we want the explosion to happen. For the first question, it’s simple, the explosion happens when a virus is killed. This means we need to do something in the “check_collision” function. More precisely, the changes should be inside this “if” statement when a bullet hits an enemy. Ok, next question is what should we do here? Let’s think about it. Where are all those particles after they have been created in function “setup_particles”? Did we move them anywhere? No! So they should all start at the default position, which is just the center of the window. But when an explosion happens, we want all the particles to be radiated from the enemy that has just been killed. This means we need to move all of them to the enemy first. Ok, let’s do that in this “if” statement. After hiding the bullet, let’s add a “for” to go through all the particles. For each particle, we call “goto” to move it to the enemy’s position. So the x coordinate is “enemy.xcor()” and the y coordinate is “enemy.ycor()”. Ok, what else do you think we should do here? Aha, yes, remember, when the particles are first created, we hide them all. Now, an explosion is happening, and they should all be made visible. So, let’s call “showturtle” on the particle. Ok, I think that’s pretty much all we need to prepare the particles for an explosion for the time being. Let’s test what we’ve got!

* OK, what else do we need to do? Again, which direction do all the particles point to after they have been created? Since we have not changed any of their directions, so by default, they all point to the right. But when an explosion happens, the particles should fly out in all sort of directions, right? So, for each particle, we want it to point to a random direction. Let’s call the “setheading” method on the particle and pass a random number between 0 and 360. Cool. 

* Test. Let me fire a bullet at one of the viruses. Yes, it got hit and notice that, after the enemy is gone, there is a very small dot showing up at it’s position. And this is our particles. But of course, because all 20 of them are at the same position, so they are overlaying on top of each other, so we can only see one particle. Cool!

* Ok, next we need to move the particles. Just like every other sprites in our game, we define a new function called “move_particles” and call it in the game loop after checking collision. Inside this function, all we need to do is just to go through all the particles using a for loop and move each one forward. So how many steps should we move them each time? Well, since explosion is usually very powerful, so the particles should move at a relatively high speed. For this, let’s define a new variable called “particle_speed” and assign 5 to it. Now, let’s pass “particle_speed” to the “forward” method. Let’s test this out!

* Test. Right when our bullet hits an enemy, we hear the explosion and the particles. But there is a problem: it seems that all 20 particles are going in the same direction to the right? Why is that? Well, which direction do you think all the particles point to after they have been created? Did we change their direction? No! So by default, they are still pointing to the right when the explosion happened. That why you see all of them going to the right. But what should an explosion really looks like? Yes, the particles should fly out in all sorts of directions, right? So, for each particle, we want it to point to a random direction after they have move to the virus that was hit by the bullet. So, go back to the “check_collision” function, after moving a particle to the enemy’s position, let’s call the “setheading” method on the particle and pass a random number between 0 and 360. This makes each particle point to a different direction. Let’s test this again!

* Test. Fire and hit an enemy, and do you see that, this is what I’m talking about and this is what an explosion should look like. So cool! Let me just fire a few more, aha, this is fun! Such a cool effect!   |
| Multiple Virus Types | * OK, we have come a very long way and have a pretty decent game now. We can move, doge, shoot and score. And there is score to keep track of how well we have done. But there is just one thing that still bothers me: the look of the enemies is a bit dull. We only have one type of virus with blue kidney-shape. And if you take a look at the subfolder in “Enemy” in “Resources”, you would see 7 subfolders, from “Virus1” to “Virus7”. We have looked at them at the beginning of the class. Each folder contains all the costumes of a particular type of virus. And they are all here for a reason: we want to have different types of viruses in the game! For one thing, this makes the game look more interesting. Also, you could make each virus type worth different points, for example kill a virus of type 2 might get you 20 points instead of 10, so on so forth. Overall, having more types of viruses makes the game more interesting. So let’s make use of all types of viruses in our game! 

* Currently, we only use all the image files in subfolder “Virus1”. We load all of them into the window. We also add all the paths to them in the “enemy_costumes” list. Now, to be able create all seven types of viruses, the first thing we need to do is to load all images in all seven subfolders into the window. Let’s take a look at function “setup_enemies”. The first “for” loop here only loads images in subfolder “Virus1”. We need to change that. But how? Well, we want to go through all subfolders one by one, for each subfolder, we load all images in that subfolder into the window. Now the names of the subfolder are pretty uniform, they all start with the word “Virus” and then a number. So if we go through numbers from 1 to 7, and for each number, we can get the subfoder name by simply join the word “Virus” and that number. Sounds like a for loop? Yes. Let’s try. So “for”, and I would call the loop variable “t” which is short for “type”. Then the range is 7. So, loop variable “t” is going to go from 0 to 6, which is not exactly 1 to 7. But that’s fine, we just need to add one get the numbers we want. Now, what should we do inside this loop? Yes, we should just go through the current virus subfolder and load all the image files into the window. Do we have the code do this yet? Of course, it’s the previous for loop here. So we just need to move it inside this new for loop by indenting it properly. Now, we have what is often called a “nested for loop”. Meaning you have a for loop inside another for loop. Although this might be the first time we come across it, it is actually pretty common in code. Essentially, the outer for loop goes over all the subfolders one by one, and the inner for loop goes over all the image files in that subfolder. Do you think this would work? Are we really loading all the images in all subfolders? Yes, brilliant! We have a bug here! Can everybody see it? Yes, for the file path string, we still use subfolder “Virus1”. So what is going to happen? Yes, the outer folder iterates 7 times, and each time, the inner for loop just loads the images in “Virus1” again and again. We never load images in all the other subfolders! Ouch! So what should we do? Yes, we have a outer loop variable called “t” and it’s time to use it! The values of “t” go from 0 to 6, right? If we add one to “t”, its values are going from 1 to 7 instead. Hmmm…1 to 7, sounds like the numbers in the subfolder names, right? And where should we use that number? Yes, in the path string. Instead of always having “Virus1”, let’s replace that number one by the “t+1”. Of course, since this is an f-string, we need to enclose it by a pair of curly brackets. 

* Ok, this might be a bit difficult to understand initially. Let’s go over the nested for loop step by step. For the first iteration of the outer loop, what is the value of “t”? Yes, it’s 0. Now, we enter the body of it and start running the inner for loop. The loop variable “i” of this for loops goes from 0 to 18. So the value of “i” in the first iteration is also 0. Since both “t” and “i” are zero, when we run the code inside the inner for loop, the path string is pointing to subfolder “Virus{t+1}” which is “Virus1” and image file “{i+1}.gif” which is “1.gif”. Ok, that gives us the first image in the first subfolder. Then the inner for loop continues with its second iteration, when the value of “i” becomes 1. Note that the value of outer loop variable “t” is still 0, because we are still running the first iteration of the outer loop. So this time, the path string is still pointing to subfolder “Virus1”, but the image changes to “2.gif”. So the inner for loop continues until all 19 images are loaded, by which time, it finally completes. Now, very importantly, it’s time for the outer loop to run its second iteration. This time, the value of “t” becomes one. And once the second iteration of the outer loop starts, we start running the inner for loop again. And its loop variable “i” goes from 0 to 18 again. But this time, since “t” is one, the path string now points to all the image files in subfolder “Virus2” instead. So this continues on, until we go through and load all the images files in all the subfolders. 

* Ok, before we move on, I would like to define a new variable for the number of virus types. It’s called “num_of_enemy_types” and we assign 7 to it. Now we can change the range number from 7 to “num_of_enmey_types”. OK, let’s test the code!

* Test. OK, nothing is changed, and the game works exactly as before. This makes sense, because we just loaded a bunch of extra images without using them at all. So of course nothing is gonna change. Having said that, let’s see how we can use those extra images to create different types of viruses.

* Ok, first thing first, we need to start using costumes of different virus types when creating an enemy. Where do we create an enemy? Yes, inside the “create_enemy” function. So this “shape” method call sets the initial costume of the newly creatred enemy. Right now, which costume did we use? Yes, always the first item of the “enemy_costumes” list. Hmmmm….ok, what is the first item of this list? Yes, it is going to be the first image of “Virus1”, that’s why all viruses have a blue kidney shape, because that’s what Virus1 looks like. But since we have a total of 7 different virus types now, we want each new enemy to have a random type selected from those seven. But how? The “enemy_costumes” list now contains a total of 19 * 7 = 133 costumes, because there are 7 different types of viruses and each type has 19 costume images. To create an enemy with a random type, we need to randomly pick a costume from this list. But it cannot just be any costume, because the enemy needs to start with the first costume of a virus type. So for example, if an enemy is to have type 3, the initial costume for it should be the 39th item in the “enemy_costumes” list. Why, because type 1 and type 2 have a total of 38 images. So the first costume of type 3 starts at the 39th position. Similarly, if the type if 5, the initial costume for the enemy should be the 77th item in the list. So the index for “enemy_costumes” can not be 0 always. It should depend on the type of the enemy you want to create.

* But how? Let me ask you a question, if I give you the type of the virus as a number, which means it can be from 1 to 7, would you be able to work out the index of the its first costume in the “enemy_costumes” list? Let’s try! For example, if the virus type is 1, we already know that the index of its first costume is 0, right? Now, if the type is 2, what would be the index of its first costume? Well, we just need to skip the first 19 items, which are all costumes for the first virus type, and then the 20th item is the first costume of virus type 2, whose index is 19. Remember, indices in a list always start at 0. Ok, move one, how about virus type 3? What would be the index of its first costume? Well, starting from the 20th item, we skip 19 items again, and the 39th item is the first costume of virus type 3, whose index is 38. And this continues on, the index of the first costume of virus type 4 is 57, and for type 5, it’s 76, for 6, it’s 95 and for type 7 it’s 114. So, if we list all 7 indices of the first costumes of all the virus types, that is 0, 19, 38, 57, 76, 95 and 114, do you notice some pattern? Yes, the number sequence starts at 0 and increases by 19 each time. So give a virus type number, can you now find the corresponding index of its first costume? Aha, brilliant. We can come up a very simple formula to do that! So if the type number is “t”, then the corresponding index is just “(t-1)*19”! Don’t take my words for it, try yourself! Say the type is 2, then 2 minus 1 is 1, and then times 19 is 19, which is the index of its first costume! How about type 5? Well, 5 minus 1 is 4, and then times 19 is 76, again, this is exactly the index of its first costume! Wonderful! So let’s get all these into python code!

* In function “create_enemy”, after creating a new enemy, let’s first pick a random virus type. This is just a random number from 1 to 7. And we should already know how to do that: let’s call the “randint” method of the “random” module, and pass arguments 1 and “num_of_enemy_types” as the lower and upper bound. The variable “num_of_enemy_types” has value 7. Then assign the return value to a local variable called “virus_type”. Ok, now “virus_type” has a random value between 1 and 7. Next, to select the initial costume for our enemy, we no longer always pick the first item of the “enemy_costumes” list, instead, based on what we have just learnt, we can use forumla “(virus_type - 1) * num_of_enemy_costumes” work out the correct index. The variable “num_of_enemy_costumes” has value 19. Ok, these changes should give each new enemy a different costumes. Let’s test if it is the case!

* Test. Ok, the game starts, but….the three enemies are still type one. Have we don’t something wrong here? Well, the code we have just changed in “create_enemy” function only sets the initial costume of each enemy. But remember, once the same starts, each enemy keeps changing its costume. Would it be possible that, our enemies did start with different initial costumes, but when they start changing costumes, it all went back to type one again? How can we verify our assumption? Well, what if we just stop the enemies from changing costumes? If we can do that, then their costumes will just stay at the initial ones and never change. How can we do that? Simple, let’s just comment out the function call to “switch_enemy_costume”. Once we do that, the costumes never change. Let’s see what happen this time! Wow, see that? All three enemies are having different types! Our change works! Yes yes, I know, I know, they are not changing costumes anymore and we certainly have a problem with that. But at least it shows that our enemies do have different types! That’s a step forward! Cool! Ok, let’s get the line back.

* OK, the code works. But having to come up with a formula to work out the index of each enemy’s costume is a bit hard to digest. That’s not a good news for people who write the code or people who try to read and understand your code. We want to have a simpler way to achieve the same result. Ok, let’s take a look back at the change here. Previously, the “enemy_costumes” list just contains all the costumes for a single virus type. Now, it contains all costumes of seven virus types, right? So, can we think of it as containing 7 different lists, one for each virus type? Sure! So all we are doing here is just that, given a type number between 1 and 7, find the one of the seven costume lists for that virus type, and get the first costume from that list, right? Now, when you try to find something based on some other value, what does that remind you of? Yes, dictionary! You are given a key and try to find the value associated with that key, right? What is the key here? Yes, it’s the type number! And what is its associated value? Well, the value is the costume list for that virus type! So what if we have a dictionary, where the key is the type number and the associated value with is a list of costumes? Then, when we have a randomly picked type number, we can go straight to the dictionary and get the corresponding costume list. After that, to set the initial costume for an enemy, all we need to do is just pick the first item from its costume list. Can you see how things become so much simpler? At this point, you might be thinking “Are you suggesting that we use an integer as the key and a list as the value for a dictionary? Is that even possible?” If that’s what you are thinking, then good job! I’m glad that you are in doubt! This is because previously, it seems that we mostly use strings for both keys and values. But in fact, with a dictionary, you can use anything for values: integers, floats, strings, lists, or even dictionaries, virtually anything. There is no limitation at all! For keys, you can still use integers or strings, but it’s slight more restricted. For example, you cannot use lists or dictionary as keys. But who is crazy enough to use a list for keys anyway? 

* Ok, to achieve all these, the first thing we need to do is to turn “enemy_costumes” from a list to a dictionary. Let’s go to the top of the file where is was defined. Instead of assigning an empty list, we assign it an empty dictionary. What do you think would happen if I run the code now? Would it work? Probably not because we have just changed something from a list to a dictionary. So surely, some code is going to blow up some where! But let’s run it any way, so that we know where things can go wrong!

* Test. Aha, as expected, we have an error! It points to this line in function “setup_enemies”, the message says “’dict’ object has not attribute ‘append’”. This basically says, a dictionary does not have a method called “append”, so calling it is an error! Ok, that makes sense, because we have just changed “enemy_costumes” to a dictionary and there is no method named “append” for a dictionary. So what can we do? Well, let’s use the dictionary way to add values then! As we have discussed before, the key for the dictionary is the type number, and the corresponding value is a list of costumes for that virus type. Let’s look at both one by one. First, do we have a type number? Yes, it’s just this loop variable “t”. Yes, it’s from 0 to 6 now, but we can just add one to it to make it go from 1 to 7. No big deal! Next, the value. It’s going to be a list of 19 costumes. Do we have that yet? Not really, we need to create it. But where? Well, we need to create such costume list for each virus type, right? And where do we have a new virus type? Yes, for each iteration of the outer for loop. Whenever a new iteration stars, we need a new costume list for that virus type. So inside the outer for loop and just before the inner for loop starts, let’s create a new empty list called “costumes”. This is the costume list for the current virus type. Now, we enter the inner for loop, which loads all costumes for the current virus type. So instead of adding each costume to “enemy_costumes”, which is wrong because it is a dictionary now, we add it to the “costumes” list instead. So the inner for loop is going through all 19 costume images for the current virus type, and when it completes, we not only loaded all 19 images into the window, but also added them to the “costumes” list. And this list is going to be the value of our “enemy_costumes” dictionary! So when should we add the pair to the dictionary? Yes, after the inner for loop is completed. After it, we do “enemy_costumes”, then the key, which is “t+1”, and assign it a value, which is the “costumes” list we have just completed. Ok, after adding storing the list of costumes for the current virus type, the outer for loop is going to iterate again for the next virus type, and the whole process repeats. After the outer loop is finally completed, our “enemy_costumes” dictionary is going to contain all costumes for all seven virus types, with the type number being the key, and the list of costumes for each virus type being the value! Right, we should have fixed the error and let’s run the code again!

* Test. Ah, we have more error! Let’s see what it says this time. The line that caused error is this one in “create_enemy” function. It says “KeyError: 114”. Ok, the number “114” here is the key value and python is complaining that this is not a right key. Ok, first, we have to be aware that “enemy_costumes” here is no longer a list anymore. What is it now? Yes, it is a dictionary. So instead of indexing a list, we are trying to get a value from a dictionary. Now what key did we used? Well, we use whatever this formula gives us. According to the error message, the key seems to be 114. This is because the randomly picked type number was 7, and this gives us 114. But we only used this formula to get the index of the first costume of the current virus type from a list. However, “enemy_costumes” have become a dictionary now, and we know that there are only 7 pairs in it, with they keys ranging from 1 to 7. So 114 is obviously a wrong key. So where can we get the key now? Yes, it’s just the “virus_type” local variable here. This is a randomly picked number from 1 to 7, exactly what we need! So no need for any formula, we can just replace it with “virus_type”! But are we done yet? Let me ask you, what is the values in this dictionary? Yes, it’s costume lists. So what we are getting here is a costume list for the current virus type. But are we going to pass the entire list to method “shape”? Of course not! We just need to pass the first item of that list. So what should we do? Yes, just use index 0 to get the first item! So here although we use two pairs of square brackets after dictionary “enemy_costumes”, but they have different meaning: the first pair is for getting the costume list assocaited with key “virus_type”; while the second pair is for getting the first item of that list using index 0. If this is the first time you see such code, it might be a bit hard to comprehend. But if you just take it slow, and go step by step, it’s actually pretty clear what the code does. And the benefit of doing all these is that the code much simpler now! Ok, let’s run it one more time and see if we have fixed all problems since we have changed “enemy_costumes” from a list to a dictionary. 

* Test. Ouch, there is still error. This time, it comes from “switch_enemy_costumes”. Let’s see what went wrong here. The line that caused problem is this one where we call the “shape” method. It’s KeyError again and this time the wrong key is 0. Let’s check where this number comes from. So “i” is a global variable that was initialized to 0, right? Now, when this function is run, “i” was zero. So in the for loop, we use i, which is zero to index “enemy_costumes”. And again, since “enemy_costumes” is a dictionary now, and its keys range from 1 to 7, but not including 0. That’s why Python thinks you are passing a wrong key. Again, this is because we were using “enemy_costumes” as a list before, but now it’s a dictionary so everything falls apart. So what should we really do here? Well, ideally, we should go over all the enemies, for each enemy, we want to get its type number, and then we use that type number as key to get the enemy’s costume list from the dictionary. And finally, we can use “i” to index that costume list. So, as long as we can get the type number for each enemy, the rest is not very different from setting the initial costume for each enemy in “create_enemy” function. So the one million question is, how do we know the type number for each enemy here? Currently, there is no way for us to get the enemy’s type number because the “enemies” list only stores enemies. So how can we also store each enemy’s corresponding type number? Hmmm…sounds like we are going to store pairs of values again! How about using a dictionary? Use the enemies as keys and their type numbers as values? Let’s give it a try!

* First, go there where “enemies” is defined. Currently, it is initialized as an empty list. Let’s change to an empty dictionary. After this, the first change we need to make is how we add an enemy. Go to function “create_enemy”. Currently, we are calling the “append” method to add an enemy. But since now “enemies” is a dictionary, this would no longer work. Here, we are going to use the enemy as key and its type number “enemy_type” as value, and add this pair into the dictionary. So let’s do “enemies[enemy] = enemy_type”. As you can see, even a turtle object can be used as key for a dictionary. Now both the enemy and its type number are stored in the “enemies” dictionary. So back to function “switch_enemy_costume”. Here, we are not just going to go through all enemies, but also their corresponding type numbers. So go though all pairs of a dictionary, we need to make some changes to our for loop. Of all the for loops we have seen so far, there is always just one loop variable, right? Now, when you go through a dictionary, it’s often the case that you need both the key and the value of each pair. In this case, we are going to create two for loop variables, one for the key and one for its value, I would name them “enemy” and “enemy_type” in this case. Then it is still the “in” keyword. Now, for a list, we can just have the variable “enemies” at the end. But for a dictionary, it’s slightly different: you need to call a method named “items” on the “enemies” dictionary to get all the items to loop through. This method has no parameters, so just a pair of empty parentheses. With this loop header, it is going to go through each pair in the dictionary, for each iteration, loop variable “enemy” is going to store the current enemy and “enemy_type” is going to store the current enemy’s type number. Ok, with the enemy and its type number available, switching the costume is super easy! We call the “shape” method again on loop variable “enemy”. Then we use loop variable “enemy_type” as key to get the enemy’s costume list from “enemy_costumes” dictionary. Of course, this is not going to be the final argument passed to the “shape” method since it’s a list. To pass the costume, we need to use the global variable “i” again as index for this list. Let’s add another pair of square brackets at the end and use variable “i”as index. So the first time “switch_enemy_costume” is run, “i” is zero, this for loop changes all enemies to their first costumes. Then “i” becomes 1, and the next time this function runs, it changes all enemies to their second costumes, so on and so forth. So all enemies, although they have different types, can all change their costumes at the same time. Phew, that’s quite some change. Time to see if we have achieved our goal. What is our goal again? Yes, we want to have different types of enemies! Let’s run the code!

* Test. Hooray!!!! We did it! We have different types of enemies! And they can still animate nicely! We have a pretty nice game! nb |
|  |  |
|  |  |

### Exercise

- Fire multiple bullets at the same time
- There is a bug in our code: when the bullet hit and killed an enemy, it stays at the enemy’s place. We cannot see it because it’s hidden. But it’s there. This means, before we fire it again, it will remain at that place. The problem is, when another enemy happens to get close enough to this hidden bullet, it will be killed. Because according to our code, as long as an enemy and the bullet gets close enough, it is consider a hit and the enemy is killed, even if the bullet is not visible. This can leads to some strange behavior in our game: when you are just moving the player around not firing, you would sometimes see an enemy gets kill somewhere else in the window out of the blue. Can you fix this?
- Can you make each enemy worth different points. For example, virus1 is worth 10 points, virus 2 is worth 20 points, and so on