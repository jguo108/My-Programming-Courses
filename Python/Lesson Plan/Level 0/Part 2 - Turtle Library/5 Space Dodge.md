# 5 Space Dodge

### Reference

https://www.freepik.com/free-vector/funny-cartoon-cute-virus-bacteria-set-isolated-white_13110265.htm#fromView=search&page=1&position=1&uuid=24951a18-30f3-41cd-9da7-8e086019a6fc

https://www.freepik.com/free-vector/hand-drawn-virus-collection-concept_7274749.htm#fromView=search&page=2&position=50&uuid=c9f765ca-a0e3-42ac-a51f-fd51c81c75ba

### Code

### Key Points

- Turtle Module
    - Use keys tp control the movement of turtles
    - Use Turtle to create Game Score
    - How to end a game
    - Collision checking
    - Use list to manage game characters
- Programming Concepts
    - Iterate through a list

(TODO: This is currently set in the context of “Virus Dodge”, need to update that)

| Steps | Notes |
| --- | --- |
| Introduction | * OK, welcome back, it’s a brand new day and a brand new lesson! Since the beginning of the second part of this course, we get to know and play with the Python turtle module to do a lot of fun things: we use it to draw interesting shapes, create animations with image sequence and move the sprites around in the window. We use a series of small projects to demonstrate how to do each. Although they might seem very simple and not too exciting, but remember, we are just creating the basic building blocks for 
even more exciting and fun games. And since we are all turtle expert now, it’s time to finally take on even bigger challenge! In this and the next projects, we are going to combine everything we know about Turtle, plus some new knowledge, to create two full games.

* Ok, we all know that there are tens of thousands of virus trying to attack the heathy cells in our body at all times. One way to not get sick is to avoid being infected by those evil virus. Inspired by this, we are going to create a game called “Virus Dodge” in this lesson. In this game, you, as a healthy cell in the human body, is going to try as hard as possible to void being infected by the viruses around you. The longer you can stay alive, the higher your score is! But it is not that easy! As time goes by, viruses are going to reproduce themselves. More and more of them are joining for the hunt for a health cell. As a result, it becomes harder and harder to not be infected. As soon as your cell touches one of the viruses, that’s it, game over! Now, you can play this with your friends or families to see who can stay healthy for the longest!

* Sounds fun? Let’s build the game! |
| Planning | * OK, as a project or a game becomes more and more complex, it is important make some plan before actually starting coding. This gives us a clear path to follow and it’s less likely to make big mistakes. Of course, we are not trying to get everything right, and there will always be surprises and unexpected things along the way. But a rough plan can make sure we always head in the right direction, that is good enough.

* OK, based on the demonstration I showed you earlier, what sprites do you think we have in the game? Yes, we have the player, a health cell. What else? Yes, the viruses, how many of them? Well, initially there are three and as the game continues, more and more viruses are reproduced. What else do we have in the game? Aha, yes, this is something new, we have a score in the upper left corner. And it keeps increasing as we play the game. Yes, we also have some background, that’s good! Ok, I think these are pretty much all the main things in our game.

* Once you have figured out all the sprites, the next thing we should consider is how should they behave. Let’s go one by one. First, the player. Well it’s controlled by us. We use the four arrow keys on the keyboard to make it go up, left, right and down to dodge the virues, right? That’s it. Next, the virues. These are not controlled by us, instead, they are controlled by our code to move randomly. Also notice that, when a virus hits the edge of the window, it bounces back. Does that remind you something else? Yes, the jellyfish in the last lesson. They seem to be very similar or even identical! OK, apart from moving around, what else does a virus do? Yes, looks like it has some kind animation: its size just shrinks and grows back again and again. As we will see later on, this effect is achieve by using a sequence a costumes, just like the animation we did for the jellyfish. Right, what else is special about the virus? Yes, their number can grow. As the game continues, more and more virus are reproduced and ready to attack. This is something new that we should pay attention to. Ok, the next is the score. Looks like it’s some kind of text that can change as time goes by. We don’t know how to do that yet, but that’s another thing too keep an eye on. So I think this covers all the important points about the sprites.  |
| Window setup | * Ok, let’s start coding. First, as always, we would quickly write the code the setup the window. Import the turtle module, call the “Screen” method to create a screen object and assign it to a “window” variable. Then call the “mainloop” method on the “window” variable to keep it open. 

* Next, create a function called “setup_window”. In the function, call the “title” method to set the title to “Virus Dodge”. Now, same as the last lesson, we are going to use an image for the window background. In the “Resources” folder of this lesson, there is a subfolder called “Background”, and inside there is just one image named “background.gif”. There is nothing too special about this image, it’s just a deep blue background and we are going to use it for the window. To set the window size properly so that this image can fit in nicely, what should we do? Yes, we first need to figure out the width and height of this image. So, right click the image and select “Reveal in File Explorer”. Now, the folder that contains this image is open up. Then right click the image here, choose  “Properties”, and in the window that pops up, choose the “Details” tab and here you can see that its width is 600 pixels and its height is also 600 pixels. So these are the sizes we are going to use for our window.

* Get back to the code, define two variables “window_width” and “window_height”, assign 600 to both. Then inside “setup_window”, call the “setup” method on the “window” variable and pass “window_width” and “window_height” as arguments. Finally, we need to use the image as the background. How can we do that? Yes, we call the “bgpic” method on “window” and pass the file path to the image file. The path is “Resources/Background/background.gif”.

* Finally, never forget to call “setup_window”. Ok, let’s test the code.

* Test. Cool, the window is a 600x600 square with our space image fits in nicely as the background. Nice!

* Ok, so I have been going through all the code very quickly here because we have been doing something like this for many times by now and I want to save our time for the more exciting stuffs. If you find this a bit hard to follow, you can also always go back to watch the replay of previous lessons to refresh your mind.  |
| Player | * OK, the stage is set, time to bring on the star of the show: our player! After the “window” variable, create another one called “player”. Now, we could call the variable “cell”, but I chose to make it more general and name it “player”. The benefit of doing this is that, if later on, I want to change the game to, say, spaceship avoiding aliens, then I don’t have to change the variable name to “spaceship”, it can just stay as “player”. Because, after all, pretty all much all games have at least one player of some sort. OK, that’s just a side note. Next, let’s call the “Turtle” method to create a turtle object and assign it to “player”. 

* After that, create a new function called “setup_player” that is going to be used to set the player up. The first thing we want to do is to give a player it’s costume. Again, in the lesson’s folder, there is a subfolder called “Player” and inside there is an image file called “player.gif”. If you open it up in VS code, you can see it’s a green cell. Pretty cute! We want to use this for our player. But remember, to use any costume for a sprite, we first need to add that costume image to the window by calling the “addshape” method. So let’s call that on the “window” variable, and the path to the image is “Resources/Player/player.gif”. Then we can use this image as costume of the player by calling the “shape” method on “player”. Now, here we need to pass the same path string again to “shape”. So, it’s better if we create a local variable “path” and assign the string to this variable. Then we can use it as argument to both method calls. Ok, for now, I would just have the player start at the center of the window. Since this is the default position any new turtle is going to start at, nothing needs to be done here. Of course, if you want it start at some random position, you can do it, and the code would be pretty much the same as the jellyfish in the last lesson. Finally, very important, because we are not going to use “player” as a pen to draw anything, we need to call its “penup” method so that it does not leave a trace behind when moving.

* OK, let’s call “setup_player” after setting up the window. Let’s run the code.

* Test. Ok, cool, we see the green cell right at the center of the stage. Of course, it is not doing anything right now and we have no way to move it. Let’s work on that next!

* Ok, in the last lesson, we have learnt how use keyboard keys to control the program. The idea is that you bind a key to a user-defined function. That function, or the key event handler, is going to do whatever you want the program to do when that key is pressed. We bind the space key to a “stop” function so that when it is pressed, the function changes the program state to “stopped”. This allows the infinite game loop to break and the animation to stop.

* Ok, here we want to use keyboard keys to control how the player moves. More specifically, we want to use the four arrow keys. Let’s first understand the control logic for player movement. When the game starts, the player starts moving right away in whatever direction it is currently facing. We all know that, by default, any turtle sprite is created facing right. So, initially, it’s going to move to the right. Then what the four arrow keys are going to be used for? Well, they are used to change the player’s direction. If I press the up arrow key, the player is going to face straight up and start to move in that direction. Same with the other three arrow keys. One final thing we need to consider is that what should happen if the player’s has not been changed before it hits into one of the edges? Well, we could just do what the jellyfish does, bounce back! Simple! OK, things are getting much clearer now, first, we want the player to move forever, just like the jellyfish. Then we want to bind arrows keys so that they can be used to change the player’s direction, and finally, it should bounce back whenever it hits an edge. With all these combined together, we can control where the player goes in the window. Sounds good? Let’s get coding! 

* First, we want the player to move forever. And guess what, we have done exact just that in the previous lesson. If we open up last lesson’s file, here is what we need: a “game_loop” function that contain a forever loop. Inside that loop, just  move the player. So we can copy the “game_loop” function and the “move_jellyfish” function over here. For the “game_loop” function, we don’t know  what the stopping condition should look like yet, so let’s just delete the “if statement” for the time being. Also, the function that moves the player should be called “move_player” rather than “move_jellyfish”. Then inside the “move_player” function, let’s change variable “jellyfish“ to “player” in all places. There is also another variable called “jellyfish_speed” which determines how fast the jellyfish moves. Of course, here we are going to create a global variable called “player_speed”, and assign maybe 2 to it. Then replace the “jellyfish_speed” here with “player_speed”. Finally, after all the changes, do not forget to call “game_loop” to run the game. Ok, let’s test what we have so far.

* Test. Right, as soon as the program starts, our player moves right immediately, and when it hits the left edge …. ouch… we have a an error! What does it say? “name ‘random’ is not defined” and it points to this line here. Aha, sure, we copied the code from the last lesson, and it uses the “random” module. But what we forgot to do is to import the “random” module in our current file. So let’s do that! “import random”. And test it again. Wow, this time, once our player hits the left edge, it bounds back and continues to move in a different direction, just like the jellyfish. Nice!

* Ok, right now the player can only change its direction after hitting an edge. Next we are going to look at how we can change its direction at any time by pressing the arrow keys! To make that work, seems that we need to do some key binding again! Let’s first create a function call “bind_keys”, here we will bind the four arrow keys to change the player’s direction. Still remember how to bind a key to a function? Yes, we call the “onkey” method on the “window” variable. The first argument is the user-defined function and the second argument is the key. So what are the exact names of the four arrow keys that we can use for binding? Let’s open up the web page we saw in the last lesson, which contains a list of all the keys. Scroll all the way towards the bottom, and you will see these four keys: “Left”, “Up”, “Right” and “Down”. They are the names for the four arrow keys. Note that, unlike the “space” key we saw in the last lesson, these four names all start with a capital letter. This is important, because it won’t work if you use a lower case letter. Ok, let’s bind them one by one. 

* Let’s first bind the left arrow key. Create a function called “left” that will be run when the left arrow key is pressed. What should it do when it is run? Yes, we want to make the player face left. And how do we make a turtle sprite to face left? Well, way back in the Modern Art lesson, we have learnt about how direction works in Turtle. The left, up, right and down directions correspond to 180 degrees, 90 degrees, 0 degree and 270 degrees. You can make a turtle point to any direction including these four special ones. So to make the player face left, we just need to point it to 180 degree. And how can we make the player to point to 180 degrees? Yes, simple, just call the “setheading” method on the player and pass 180 as argument. That’s it, this is a the even handler function for the left arrow keys. Now, we have that, let’s pass it as the first argument to “onkey”. The second argument is the name of the left arrow key, which we already know is “Left”, so pass that in. That’s it, that’s how we bind a left arrow key to a function called “left”. Whenever the left arrow key is pressed, the function “move_left” is run. Finally, don’t forget to call “bind_keys” after setting up the window and the player. Let’s test to see if the binding works.

* Test. Ok, let’s press the left arrow key… and …. hmmm….nothing happens. Our player still moves to the right and never change its direction to face left. What is going on here? Can anyone spot any problem with our code? Aha, yes, excellent! We only bound the left arrow key, but we have not made the window listen for that key press event! How can we do that? Yes, we need to call the “listen” method after binding the left arrow key. Let’s add that! Ok, test it again! Now, as I press the left arrow key, the player immediately changes its direction and start moving to the left. Cool! The binding works! Nice! Ok, now let’s have a 5 min break and I want you to complete the bindings for the other three arrow keys. Make sure the player changes to the correct direction after each key press.

* Ok, time’s up, everybody got it done? Have you tested each binding? Are they all working? Nice! So let me just quickly finish mine and see if this looks the same as yours. So …. (TODO: just finish up the remaining three bindings). Ok, all done. Let’s test.

* Test. Yeah, works perfectly! Every time I press an arrow key, the player changes its direction accordingly! Now we have full control over where the player should go. This is super important if we want to avoid those dangerous virues.

* Ok, you have probably noticed the small delay between pressing an arrow key and the player changing direction. There is also a delay after the player hits an edge and before it is bounced back. We are not going to explain the reason now …. (TODO: should we mention this?) |
| Single enemy | * Ok, time to add some viruses to hunt down our player! Now I have to confess that for each virus, its behavior is exactly the same as the a jellyfish: it starts at a random position and points to a random direction, then moves around in the window, and whenever it hits one of the edges, it bounds back. Also, we have a sequence of costumes used to animate the virus. So since the code is 99% the same, I will once again open up the file from last lesson and copy the relevant bits over here.

* But first, let me define a new variable called “enemy” and assign it a new turtle object. Again, I could name this variable “virus” instead. But for the same reason I decide to call the cell “player” and not “cell”, I would name it “enemy” and not “virus”. Then let’s copy the “setup_jellyfish” function from last lesson and paste it after “setup_player”. Of course, we need to change the function name to “setup_enemy”. Ok, then let’s check carefully what else we need to change here. The first obvious thing is to replace all variable “jellyfish” with the new “enemy” variable. Next, there are two variables “num_of_jellyfish_costumes” and “jellyfish_costumes”, one for the number of costumes and one to store the file paths to all costume images. Here we need “num_of_enemy_costumes” and “enemy_costumes”. They do not exist yet, so let’s define both first. If you open this lesson’s folder, you would again see a folder called “Resources”. Open that up, and you would see a subfolder called “Enemy”. Inside, we have 31 images used for the enemy’s costumes. So we should assign number 31 to variable “num_of_enemy_costumes”. Next, “enemy_costumes” is just an empty list to start with. Right, back to “setup_enemy”, we can now replace the variable, so change “num_of_jellyfish_costumes” to “num_of_enemy_costumes” and change “jellyfish_costumes” to “enemy_costumes”. Ok, what else do you think need to be changed? Yes, the file path. Ok, for the path in the “for” loop, we just need to change from “Jellyfish” to “Enemy”, and same for the path passed to the “shape” method. Cool, I think this is all the changes we need to make for this function! And finally, do not forget to call “setup_enemy” after setting up the player. Let’s test this.

* Test. Ok, the game starts we see a virus showing up in the window. And if we run it a couple of times, you would notice that the enemy appears in different location each time. Cool.

* Right, since we have now added all the alien’s costumes it’s time to animate it. Again, we are going to use the event based-approach as we did for the jellyfish. So once again, let’s copy function “switch_jellyfish_costume” and paste it after “setup_enemy” here. Ok, time for some more changes! First, let’s change the function name to “switch_enemy_costume”. Once you do that, make sure to also change the first argument to “ontimer” as well. Because this is just calling this same function again in 100 milliseconds. Next, just look for any thing that contains the word “jellyfish” and those shoud be changed. First, “numer_of_jellyfish_costumes” needs to be changed to “num_of_enemy_costumes”. Then, “jellyfish” needs to be changed to “enemy”. And finally, “jellyfish_costumes” needs to be change to “enemy_costumes”. Ok, now very important, here we have a global statement for variable “i”, this is used to index the costume list. But do we have that global variable “i” in our code? Not yet, right? So let’s define one in the global scope and assign an initial value 0 to it. Finally, let call “switch_enenmy_costume” before the game loop. Let’ stest this!

* Test. Ok, the enemy becomes alive! It’s moving it’s body and legs, ready for attack! Cool!

* Next, we want it to actually start moving and bouncing around in the window. So the only different between a player and an enemy when it comes to moving is that the player can be controlled with arrow keys to change direction whereas the enemy just moves on its own. This means, the enemy’s code for movement should be the same as that of the player’s. The only difference is just that we don’t need to bind any keys for the enemy. So let’s copy the “move_player” function and paste it underneath. Then change the function name to “move_enemy”. Inside the function, replace all “player” variables with the “enemy” variable. Also, moving speed should be “enemy_speed” instead. But we haven’t had that variable yet, so let’s create one. Since the player speed is 2, we make the enemy a bit slower by assigning 1 to “enemy_speed”. Then let’s change “player_speed” to “enemy_speed” in the “move_player” function. Of course, just like we call “move_player” in the game loop to move the player, we also need to call “move_enemy” to move the enemy. Let’s test it again!

* Test. Ok, now the enemy actually starts to move! When it hits an edge, it bounces back. It just wondering around like this forever! But there seems to be a small problem here: I’m not sure about your computer, but on mine, the game seems to become less responsive now. The movement of the player and the enemy are not as smooth, and when I press an arrow key, both the player and the enemy seem to pause for bit before moving again. It does not seem to be a huge problem, the game is still playable, just a bit annoying. I want to point it out here, because as we will see later on, this small annoyance will quickly become a big problem.  |
| More enemies | * OK, as we have seen at the beginning of this lesson, the game starts with three enemies, and as the user plays, there will be more and more of them. Currently, we only have one enemy stored in variable “enemy”. This is clearly not going to be enough. So what do you think we should have instead? Yes, we need a list to store all enemies in the game. With that, as new enemies show up, we just need to add them to the list. 

* OK, let’s first create a new list variable called “enemies” and then initialize it to an empty list. Before the game starts, we are going to add three enemies to the list. Since all enemies are not stored in this list, we no longer need the “enemy” variable, so we can just delete this line. Of course, the code is broken now, because the “setup_enemy” function needs to access this “enemy” variable to set things up. But we will fix that very shortly.

* Currently, the “setup_enemy” function only sets up one enemy, we are going to change it so that it sets up multiple enemies instead. Because of this, we first rename it to “setup_enemies” since it is setting up more then one enemy now. We need to change it in both the function call and the function definition. Now, inside this function, we still need to add all the costumes, so nothing needs to be changed here. But the rest of the code only sets up one enemy at moment, we now want it to do the setup mutiple times, one for each enemy. So what can we do? Yes, we need a loop, or more specifically, a “for” loop. So “for”, and we don’t need the loop variable in this case, so it’s just “_”, then “in” and “range(3)” because we want to create three enemies to start with. Now, inside the loop, what do need to do first? Yes, we need to create a enemy. Remember, we have deleted the global “enemy” variable, so there is not enemy now. We need to create them one by one. So in the loop, define a local variable “enemy”, create a turtle object by calling the “Turtle” method and assign it to “enemy”. So we are going to create a different enemy each loop iteration. Now, once we have an enemy, what should we do next? Yes, we should setup it up properly. Do we have the code to setup an enemy? Sure we do! It’s all the rest of the code in this function. So, giving it a costume, calling penup, position it to a random position etc etc. Everything is already here. All we need to do is just indent all the them so that they are moved in side the “for” loop. There you go, we create a new enemy and set it up in each loop iteration. Last but not least, we need to add this new enemy to the “enemies” list at the end of each iteration by calling the “append” function on “enemies”. Cool, so after calling “setup_enemies”, we should have three new enemies in the list, each at a different random location and facing a different random direction. Let’s test the code!

* Test. Oh no, we have an error! Let’s see that it says. Ok, it’s complaining about this line in function “switch_enemy_costume” and says “name ‘enemy’ is not defined”. Aha, yes, because we have deleted the global “enemy” variable, so of course it cannot be found. So this function is switch the costume of our only enemy previously. But now, we have more than one enemy and all of them need to have their costume switched. What should we do here then? Yes, we just need to call “shape” for each of the enemy and give it a new costume. Simple as that. Since all the enemies are now inside the “enemies” list, we just need to go through the list, get each enemy and call “shape” on it to switch its costume. Simple as that! How do we go through a list? Yes, we use the “for” loop again. So “for”, this time, we do need the loop variable, it’s going to be each of the enemy in the list, so let’s name it “enemy”, then “in” and finally the list “enemies”. Next, just move this “shape” call inside the “for” loop. So we are getting each enemy from the list and calling “shape” on it to switch its costume to the next one. Nice! Let’s test this again!

* Test. Oh no, we still have some error. Let’s see what it’s complaining about this time. Aha, yes, we are still using the global “enemy” variable that’s been deleted in function “move_enemy”. And we call this function in the game loop. But before we address this problem, I really want to check if our changes for the animation work or not. SO let’s just briefly comment out the “move_enemy” function call in the game loop so that it won’t be run. Now, let’s start the game again. Ok, now there is no error and we can see that the animation works for all three enemies! Pretty nice! Of course, none of them are moving now because we have just commented our the call to “move_enemy”. Let’s fix that next!

* First, let’s uncomment the “move_enemy” function call. Currently, this function only moves and bounces one enemy. But since we have three enemies now, we need to move all of them. Just like how we switch costumes for all three enemies, we can go through the enemy list and move them one by one. So let’s add another “for” loop, again the loop variable is going to be “enemy”, then “in” and finally the list “enemies”. Then we just need to move both the “forward” method call and the bounce code inside this for loop. So for each loop iteration, we get an enemy, move it forward, check if it collides with an edge, and if so, bounce it back. Now, since we are move multiple enemies, we want to rename this function to “move_enemies”. And also change the function call to “move_enemies”. Ok, let’s test this!

* Test. Right, we have all three enemies moving now! That’s nice! But there is something not so nice going on here. Last time when we had only a single enemy, I pointed out that the game becomes less responsive. It wasn’t too bad back then, and the game can still be played. But watch what happen now, everything, the player, the enemies are moving so slowly. Even worse, the delay between pressing an arrow key and the player changing direction is becoming even greater. That small annoyance has finally turned into a big problem! We can no longer ignore it, this has to be dealt with!  |
| Solving unresponsiveness | * Right, to solve this problem we have to first understand what causes it. And to understand what causes it, we need to talk about how turtle creates the impression that something is moving on the stage. 

* Do you still remember the flipbook I have shown you earlier? Right, imagine drawing a small car. On the first piece of paper, draw it on the left side. Then in the next piece of paper, still draw it on the left side, but move it slightly to the right. So it’s still the same car, but this time it moves to the right a tiny bit. Then on the third piece of paper, draw the car again, but this time it moves to the right a tiny bit once again. Now, this just continues, drawing the car slightly more to the right on each piece of paper, and eventually on the last piece of paper, draw the car on the right side. At this point, you might have tens of even hundreds of pieces of paper, depending on how much you move the car each time. Now, imagine flipping through all pieces of paper from the beginning to the end, what are you gonna see? Yes, you are gonna see a small car driving from the left to the right, it is moving! So this is how animation are created, doesn’t matter whether its a simple flipping book like this one, or a large movie or a 3A game, the basic principle is the always the same.

* Ok, the way animation works in Python turtle also follows this same basic principle. Think of it as a drawing machine, it can draw anything you place in the window, background images, shapes, turtle sprites, anything. It draws them in the window for you to see. But so far, everything is static, meaning they are moving? So how does turtle create all the animation we have seen? Well, turtle does not just draw the window for once and be done with it. In fact, it can draw the window multiple times as the program runs. So when does it decide to redraw the window? Well, there are a number of reasons. 

* Let’s look at the two animations we have seen. One comes from sprite changing costumes and one comes from sprite moving to different positions. In the first case, how did we make the sprite to change costumes? Yes, we use “event-based” programming with the “ontimer” function. And each time the timer expires, we change the costume to a new one. Now, because something new usually happens when a timer expires, turtle decides it’s probably a good time to redraw the window to show whatever that is new out there. In this case, it’s the new costume. So each time a sprite switches to a new costume, the window is redrawn. This is just like drawing the costume on a new piece of paper. And if you show the paper piece after piece, each with a different costume, you get an animation.

* In the second case, we move the sprite by calling certain turtle functions, such as “forward”. Now, when you call such functions, it’s most likely that a sprite is going to end up in a different position. Therefore, turtle decides it’s another a good time to redraw the window to show user where the sprite currently is. And it does so each time a sprite moves, just like when our car moves to the right a bit more, we draw it on a new piece of paper. And if you show the paper piece after piece, each with the sprite in a different position, then it appears as if the sprite starts to move, just like the car. Here, we only mention the “forward” function, but in fact, there are a lot more functions that can move a turtle sprite, and all of them will cause the window to be redrawn.

* So in summary, python turtle will redraws everything in a window every time a timer expires with “ontimer” function or every time a turtle sprite changes its position. Of course, there are more cases that can cause a redraw, but knowing these two are enough for now. 

* Ok, drawing the window is a very important task of the turtle module, that’s why we can not only see what’s out there in the window but also all the animations and movements. Super important. But there is a downside, drawing a window is time consuming. Just think about how long it would take you to draw just that simple car on a piece of paper, it takes time, right? Of course, a computer can still draw things much faster than a human, but this is still significantly slower than doing things like adding two numbers. And in an animation or a game, whenever a timer expires or whenever a sprite moves, the entire window needs to be redrawn. This can make things terribly slow if you have many moving sprites.

* Let’s take a look at our code. How many sprites do we have in total? Yes, we have four, one player and three enemies. And what kind of animations do they have? Yes, the player and enemies move around in the window and each enemy also changes its costumes continuously. This means, each time the player moves by calling “forward”, the window is redrawn; each time an enemy moves by calling “forward”, the window is redrawn; each time an enemy switches to the next costume when the timer expires, the window is redrawn. And remember, we have three enemies, so that is a lot of window redraws. And this just gets worse once we have more enemies. For example, let’s go to function “setup_enemies”, and change the number of enemies from 3 to 10. Now run the game.

* Test. Oh my god, look at that, the whole game just grinds to a halt, looks like everything was in slow motion! This is because the more enemies you have, the more often turtle needs to redraw the entire window! And as we all know by now, drawing a window is very slow!

* So is there a way to make the game smoother? Well, if the reason for the game to be slow is because we are drawing the entire window too many times, then the obvious solution is just to redraw the window less often. As we have discussed earlier, turtle redraws the window every time the timer for switching costumes expires or every time a sprite moves forward. So if we can reduce the number of redraws, then we should be able to make the game runs faster and smoother. But how?

* Let’s consider our one player and three enemies. And assuming each one is about to move a number of steps. Let’s do this very very slowly. Say the player moves first. After that, turtle redraws the window, so we can now see it in its new position along with the other three enemies. Then, one of the enemies moves next. After that turtle redraws the window again. We can now see the player and this enemy in their new position. Right, this continues on. The second enemy then moves. After that, turtle once again redraws the window. Now, we see the player and the two enemies in their new position. Finally, the last enemy moves. Turtle redraws the window one last time and we now see all sprites in their new positions. So how many times does turtles draws the window? Four, right? So how can we cut the number down? Now, here, we are arriving at the final window, where all sprites have moved to new position, incrementally, meaning we are moving one sprite each time and redraws the window as we move each sprite. Now, what if we can move each sprite, but do not redraw the window as we move them, and only draws the finally window where all sprites have moved to their new positions? Is that gonna make any difference to what we finally see at the end? No, right? The final window, will always be the same in both approaches, regardless of whether you draw all the previous intermediate ones or not, right? If they are the same, then why draw all the other windows? We can just wait until all sprites have finished moving, then draw only once at the end, right? So we reduce the number of redraws from four to one! And the amazing thing about this is, doesn’t matter how may enemies you have, you always just draw the window once at the end when everyone has fishing moving. If you use the old approach, then you are redrawing 11 times with 10 enemies, once for the player. And redrawing 101 times if there are 100 enemies. In that case, you cut the number of redraws from 101 to 1, that is just nuts!

* OK, so we now know how to speed up the game by reducing the number of redraws. But there is problem: turtle is pretty stubborn and it always redraws the window when a timer expires or when any sprite moves. Is there a way to tell turtle: hey, please don’t redraw the window unless I tell you so! Fortunately, there is such a way! Let’s see how it work! There are two parts of this solution: first is to ask turtle not to redraw the window at any time; second is to tell turtle when to redraw the window whenever we need it to.

* First, to stop turtle from automatically redrawing the window, we need to call a special function named “tracer” on the “window” variable. Let’s do that in function “setup_window”. Now this function like a switch that can turn redraw on or off. By default, redraw is on, meaning if you don’t call it, turtle will redraw the window when timer is expired or when a turtle sprite moves. However, you could turn it off by passing 0 as the argument. Once it is off, turtle will never redraw the window unless you ask it to. So the next question is when and how do we ask the turtle to redraw the window? Well, as we have discussed earlier, we want all sprites to finish moving before we redraw the window, right? So where do all the sprite finish moving? Yes, it’s inside the game loop, after calling “move_player” and “move_enemies”. After these two functions, all sprites have finished moving and it’s time to redraw the window to show their new positions. Then the next question is, how do we ask turtle to redraw the window? So there is another function named “update” that you can called on a window, this is like telling the window “hey you, I want you to redraw yourself now!”. So, let’s call that in the game loop. So, after moving all sprites, we finally want to redraw the window. Let’s test what we have now!

* Test. Wowowowowo, what is going on! The sprites are going like crazy! We go from super slow motion to crazy fast motion. Ouch! This is working too good! We need to slow things down! Right, things are so fast because the game loop is now running too quickly, because we reduced the number of redraws from four to one during each iteration. What can we do to slow it down? Still remember how we made the ghost animation slower? Yes, we used the “sleep” method to add some delay between switching face costumes. So here, we can also use “sleep” to add some delay between each move of the sprites. To use this function, we first need to import the “time” module. Let’s do that at the beginning of the file. Then, inside the game loop, after redrawing the window, we call “sleep”. Now the argument to sleep is the number of seconds you want the program to sleep for. Let’s first try 1 second. Ah, I think we slept for too long, the game is back to slow motion again! Let’s try 0.1 seconds. Ok, better, but still too slow. Try again, this time 0.01 seconds. Aha, yes, I think this is the right speed, not too slow and not too fast. 

* As you can see, once you take control of when the window is redrawn, you can easily make the game run faster or slower, simply by changing how long to sleep for during each iteration of the game loop. If you sleep for longer, the game runs slower, if you sleep for shorter, the game runs faster. And when it comes to games other than those super simple ones, you almost always want to take the privilege of redrawing window from the hands of turtle, and take full control yourself by calling the “tracer” and “update” functions. You get to decide where and when to redraw the window. This is usually done in the game loop, when all the actions of one iteration, such as moving all sprite, have finished and it’s time to show the results in the window. This is a very important technique for writing games and you should make sure you are familiar with this kind of pattern. |
| Collision detection | * Ok, so both the player and enemies can move and bounce in the window, we can also use the arrow keys to control where the player goes. All good so far. But right now, it’s not much of a game. For something to be a game, there needs to be at least two basic things: goal and end condition. Goal means what you want the player to achieve, do you want it to kill a monster, to score the highest point or something else. There needs to be a reason why anyone would want to play the game. In this case, as I have shown you at the beginning, the goal is to stay alive for as long as possible. The longer you keep the player in the game, the higher your score is. Ok, that’s the goal. What about end condition? This means how should the game end? For some games, this could be very clear: it ends when you kill the monster or find the hidden treasure. For our game, it ends when the player is caught by the any one of the enemies. Simple as that. So, knowing both what the goal and the end condition are, we can finally start to turn this animation into an actual game. We will first look at the end condition and then work on the goal afterwards.

* Ok, what does it mean for our player to be caught by an enemy? Yes, it simply means our player has collided with one of the enemies. So the end condition becomes checking if a collision happens between the player and one of the enemies. Next question, where should we check if a collision happens? Now, if neither the player nor the enemies move, then there can be no collision at all, right? How can two non-moving things collide with each other, not possible right? So they only collide once they start to move. Where do we move the player and the enemies? Yes, inside the game loop. So player moves a bit, then all the enemies move a bit. Now, after everybody has moved to its new position, there may potentially be a collision now, right? OK, looks like we need to check for a collision right here, after all sprites have been moved.

* Ok, next, how do we decide if two sprites collide with each other? We have done some collision check before, right? Yes, when we bounce the sprites from the edges, we first check if they hit the edges or not, right? This is a kind of collision check. For two sprites, what should we check to decide whether they collide or not? Yes, we can check their distance! If the two sprites are close enough, or in other words, their distance is smaller than some threshold, then we can say they collide. The next question then becomes how do we get the distance between two sprites in the window? It’s time to take Scratch out again. In Scratch, if you want to know the distance between two sprites, what can you do? Yes, you can use a “distance to” block in the sensing block. So here I have two sprites, a player and an enemy. In the player, if I drag out a “distance to” block, I can then select the enemy sprite from its drop down list. And gives you the distance between the player and the enemy. If I click this block, it says the current distance is 25. Now if I move the enemy closer, and click the block again, it says 13 this time (TODO: prepare a scratch file with a player and an enemy for this demonstration). So it always gives you the current distance between any two sprites on the stage. 

* Ok, back to Python, as it turns out, a turtle object also has a method called “distance” that you can call to find out the distance between any two turtles in the window. So since I want to check if any enemy collides with our player, I’m gonna call the “distance” method on the player. Now just as you select another sprite from the “distance to” block’s dropdown list in Scratch, you need to pass another sprite to the “distance” method to get the distance between player and that sprite. Here, we need the distance between the player and the enemy. But which enemy? Well, any enemy, in fact, as long as one enemy collides with the player, the game ends. So we should check the distance between the player and all three enemies and see if it collides with at least one of them. This sounds like we need we need to go through each enemy in the list and check if its distance is smaller than some threshold. Sounds like anorther “for” loop. So “for”, the loop variable is “enemy”, then “in” and finally the list “enemies”. Inside the loop, we need to check if the distance between “player” and the current enemy is less than some threshold, so let’s add an “if” statement first. For the threshold, you probably need to play with different numbers, it depends on the shape and sizes of your sprites. Here, I found that 20 works fine. So if the distance between the player and the current enemy is less then 20, they are considered colliding with each other. For the if condition, we already know how to get the distance, we call the “distance” method on the “player” and pass loop variable “enemy” to it, then if this distance is less than 20, they collide. Next, what should we do if they collide? Well, if this happens, we want to end the game. But how? In the last lesson, how did we stop the animation when user presses the space key? Yes, we use a “stopped” variable and set it to True in the space key event handler. Then in the game loop, we simply check if “stopped” is True and if so, break out of the loop. Do you think we can use the same trick here? Of course, and in fact, using a “stopped” variable is one most common way to decide whether a game should end or not. So let’s first define a new variable called “stopped” and assign False to it. Then back to the game loop, if a collision happens, we set stopped to True. Of course, this is not enough, we also need to check if “stopped” is True at the beginning of each loop iteration, if so, we break out of the game loop. Finally and very important, since we are changing the value of the global variable “stopped” in “game_loop” function, what else should we do? Yes, we should declare it as global in at the beginning of the function. Right, that’s quite of a lot of code. Let’s test it and see if the game ends when our player touches any enemy.

* Test. Now, let’s move the player towards an enemy and boom, they collide, and the game ends! Nobody moves any more! (TODO: ok here is something that is different comparing to the last lesson, then the game stops, the enemies also stops their animation. In the last lesson, this is not the case, and I have asked the students to explicitly make sure the jellyfish animation also stopped by using the “stopped” variable. The difference comes from the fact that we disable auto redrawing here and so even though the switch costume function still runs, but it is not triggering a redraw so we do not see the costume changing. Should I point this out in the lesson?) That’s very cool, our collision detection works! 

* Ok, the code works and that’s good. But let’s take another loop at this “for” loop, say we have 100 enemies in the “enemies” list, and we go through each enemy one by one to check for collision, right? Now, assume that we get “lucky”, the player collides with the very first enemy in the list. So the condition becomes True and we set “stopped” to Ture, right? Meaning a collision happened and the game should end. So far so good? Now, what is our code going to do next? Well, it is just going to continue with loop, check for the next enemy, and then the third enemy and so on and so forth, all the way until the 100th enemy. You would probably jump out of your seat and say: “this is silly, we already know the player collide with the first enemy, why bother check the remaining 99!” Yes, you are absolutely right, it’s silly to continue checking the other 99. Because colliding it doesn’t matter whether the player collides with one enemy or more, as long as it collides with one, the game ends. This means, as soon as we find a collision, we can stop the “for” loop and jump out of it, so that we do not waste time checking for the remaining enemies. How do we stop and jump out of a loop? Yes, we use the “break” statement. So let’s add one after setting “stopped” to True. Let’s test the code again.

* Test. Ok, the game still ends when we collide with an enemy. There may not seem to be any difference on the surface, but when there are a lot of enemies and as long as the one we collide with is not the last one in the list, we saves quite some time checking for collision! 

* Ok, before I move on to a different topic, I would like organize the code a bit better. Here, we have a “for” loop in the middle of the game loop. Because it does something very specific, that is to check for collision, I want to place it into a separate function. So let’s define a new function called “check_collision” with no parameter, then just move this entire “for” loop over here. One small change I want to make after moving the code is that, I want to change the “break” statement to just a “return” statement. So what is the difference here? Well, the “break” simply ends the “for” loop and continues with whatever code that is after the loop. Since there is no code after the loop in this function, the function ends. Now, what about the “return” statement. This is the first time we see a “return” statement without any value to return. This is not wrong, and actually, whenever you see a “return” in a function, it means stop this function immediately and return to the place where this function was called. So whenever we find an enemy that collides with the player, we end the function right away. The reason I use it here is because, since there is no code after the loop in this function, there is no need to end the loop first, check that there is nothing to run after the loop and then end the function. By using the “return” statement right away, we saves some extra work. Ok, once the “check_collision” function is done, we just call “check_collision” in the game loop instead. Finally, since the global “stopped” variable is not being changed in the new function, we need to move the global declaration to that function as well. Let’s test the code again.

* Test. OK, everything still works! Nice! Now take a look at the game loop, it’s short, simple and clear. For each iteration, we move the player, move all the enemies, check if the player collides with any enemy, then finally redraw the window to show what everything looks like now. Cool! |
| Adding score | * Ok, right now, we can control the player to dodge the enemies. And the goal of the game to dodge for as long as possible without being caught. Now imagine taking this game to your friend have a competition, can you tell who is better? No, because the game does not give you any indication of how well you’ve done. Of course, you can get a clock and time each one of you to see who stays alive for the longest, but let’s be honest, shouldn’t that be the job of the game? This leads to another very important part of any game design, there needs to be a scoring system. This gives the player feedback on how well he/she has done and allows people to compete with each other. Ok, our game is no exception and we need to introduce scores as well.

* If you still remember the final game I showed you at the beginning, there is some text at the upper left corner of the window that shows the player’s current score. And it keep increasing as time goes by, as long as the game is on. So the longer the player can stay alive, the higher the score. There are two problems to solve here: first we need to add text for the score, and second, we need to update the score as time goes by. Let’s look at them one by one. 

* So far in our Python turtle journey, we have seen that a turtle can be used as a pen to draw shapes, we have also seen that a turtle can be a sprite of a game. Here we are going to see the third used of a turtle: text. You can use it to display any text you want. Quite a surprise hug? Let’s see how this is done. So first, we need anther turtle for the score text. Let’s create one after the “enemies” list. I’m just gonna call it “score”. Then let’s define a new function called “setup_score” to, well, setup the “score” turtle. So since we want the score to be somewhere in the upper left corner of the window, let’s first move it there. So call the “goto” method on the “score” variable. Now, what should the x and y coordinates be? We know that the coordinates of this upper left point is -300 and 300, right? So let’s use those. Of course, we are not going to use the numbers direction, the x coordinate -300 is just -window_width/2 and the y coordinate is just window_height/2. Ok, let’s call this function after setting enemies and see what it looks like. 

* Test. Ok, let’s take a look at the upper left corner, do you see anything, hmmm… not really? I think it’s probably because the score turtle’s default color is black and we have a very dark background, so it is not too obvious. Let’s change its color to something lighter. Before calling “goto”, let’s call “color” and pass “gray80”, which is a light grey color. Try again. Aha, we still don’t quite see the turtle itself, but we know it’s there, why? Yes, because we see its trace from the center of the stage to the upper left point. I think it has moved to the right place. But of course, we don’t need this line here, and the reason we have it is because….? Yes, we have not put the pen up before it moves. So let’s do that, call “penup” before “goto”. OK, try again, yeah, the line is gone! Cool! 

* Now, the turtle is in place, how can we create the text? Well, when we learnt about file handling in the first part of the course, do you still remember how we write to a file? Yes, we have a file object and then we call the “write” method on that object to write to the file. And it turns out that a turtle object also has a “write” method. But instead of writing to a file, it writes text at the current turtle position. Let’s try that. After moving the turtle, let’s call “write” on the score sprite. One of the most important arguments for this method is the text to write. Since this is going to display the player’s current score, we pass string “Score: ” for the time being. Ok, let’s run this.

* Test. Right, if we take a look at the upper left corner, there is still nothing. Ok, let explain why. When turtle write out some text, the text is always going to be to the right and above the turtle’s current position. So if the turtle is at the upper left point, then the text it writes is going to be somewhere here. But this is completely outside of our window right? That’s why we don’t see it! So what can we do? Well, easy, we just need to make the start position of the score turtle a little bit lower and a little bit to the right. If it is here, then the text it writes is going to be somewhere here, then it is still inside the window. OK, to move the turtle right we just need to add some number to its x coordinate, let’s add 10 to “-window_width/2”; to move it down, we subtract  some number from its y coordinate, let’s subtract 30 from “window_height/2”. So the score turtle now starts at x -290 and y 270, somewhere here. Let’s run this again. Aha, we can now see the text “Score:” at the upper left corner cool! But there is a small issue, we still see the turtle next to the text, we should hide it. How do we hide a turtle? If you have completed the exercise for last lesson, you should know that there is a method called “hideturtle” that we can call on a turtle object to hide it. So, let’s hide it from at the beginning of the function. Try again, and yes, the turtle is gone, we are only left with the text. Looks nice!

* OK, the text is there, but right now, I think it looks a bit too small and I don’t quite like the font. I want to change those. And the way to do that is pretty simple, you just pass another argument to the “write” method. This parameter is called “font”. Now, to pass that argument, we can’t just add a comma and type in its value after the text. This is because, there are actually two more parameters between the first text parameter and this font parameter. These two are no important for us here, and that’s why the reason I don’t mention them. But if you just pass the font like this, then it will be treated as the second parameter of the function. And if you take a look at this [page](https://www.geeksforgeeks.org/turtle-write-function-in-python/) for the “write” method, you can see that the second parameter is something called “move”, this clearly has nothing to do with font. So you would get an error. Right, then what is best way to pass the font argument then? Well you might say, let’s just pass the second and third arguments, and then we can pass the font as the fourth one. Ok, that’s one way of doing it. But there is a better one and we have learnt about it in the first part of the course. Can anyone still recall what that is? Yes, excellent, it’s called a named argument! The way you pass a named argument is a bit like defining a variable, you first type in the name of the parameter, followed by an equal sign, and finally the value you want to pass. If you do that, than it does not matter where that argument is passed, it could be at the second position, or the third position, and the function knows you are passing the argument for the “font” parameter. Cool. So what value should we use for the “font” parameter? Now the page says it’s a tuple that has three items, “font name”, “font size” and “font style”. Ok, we have not learnt about what a tuple is before. But we have learnt something similar, a list. Yes, a tuple is very similar to a list, it is just a collection of items, and you can index it to get individual items. On difference is that, instead of using square brackets to enclose all the items, you use use parentheses for tuples. Of course, there are some major differences, but I will not going to those here. Ok, so the value for “font” parameter is a tuple, so we type in a pair of parentheses first. Then let’s take a look at each of its items. The first one is “font name”. There are a lot of different fonts out there. But the exact fonts you can use depends what fonts you have installed on your computer. Here, I will not go into the details, I will just pick a font called “Courier” which I think looks good for the score. Next, its the “font size”. This is a number, the bigger it is, the larger the text size. Again, you can try different numbers, and I find 14 works well here. Finally, it’s the “font style”. If you want to make the text bold or italic, you can do that with this parameter. But I just want some normal text. So I will pass string “normal”. That’s it, that’s how you specify the font for your text. Let’s run the code again and see what the text looks like now.

* Test. Aha, cool, I think the font and size looks perfect now! Of course, if you don’t like it, you can always customize the way you like.

* Right, the score text is ready now. But it is not displaying any actual score yet. Let’s address that next. First we need a variable to keep track of the player’s score, right? So let’s define a global variable call “points” to store the points a player has scored. Initially, the player has no points, so we assign 0 to it. Now, once we have the score, we need to display it as part of the our score text. So go back to the “setup_score” function, we change the first parameter of the “write” method to an f-string, and add the “points” variable as part of the text. Let’s run the code again.

* Test. Aha, this time, we see “Score: 0”. That’s the initial score our player starts with. Pretty cool!

* But obviously, the score stays at 0 and never changes at the moment. However, in the final game, the score should keep increasing as long as the player is still alive. The longer it can stay in the game, the more points it can score. So we need to be able to change the score! Now, in some games, you score points by collecting thing or killing enemies, here, it’s a bit different, you don’t actively score point, but instead, you just try to stay alive for as long as possible to score points. In other words, the score just increases as time goes by. So it starts at 0, then may be one second later it becomes 1, then another second later it becomes 2, and so on and so forth. Of course, I’m using one second interval here as example, you can choose any time duration. Ok, if something happens again and again at regular interval, what do you think is the best way to code this? Yes, event based programming with the “ontimer” function. So we setup a timer that goes off every one second, and whenever it goes off, we increase the score, simple as that!  

* Ok, first, we need to create a new function that is going to handle the event when the timer goes. Because this function is going to update the score, let’s just call it “update_score”. Now, what do we want to do here? Yes, first obvious thing is the increase the points. Now, how much to increase the points is totally up to you. You can increase it by one each time, or two, or whatever. I’m just gonna increase it by one. So add one to the global variable “points”. Now, we are changing a global variable’s value, what is missing? Yes, the global variable declaration. So let’s do “global points”. Do not forget this, otherwise, you are gonna get some error. Ok, we want this event handler to be run again and again every one second, so what should we do at the end? Yes, we should schedule its next run. How can we do it? Yes, we call the “ontimer” function on the window, the function to run next is just this “update_score” function, and we want the delay to be one second, and remember, “ontimer” uses milliseconds, and 1000 milliseconds is one second, so let’s pass 1000 as the second argument. Right, we have the event handler done, of course, do not forget to call it just before the game loop starts. So let’s call “update_score” before calling “game_loop”. Right, let’s test this!

* Test. Ok, the game starts, but we don’t see the score being changed at all! It is still just 0 always. What went wrong? Is is because our “update_score” function not working properly? Let’s prove it. Let’s print the value of “points” in the function just to show that it is indeed increasing. Let’s test again. Now, take a look at the console, see, points is increased by one each second, looks like the function works fine. But why are we not seeing the change here in the window? Well, do you still remember how we made the score text show up at the beginning. Yes, we call the “write” method on the score turtle to write it out! But when we did that, the score was 0. Now the score is changing, but did we write it out again? No! Well, if it changed and we did not write it out again, then how can we see the change, right? So what we need to do is that, whenever the score changes, we need to call the “write” method on the score turtle to write out the new points. Let’s try that. So after adding one to “points”, call “write” on the “score” variable, now the first argument we want to pass is the score text. So it’s an f-string “Score: ” and we pass variable “points”. The next argument is the font, again, we used name argument, so “font”, and the value is a tuple, a tuple is enclose in a pair of parentheses. The first item of the tuple is the font name “Courier”, the second item is its size 14, and the last item is its style “normal”. So if you compare this with the “write” method call in “setup_score”, you can see that they are exactly the same. The only difference is that we are calling “write” once every second here with a new point value. Ok, we don’t need this print anymore, let’s delete it. Right, time to test the code again!

* Test. Ok, now we can see some changes to the score text, looks like it been updated every second. But here is a problem, it seems that all the different values for points are laying on top of each other. Very quickly, we can’t even tell what number it is. Hmmmm…seems that we need to clear the score text before we write a new one. This is simple, a turtle object has a method called “clear” just for that. Let’s call it just before we write a new score text. Now, let’s run the code again.

* Test. Ya!!! It’s works, the score changes by one every second! Now we have a way to show how well a player has done. The longer it can stays alive, the higher its score! But there is a tiny problem. When you start the game, do you notice that the score seems to start from one instead of zero. Did see it? Let’s me run again, see, as soon as the window opens up, the score is already one. OK, this is not a huge problem, but it does not make too much sense. When the game just started, the player has not played for even one second, then how can he score any points, right? Let’s first try to understand why this happened. We call “update_score” right before the game loop, right? And as soon as you call it, it’s going to increase points by one. Since points starts from 0, it becomes one and this get write out. And all these happens before the game loop even starts! So how can we fix it? Well, the solution is just to NOT start it right away, instead, we wait for one second before calling “update_score”. How can we wait for one second? Yes, again, use the “ontimer” function. So, before the game loop, let’s call “ontimer” on the window, pass the “update_score” function and 1000 milliseconds. So this will only start to update the score after one second. Let’s try that!

* Test. Right, see? Now the score starts from 0 again. And only after about one second, it changes to 1. Nice! It’s a small problem, but it feels good to get it right! |
| Adding more enemies | * Ok, our game is pretty complete by now, we have a player to control, we have some enemies to dodge, we have a scoring system to show how well the player has done, and we are able to end the game when the player is caught. All seems working perfectly! But there is a problem: it is just too easy now. With the three enemies, I can keep my player alive for a whole day! If your game is too easy and its difficulty level does not increase, the player can very quickly get bored and throw your game into the trash can! So we need to spice things up a little bit!

* Now, there are a number of different ways to make the game harder and harder. For example, you can make the enemies move faster, or you can make them chase the player instead of just moving aimlessly. In fact, I will make that an after-class exercise for you. But here, I will just increase the difficulty level by adding more and more enemies as time goes by. So we start with three, then maybe 3 seconds later, we add one more, and another 3 seconds later, we add one more. This continues on and there will be more and more enemies for the player to dodge. And surely, this is going to make the game harder and harder, and eventually at some point, there are just going to be so many enemies that it is impossible to dodge and the game ends. Sounds like a cool thing to do! 

* OK, adding one enemy every 3 seconds and doing this again and again. Does this sound familiar? Yes, we have just done something similar to increase the score every one second. Here, instead of increasing a score, we increase the number of enemies, and instead of waiting for one second, we wait for 3 seconds. But the rest are pretty much the same! Sounds like another case for some event based programming! Cool. Let’s create a new function as the event handler, since we are going to add new enemy, I’m just gonna name it “increase_enemy”. OK, what should we do inside this function? Yes, two things, create one enemy, and add it to our enemies list, right? But we have done this before, right? Yes, we did that in the “setup_enemies” function. Take a look at this “for” loop, what did we do there? We create an enemy and we add it to the enemies list. Exactly the two things we want to do here! Now, we can copy all these code here and paste it inside the “increase_enemy” function. But do you think this is a good idea? No, right? As I keep saying, do not duplicate your code. Then what should we do? Yes, we can create a function for the two steps and then call it from both “setup_enemies” and “increase_enemy”. So let’s define a new function called “create_enemy”, and let’s move all the code here to this new function. Then what should we do in the “for” loop? Yes, we just need to call “create_enemy”. 

* Now, what is the benefit of creating this new “create_enemy” function? Well, remember, we were working on the “increase_enemy” function to add more enemies to the game, right? Now, back to that function, all we need to do now is just call “create_enemy” function. That’s it, that’s how we create a new enemy and add it to the game. Of course, do not forget to call “ontimer” at the end so that we can add a new enemy every 3 seconds. We pass ”increase_enemy” function as the first argument and 3000 milliseconds as the second argument. Of course, just like the “update_score” funciton, we need to call “increase_enemy” before the game loop. Again, we don’t want to increase enemy as soon as the game starts, we only want to start increasing it after 3 seconds, so again, before the game loop, let’s call “ontimer” again, pass “increase_enemy” and 3000 milliseconds. Let’s test this!

* Test. Now, we still start with three enemies. But watch, as soon as the score becomes 3, which means we have stayed alive for 3 seconds, there is a a fourth enemy, and when the score becomes 6, we have a fifth enemy and this goes on. As time passes by, we see more and more enemies. And it’s becoming more and more difficult to dodge them! Oh my god, there are so many of them, ouch, I’m dead! |
|  |  |
|  |  |

### Exercise